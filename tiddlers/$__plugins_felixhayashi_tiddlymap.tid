author: Felix Küppers
core-version: >=5.1.5
created: 20190410085432249
dependents: $:/plugins/felixhayashi/vis
depends: $:/plugins/felixhayashi/vis
description: TiddlyMap – Map drawing and topic visualization for your wiki
list: readme license
modified: 20190410085432249
plugin-type: plugin
released: Tue, 29 Jan 2019 20:24:31 GMT
source: https://github.com/felixhayashi/TW5-TiddlyMap
suggested: $:/plugins/felixhayashi/topstoryview
title: $:/plugins/felixhayashi/tiddlymap
type: application/json
version: 0.15.4+9756

{
    "tiddlers": {
        "$:/plugins/felixhayashi/tiddlymap/layout": {
            "text": "\\rules only filteredtranscludeinline transcludeinline macrodef macrocallinline \n\n@charset \"UTF-8\";\n/********************************************************************\n * README                                                           \n ********************************************************************\n * \n * If you add some non-valid css string that won't compile and \n * unquote also doesn't help, do the following: in this stylesheet,\n * add a placeholder of the form __yourVariable__ at the point where\n * you need the string to be inserted. Then visit the gulpfile.js\n * file and add a replace instruction for your variable so it will\n * be replaced after the sass compiler has finished.\n * \n * Careful of the variable scope. Variables defined in partials\n * are visible everywhere https://gist.github.com/matyus/4339721.\n * \n *******************************************************************/\n/**\n * Returns a makedatauri macro\n */\n/**\n * Do not allow blurred background for dialogs\n * see: https://github.com/Jermolene/TiddlyWiki5/issues/1893\n */\nbody .tc-page-container-wrapper.tc-modal-displayed {\n  -webkit-filter: inherit;\n  -moz-filter: inherit;\n  filter: inherit; }\n\nbody .tc-modal-wrapper {\n  z-index: 1010; }\n  body .tc-modal-wrapper .tc-modal-header svg {\n    vertical-align: sub; }\n  body .tc-modal-wrapper .tc-modal-header h3 {\n    line-height: 10px; }\n  body .tc-modal-wrapper .tc-modal-body {\n    min-height: 250px;\n    max-height: 70vh;\n    padding-top: 0px;\n    padding-bottom: 0px;\n    overflow: auto; }\n  body .tc-modal-wrapper .tc-modal-footer {\n    padding: 8px; }\n    body .tc-modal-wrapper .tc-modal-footer .tmap-dialog-button {\n      font-weight: bold; }\n    body .tc-modal-wrapper .tc-modal-footer .tmap-hidden-close-button {\n      display: none; }\n\ntable.tmap-table tr, .tc-modal-body table.tmap-config-table tr {\n  /*\n    &:hover {\n      background-color: #FFFFF3;\n    }\n*/ }\n  table.tmap-table tr:nth-child(odd), .tc-modal-body table.tmap-config-table tr:nth-child(odd) {\n    background-color: #F0F0F0; }\n  table.tmap-table tr:nth-child(even), .tc-modal-body table.tmap-config-table tr:nth-child(even) {\n    background-color: #FFFFFF; }\n\n.tmap-save-canvas-preview {\n  text-align: center; }\n  .tmap-save-canvas-preview img {\n    background-color: white;\n    border: 1px solid lightgray;\n    max-width: 100%;\n    max-height: 100px; }\n\n.tmap-list-separator {\n  display: block;\n  background-color: #efefef;\n  margin: 10px 0 5px 0;\n  cursor: default;\n  border-bottom: 1px dotted gray;\n  font-weight: bold;\n  font-size: 0.8em; }\n\n.tmap-unicode-icon {\n  width: 1em;\n  display: inline-block;\n  text-align: center;\n  color: black; }\n\nhtml .tmap-link {\n  color: #5778D8; }\n  html .tmap-link:hover {\n    color: white;\n    background: #5778D8; }\n\nhtml .tmap-small-list, html .tmap-smaller-list, html .tmap-very-small-list {\n  overflow: auto;\n  min-height: 2em;\n  max-height: 9em;\n  display: block; }\n\nhtml .tmap-smaller-list {\n  max-height: 7em; }\n\nhtml .tmap-very-small-list {\n  max-height: 5empx; }\n\nhtml .tc-tiddler-controls button.tmap-active-button svg {\n  fill: #888888; }\n\nhtml #tmap-node-filter-dialog #tmap-filter-tips {\n  font-size: 0.8em; }\n\nhtml #tmap-node-filter-dialog textarea {\n  height: 100px;\n  max-height: 300px;\n  overflow: auto;\n  width: 100%;\n  font-size: 11px;\n  font-family: \"Courier New\", Courier, monospace; }\n\n@media (max-width: {{$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint}}) {\n  .tc-sidebar-scrollable .tmap-desktop-editor .tmap-widget:not(.tmap-fullscreen) {\n    display: none; } }\n\n@media (min-width: {{$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint}}) {\n  .tc-sidebar-scrollable .tmap-mobile-editor {\n    display: none; }\n  .tc-modal-wrapper {\n    z-index: 1010; }\n    .tc-modal-wrapper .tc-modal {\n      boder: 1px solid #999999;\n      left: calc(50% - 400px);\n      width: 802px; }\n    .tc-modal-wrapper .tc-modal-body {\n      left: calc(50% - 400px);\n      width: 800px; } }\n\n/**\n * see https://developer.mozilla.org/en/docs/Web/CSS/animation\n */\n/*** Keyframes for animations *************************************/\n@-o-keyframes fadein-keyframes {\n  0% {\n    opacity: 0; }\n  100% {\n    opacity: 1; } }\n\n@-moz-keyframes fadein-keyframes {\n  0% {\n    opacity: 0; }\n  100% {\n    opacity: 1; } }\n\n@-webkit-keyframes fadein-keyframes {\n  0% {\n    opacity: 0; }\n  100% {\n    opacity: 1; } }\n\n@keyframes flash fadein-keyframes {\n  0% {\n    opacity: 0; }\n  100% {\n    opacity: 1; } }\n\n@-o-keyframes fadeout-keyframes {\n  0% {\n    opacity: 1; }\n  100% {\n    opacity: 0; } }\n\n@-moz-keyframes fadeout-keyframes {\n  0% {\n    opacity: 1; }\n  100% {\n    opacity: 0; } }\n\n@-webkit-keyframes fadeout-keyframes {\n  0% {\n    opacity: 1; }\n  100% {\n    opacity: 0; } }\n\n@keyframes flash fadeout-keyframes {\n  0% {\n    opacity: 1; }\n  100% {\n    opacity: 0; } }\n\n.tmap-config-widget {\n  background: #F0F0F0;\n  padding: 5px;\n  margin: 5px 0;\n  box-sizing: border-box;\n  display: block; }\n  .tmap-config-widget .vis-network {\n    display: none; }\n  .tmap-config-widget .vis-configuration-wrapper {\n    width: 100%; }\n    .tmap-config-widget .vis-configuration-wrapper .vis-config-rangeinput {\n      height: inherit;\n      margin-left: 4px; }\n    .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item {\n      width: 100%;\n      height: inherit;\n      background: none;\n      padding-left: 0px;\n      left: 0; }\n      .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item.tmap-vis-config-item-active .vis-config-label::after {\n        content: \"(inherited)\";\n        position: absolute;\n        display: inline-block;\n        margin-left: 10px;\n        -o-animation: fadein-keyframes 1s;\n        -moz-animation: fadein-keyframes 1s;\n        -webkit-animation: fadein-keyframes 1s;\n        animation: fadein-keyframes 1s;\n        content: \"✔\";\n        color: green;\n        font-weight: bold;\n        font-size: 15px; }\n      .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item.tmap-vis-config-item-inactive .vis-config-label::after {\n        /*\n        @include marker;\n        content: \"✔\";\n        color: lightgray;\n        position: absolute;\n*/ }\n      .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item button.tmap-config-item-reset {\n        vertical-align: top;\n        margin-left: 5px; }\n      .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item .vis-config-range {\n        width: 150px; }\n        .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item .vis-config-range::-moz-range-track {\n          width: 150px !important; }\n      .tmap-config-widget .vis-configuration-wrapper .vis-configuration.vis-config-item .vis-config-label {\n        width: 150px; }\n  .tmap-config-widget::after {\n    clear: both;\n    content: \"\";\n    display: block; }\n\n/*\n$color-picker-height: 200;\ndiv div.vis-color-picker {\n  div.vis-color {\n    width: $color-picker-height + px;\n    height: $color-picker-height + px;\n  }\n  \n  div.vis-brightness {\n    top: ($color-picker-height + 30) + px;\n  }\n  \n  div.vis-label.vis-brightness {\n    top: ($color-picker-height + 43) + px;\n  }\n  \n  div.vis-label.vis-opacity {\n    top: 338px\n  }\n  \n  div.vis-opacity {\n    top: 351px;\n  }\n  div.vis-initial-color, vis-new-color {\n    top: 381px;\n  }\n  \n  div.vis-button {\n    top: 411px;\n  }\n\n}\n*/\n.tmap-flash-message {\n  border: 1px solid lightgray;\n  padding: 5px;\n  margin: 6px 0;\n  display: block;\n  color: #333333; }\n  .tmap-flash-message.tmap-info, .tmap-flash-message.tmap-plain, .tmap-flash-message.tmap-neutral {\n    background: #F0F0F0; }\n    .tmap-flash-message.tmap-info::before, .tmap-flash-message.tmap-plain::before, .tmap-flash-message.tmap-neutral::before {\n      content: \"i\";\n      display: inline-block;\n      border-radius: 50%;\n      width: 0.8em;\n      border: 2px solid;\n      font-family: serif;\n      text-align: center;\n      height: 0.8em;\n      font-weight: bold;\n      line-height: 0.8em;\n      vertical-align: text-top;\n      margin-right: 2px; }\n  .tmap-flash-message.tmap-valid, .tmap-flash-message.tmap-success {\n    background: #D1EED4; }\n    .tmap-flash-message.tmap-valid::before, .tmap-flash-message.tmap-success::before {\n      content: \"i\";\n      display: inline-block;\n      border-radius: 50%;\n      width: 0.8em;\n      border: 2px solid;\n      font-family: serif;\n      text-align: center;\n      height: 0.8em;\n      font-weight: bold;\n      line-height: 0.8em;\n      vertical-align: text-top;\n      margin-right: 2px; }\n  .tmap-flash-message.tmap-warning {\n    background: #FFF6D1; }\n    .tmap-flash-message.tmap-warning::before {\n      content: \"\";\n      display: inline-block;\n      background: url(<<tmap \"datauri\" \"$:/core/images/warning\" \"\">>);\n      display: inline-block;\n      width: 1em;\n      height: 1em;\n      background-size: 100% 100%;\n      vertical-align: text-top;\n      margin-right: 2px; }\n  .tmap-flash-message.tmap-malformed, .tmap-flash-message.tmap-invalid, .tmap-flash-message.tmap-danger {\n    background: #EED5D1; }\n    .tmap-flash-message.tmap-malformed::before, .tmap-flash-message.tmap-invalid::before, .tmap-flash-message.tmap-danger::before {\n      content: \"\";\n      display: inline-block;\n      background: url(<<tmap \"datauri\" \"$:/core/images/warning\" \"\">>);\n      display: inline-block;\n      width: 1em;\n      height: 1em;\n      background-size: 100% 100%;\n      vertical-align: text-top;\n      margin-right: 2px; }\n\n.tmap-widget {\n  background: #FFFFFF;\n  width: auto;\n  position: relative;\n  border: 1px dotted lightgray;\n  padding: 2px;\n  color: #666666;\n  display: block; }\n  .tmap-widget.tmap-click-to-use:not(.tmap-fullscreen) .vis-network:not(.vis-active) {\n    cursor: pointer; }\n    .tmap-widget.tmap-click-to-use:not(.tmap-fullscreen) .vis-network:not(.vis-active) .vis-navigation {\n      display: none; }\n    .tmap-widget.tmap-click-to-use:not(.tmap-fullscreen) .vis-network:not(.vis-active):hover:before {\n      color: gray;\n      background: white;\n      content: \"Click to use\";\n      font-size: 14px;\n      font-weight: bold;\n      right: calc(50% - 65px - 5px);\n      position: absolute;\n      text-align: center;\n      top: calc(50% - 14px - 5px);\n      width: 130px;\n      z-index: 2000;\n      padding: 5px;\n      pointer-events: none;\n      background-color: rgba(255, 255, 255, 0.3); }\n  .tmap-widget .tmap-loading-bar {\n    display: none;\n    position: absolute;\n    text-align: center;\n    font-size: 2em;\n    padding: 10px;\n    top: 50%;\n    background: rgba(245, 245, 245, 0.5);\n    z-index: 1;\n    width: 250px;\n    margin: auto;\n    left: 0px;\n    right: 0px; }\n  .tmap-widget .tmap-vis-graph {\n    height: calc(100% - 35px); }\n  .tmap-widget.tmap-no-buttons .vis-navigation {\n    display: none; }\n  .tmap-widget.tmap-advanced-editor .tmap-topbar {\n    background: #d6d9d8; }\n    .tmap-widget.tmap-advanced-editor .tmap-topbar .tmap-active-button {\n      color: #488DCD; }\n      .tmap-widget.tmap-advanced-editor .tmap-topbar .tmap-active-button svg {\n        fill: #488DCD; }\n    .tmap-widget.tmap-advanced-editor .tmap-topbar .tmap-unicode-button {\n      font-size: 1.5em;\n      vertical-align: bottom; }\n  .tmap-widget .tmap-menu-bar {\n    width: 100%; }\n  .tmap-widget .tmap-topbar {\n    background: #F5F5F5;\n    border-bottom: 1px solid lightgray;\n    padding: 3px 5px;\n    height: 35px;\n    position: relative; }\n    .tmap-widget .tmap-topbar .tmap-view-label {\n      width: 100%;\n      text-align: center;\n      font-weight: bold;\n      padding-top: 3px; }\n    .tmap-widget .tmap-topbar .tmap-focus-button {\n      position: absolute;\n      right: 10px;\n      top: 6px; }\n      .tmap-widget .tmap-topbar .tmap-focus-button input {\n        width: 140px; }\n    .tmap-widget .tmap-topbar .tmap-search-dropdown {\n      position: relative; }\n      .tmap-widget .tmap-topbar .tmap-search-dropdown .tc-drop-down {\n        position: absolute;\n        z-index: 999;\n        right: 0px; }\n    .tmap-widget .tmap-topbar [hidden] {\n      display: none; }\n    .tmap-widget .tmap-topbar select {\n      width: 30%;\n      max-width: 200px;\n      word-wrap: initial;\n      padding: 0px; }\n    .tmap-widget .tmap-topbar button {\n      line-height: inherit;\n      color: #666666; }\n    .tmap-widget .tmap-topbar > * {\n      display: inline-block; }\n    .tmap-widget .tmap-topbar .tmap-separator:after {\n      color: #bdbdbd;\n      margin: 3px;\n      content: \" | \"; }\n    .tmap-widget .tmap-topbar .tc-edit-add-tag .tc-add-tag-name input {\n      width: 70%; }\n    .tmap-widget .tmap-topbar .tc-sidebar-header {\n      text-shadow: none; }\n    .tmap-widget .tmap-topbar .tc-edit-tags {\n      border: none;\n      padding: inherit;\n      box-shadow: none; }\n\n.tmap-widget.tmap-static-mode .tmap-topbar {\n  height: initial; }\n\n.tmap-widget.tmap-static-mode .tmap-vis-graph {\n  text-align: center;\n  cursor: not-allowed; }\n  .tmap-widget.tmap-static-mode .tmap-vis-graph:not(.tmap-graph-placeholder):hover::before {\n    box-shadow: 10px 10px 5px lightgray;\n    color: gray;\n    background: white;\n    content: \"Static\";\n    font-size: 18px;\n    font-weight: bold;\n    left: 50%;\n    margin-left: -100px;\n    position: absolute;\n    text-align: center;\n    top: 50px;\n    width: 200px;\n    z-index: 2000;\n    padding: 5px;\n    pointer-events: none; }\n  .tmap-widget.tmap-static-mode .tmap-vis-graph.tmap-graph-placeholder::before {\n    content: \"No Preview\";\n    display: block;\n    text-align: center;\n    padding: 20px; }\n\n.tmap-widget .tc-drop-down {\n  min-width: 170px;\n  max-width: 210px;\n  padding: 5px;\n  margin: 5px 0; }\n  .tmap-widget .tc-drop-down button, .tmap-widget .tc-drop-down a {\n    padding: 0 2px;\n    text-decoration: none; }\n    .tmap-widget .tc-drop-down button:hover, .tmap-widget .tc-drop-down a:hover {\n      color: #ffffff; }\n    .tmap-widget .tc-drop-down button svg, .tmap-widget .tc-drop-down a svg {\n      vertical-align: middle; }\n\n.tmap-widget .tc-block-dropdown {\n  width: 370px;\n  min-width: 370px;\n  padding: 5px;\n  margin: 15px 0 0 -370px; }\n  .tmap-widget .tc-block-dropdown a {\n    display: inline;\n    padding: 0px; }\n\n.tmap-widget.tmap-plain-design {\n  border: none;\n  padding: 0px; }\n  .tmap-widget.tmap-plain-design .tmap-topbar {\n    display: none; }\n\n.tc-sidebar-scrollable .tmap-widget {\n  position: absolute;\n  min-height: 350px; }\n\n/*** vis ***********************************************************/\n.tmap-widget div.vis-network .vis-edit-mode {\n  height: 26px; }\n\n.tmap-widget div.vis-network .vis-manipulation {\n  height: 34px;\n  border-top: 1px solid #d6d9d8;\n  background: rgba(245, 245, 245, 0.7); }\n\n.tmap-widget div.vis-network .vis-navigation .vis-button.tmap-button-enabled {\n  right: 15px; }\n  .tmap-widget div.vis-network .vis-navigation .vis-button.tmap-button-enabled.tmap-fullscreen-button {\n    bottom: 90px;\n    background-image: url(<<tmap \"datauri\" \"$:/plugins/felixhayashi/tiddlymap/media/fullscreen.png\" \"\">>); }\n  .tmap-widget div.vis-network .vis-navigation .vis-button.tmap-button-enabled.tmap-halfscreen-button {\n    bottom: 130px;\n    background-image: url(<<tmap \"datauri\" \"$:/plugins/felixhayashi/tiddlymap/media/halfscreen.png\" \"\">>); }\n\n.tmap-widget div.vis-network .vis-navigation .vis-button:hover {\n  box-shadow: 0 0 3px 3px rgba(75, 75, 75, 0.3); }\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover:before {\n    background: beige;\n    display: block;\n    color: black;\n    padding: 3px;\n    position: relative;\n    border: 1px solid lightgray;\n    width: 80px;\n    left: -100px;\n    top: -50px;\n    z-index: 1000;\n    text-align: center; }\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-up:before {\n    left: 30px;\n    content: \"Scroll up\"; }\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-down:before {\n    left: 30px;\n    content: \"Scroll down\"; }\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-right:before {\n    left: 30px;\n    content: \"Scroll right\"; }\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-left:before {\n    left: 30px;\n    content: \"Scroll left\"; }\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-zoomOut:before {\n    content: \"Zoom out\"; }\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-zoomIn:before {\n    content: \"Zoom in\"; }\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.vis-zoomExtends:before {\n    content: \"Fit whole graph\"; }\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.tmap-fullscreen-button:before {\n    content: \"Toggle Fullscreen\"; }\n  .tmap-widget div.vis-network .vis-navigation .vis-button:hover.tmap-halfscreen-button:before {\n    content: \"Toggle Halfscreen\"; }\n\n.tc-dropzone > .tc-story-river .tmap-widget .vis-navigation .tmap-halfscreen-button {\n  display: none; }\n\n.tc-dropzone > .tc-story-river .tmap-widget:not(.tmap-fullscreen) .vis-navigation .vis-button {\n  display: none; }\n\n.tc-dropzone > .tc-story-river .tmap-widget:hover .vis-navigation .vis-button.tmap-fullscreen-button {\n  display: block; }\n\n.tc-dropzone > .tc-story-river .tmap-widget:hover .vis-navigation .vis-button.vis-zoomExtends {\n  display: block; }\n\n/*** Fullscreen ****************************************************/\nbody.tmap-has-fullscreen-widget {\n  overflow: hidden; }\n  body.tmap-has-fullscreen-widget .tmap-widget.tmap-fullscreen {\n    background: white !important;\n    height: 100% !important;\n    width: 100% !important;\n    position: fixed !important;\n    top: 0 !important;\n    right: 0 !important;\n    bottom: 0 !important;\n    left: 0 !important;\n    z-index: 999 !important;\n    border: none !important;\n    margin: 0 !important; }\n  body.tmap-has-fullscreen-widget .tc-dropzone > *.tmap-has-fullscreen-widget {\n    background: white !important;\n    height: 100% !important;\n    width: 100% !important;\n    position: fixed !important;\n    top: 0 !important;\n    right: 0 !important;\n    bottom: 0 !important;\n    left: 0 !important;\n    z-index: 999 !important;\n    border: none !important;\n    margin: 0 !important; }\n  body.tmap-has-fullscreen-widget .tc-dropzone > *:not(.tmap-has-fullscreen-widget) {\n    display: none; }\n\nbody.tmap-has-halfscreen-widget .tmap-widget.tmap-halfscreen {\n  background: white !important;\n  height: 100% !important;\n  width: 100% !important;\n  position: fixed !important;\n  top: 0 !important;\n  right: 0 !important;\n  bottom: 0 !important;\n  left: 0 !important;\n  z-index: 999 !important;\n  border: none !important;\n  margin: 0 !important;\n  position: absolute !important;\n  border-left: 1px solid lightgray !important; }\n\n.tc-modal-footer .tmap-hidden-close-button {\n  display: none; }\n\n.tmap-modal-content {\n  position: relative;\n  padding: 1em 0;\n  padding-top: 0; }\n  .tmap-modal-content table tr td {\n    vertical-align: top; }\n  .tmap-modal-content :not(pre) > code {\n    padding: 1px;\n    font-size: 0.9em;\n    position: relative;\n    top: -1px; }\n  .tmap-modal-content :not(pre) > code {\n    color: #666666; }\n  .tmap-modal-content .tc-tab-set .tc-tab-content {\n    margin-top: 0.5em; }\n  .tmap-modal-content .tc-image-button {\n    font-size: 14px; }\n  .tmap-modal-content fieldset {\n    margin: 0px; }\n    .tmap-modal-content fieldset legend {\n      font-weight: bold; }\n\n.tc-modal-body .tmap-modal-editor > p {\n  margin: 0px; }\n\n.tc-modal-body .tmap-modal-editor .tmap-template-select select {\n  width: 50%; }\n\n.tc-modal-body .tmap-modal-editor .tc-tiddler-frame {\n  margin: auto;\n  width: auto; }\n  .tc-modal-body .tmap-modal-editor .tc-tiddler-frame .tc-tiddler-controls {\n    display: none; }\n  .tc-modal-body .tmap-modal-editor .tc-tiddler-frame .tc-tiddler-title {\n    display: none; }\n\n.tc-modal-body table {\n  margin: 6px 0;\n  border: none;\n  width: 100%; }\n  .tc-modal-body table td, .tc-modal-body table th {\n    border: 1px solid lightgray; }\n  .tc-modal-body table.tmap-key-value-table th {\n    width: 30%;\n    background-color: #F0F0F0; }\n  .tc-modal-body table.tmap-config-table.tmap-large-input tr td:last-child {\n    width: 20%; }\n  .tc-modal-body table.tmap-config-table.tmap-small-input tr td:last-child {\n    width: 60%; }\n  .tc-modal-body table.tmap-config-table tr td {\n    border: none;\n    vertical-align: top;\n    padding: 5px; }\n    .tc-modal-body table.tmap-config-table tr td:first-child {\n      width: 15%; }\n    .tc-modal-body table.tmap-config-table tr td:last-child {\n      width: 40%; }\n    .tc-modal-body table.tmap-config-table tr td input:not([type=radio]), .tc-modal-body table.tmap-config-table tr td textarea, .tc-modal-body table.tmap-config-table tr td select {\n      width: 100%;\n      /* prevents bad looking select boxes and wrapping in textareas */\n      word-wrap: normal; }\n    .tc-modal-body table.tmap-config-table tr td textarea {\n      height: 100%; }\n    .tc-modal-body table.tmap-config-table tr td .tmap-no-stretch input, .tc-modal-body table.tmap-config-table tr td .tmap-no-stretch textarea, .tc-modal-body table.tmap-config-table tr td .tmap-no-stretch select {\n      width: auto; }\n    .tc-modal-body table.tmap-config-table tr td div.tmap-button-wrapper {\n      text-align: center; }\n    .tc-modal-body table.tmap-config-table tr td .tmap-note {\n      margin-top: 0.5em; }\n    .tc-modal-body table.tmap-config-table tr td .tmap-description {\n      font-style: italic; }\n\n#tmap-element-type-manager > div:first-child {\n  height: 50vh;\n  float: left;\n  width: 21%;\n  background: linear-gradient(90deg, whitesmoke 0%, white 50%); }\n  #tmap-element-type-manager > div:first-child .tmap-searchbar {\n    padding: 1em 0 0 0; }\n    #tmap-element-type-manager > div:first-child .tmap-searchbar input {\n      width: calc(100% - 36px); }\n    #tmap-element-type-manager > div:first-child .tmap-searchbar button {\n      width: 30px;\n      float: right; }\n  #tmap-element-type-manager > div:first-child ul {\n    height: calc(100% - 65px);\n    overflow: auto;\n    margin-top: 1em;\n    padding: 0; }\n    #tmap-element-type-manager > div:first-child ul.no-bullets li {\n      list-style: none; }\n    #tmap-element-type-manager > div:first-child ul li {\n      white-space: nowrap; }\n      #tmap-element-type-manager > div:first-child ul li .tmap-ranking {\n        width: 30px;\n        display: inline-block; }\n\n#tmap-element-type-manager > div:last-child {\n  height: 100%;\n  width: calc(79% - 15px);\n  float: right; }\n  #tmap-element-type-manager > div:last-child .tc-tab-set .tc-tab-content {\n    overflow: auto;\n    height: 50vh; }\n\n.tmap-manage-node-types .tmap-edge-type-specific {\n  display: none !important; }\n\n.tmap-manage-edge-types .tmap-node-type-specific {\n  display: none !important; }\n\n.tmap-modal-fullscreen-editor .tc-tab-content p {\n  margin: 1em 0; }\n\n.tmap-has-pending-template {\n  background-color: #C1EDC4; }\n\n#tmap-search-table td {\n  border: none;\n  padding-left: 0px; }\n  #tmap-search-table td:first-child {\n    width: 30px; }\n\n#tmap-search-table b {\n  display: inline-block;\n  width: 40px;\n  text-align: right; }\n\n#tmap-search-table ul {\n  padding-left: 20px;\n  margin: 1em 0 0 0; }\n  #tmap-search-table ul li {\n    list-style: inherit; }\n  #tmap-search-table ul button {\n    text-align: left; }\n\nbutton.tmap-go-back {\n  margin-bottom: 1em;\n  font-weight: bold; }\n\n.tmap-badges > span, .tmap-badge {\n  background: gray;\n  font-size: 11px;\n  color: white;\n  padding: 3px 4px;\n  display: inline-block;\n  font-weight: bold;\n  border-radius: 2px;\n  line-height: 1em;\n  cursor: help; }\n  .tmap-badges > span.tmap-red-flag, .tmap-badge.tmap-red-flag {\n    background: red; }\n\n/**\n * See http://stackoverflow.com/questions/3331353/transitions-on-the-display-property\n */\n.tmap-popup {\n  display: none;\n  position: absolute;\n  opacity: 0;\n  transition: opacity 0.3s ease; }\n  .tmap-popup.tmap-popup-active {\n    opacity: 1; }\n\n.tmap-tooltip {\n  box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\n  min-width: 100px;\n  min-height: 50px;\n  max-width: <<tmap option config.sys.popups.width>>;\n  max-height: <<tmap option config.sys.popups.height>>;\n  padding: 5px;\n  resize: both;\n  overflow: auto;\n  cursor: auto;\n  font-family: verdana;\n  font-size: 14px;\n  background-color: #f5f4ed;\n  border: 1px solid #808074;\n  -moz-border-radius: 3px;\n  -webkit-border-radius: 3px;\n  border-radius: 3px; }\n  .tmap-tooltip[style*=\"height\"] {\n    max-height: none !important; }\n  .tmap-tooltip[style*=\"width\"] {\n    max-width: none !important; }\n\n.tmap-quick-connect {\n  font-size: 0.7em; }\n  .tmap-quick-connect p {\n    padding-left: 0;\n    padding-right: 0; }\n  .tmap-quick-connect .tc-drop-down {\n    padding: 5px;\n    width: 250px;\n    white-space: normal;\n    line-height: 1em;\n    position: absolute;\n    z-index: 1000;\n    right: 50px;\n    background: linear-gradient(45deg, whitesmoke 0%, white 50%, whitesmoke 100%); }\n    .tmap-quick-connect .tc-drop-down:first-child {\n      padding-top: 0;\n      margin-top: 0; }\n    .tmap-quick-connect .tc-drop-down .title {\n      margin: 1.5em 0 0.5em 0;\n      font-weight: bold;\n      color: gray; }\n    .tmap-quick-connect .tc-drop-down select {\n      width: 80px;\n      word-wrap: initial; }\n    .tmap-quick-connect .tc-drop-down table {\n      width: 100%;\n      border: none;\n      margin: 0.5em 0; }\n      .tmap-quick-connect .tc-drop-down table td, .tmap-quick-connect .tc-drop-down table th {\n        padding: 3px 3px 3px 0;\n        vertical-align: middle;\n        font-weight: normal;\n        border: none; }\n        .tmap-quick-connect .tc-drop-down table td table, .tmap-quick-connect .tc-drop-down table th table {\n          margin: 0; }\n    .tmap-quick-connect .tc-drop-down .tmap-quick-connect-search-bar, .tmap-quick-connect .tc-drop-down .tmap-quick-connect-existing-bar {\n      background: #F1F1F1;\n      margin-top: 0;\n      border-bottom: 1px solid #D5D5D5;\n      border-top: 1px solid #D5D5D5; }\n    .tmap-quick-connect .tc-drop-down table.tmap-quick-connect-search-bar td, .tmap-quick-connect .tc-drop-down th {\n      padding: 5px; }\n    .tmap-quick-connect .tc-drop-down .tmap-quick-connect-existing-bar {\n      padding: 5px; }\n    .tmap-quick-connect .tc-drop-down .tmap-connection-table th, .tmap-quick-connect .tc-drop-down .tmap-connection-table td {\n      text-align: left;\n      padding: 1px 1px 1px 0; }\n    .tmap-quick-connect .tc-drop-down .tmap-connection-table button {\n      width: 20px;\n      padding: 0px; }\n    .tmap-quick-connect .tc-drop-down .tmap-scroll-table {\n      height: 120px;\n      overflow: auto;\n      display: block; }\n    .tmap-quick-connect .tc-drop-down hr {\n      border: 0;\n      height: 0;\n      border-top: 1px solid rgba(0, 0, 0, 0.1);\n      border-bottom: 1px solid rgba(255, 255, 255, 0.3); }\n    .tmap-quick-connect .tc-drop-down a {\n      display: inline;\n      padding: 0;\n      color: #5778d8;\n      background: transparent; }\n      .tmap-quick-connect .tc-drop-down a:hover {\n        background: transparent;\n        color: #5778d8;\n        text-decoration: underline; }\n    .tmap-quick-connect .tc-drop-down button {\n      display: inline-block;\n      padding: 0px 3px;\n      text-align: center;\n      color: #333333;\n      line-height: 1.0; }\n      .tmap-quick-connect .tc-drop-down button:hover {\n        color: #ffffff; }\n      .tmap-quick-connect .tc-drop-down button svg {\n        fill: inherit; }\n        .tmap-quick-connect .tc-drop-down button svg:hover {\n          fill: #ffffff; }\n",
            "title": "$:/plugins/felixhayashi/tiddlymap/layout",
            "type": "text/vnd.tiddlywiki",
            "tags": [
                "$:/tags/Stylesheet"
            ]
        },
        "$:/plugins/felixhayashi/tiddlymap/js/AbstractEdgeTypeSubscriber": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/AbstractEdgeTypeSubscriber",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/AbstractEdgeTypeSubscriber\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\nvar _EdgeType = require('$:/plugins/felixhayashi/tiddlymap/js/EdgeType');\n\nvar _EdgeType2 = _interopRequireDefault(_EdgeType);\n\nvar _exception = require('$:/plugins/felixhayashi/tiddlymap/js/exception');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Super class for all edge type subscribers.\n */\nvar AbstractEdgeTypeSubscriber = function () {\n\n  /**\n   * @param {Object.<id, EdgeType>} allEdgeTypes - A list of all EdgeType instances that\n   *     are currently in the system. Each subscriber may use this list to build up an\n   *     index or perform mappings etc. Note that this list does not include types that are\n   *     just about to be inserted. Therefore, this list should only be used, if needed,\n   *     in the context of edge retrieval via loadEdges.\n   * @param {number} [priority} - Subscribers with a higher priority get executed earlier\n   * @param {boolean} [skipOthers] - In case of insert and delete operations: Whether or\n   *     not to skip any subsequent subscribers that also can handle the edge type\n   *     but have a lower priority assigned.\n   * @param {boolean} [ignore] - Whether or not to completely ignore this subscriber.\n   *     This flag is useful if you want to dynamically at runtime whether or not to\n   *     include the subscriber.\n   */\n  function AbstractEdgeTypeSubscriber(allEdgeTypes) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$priority = _ref.priority,\n        priority = _ref$priority === undefined ? 0 : _ref$priority,\n        _ref$skipOthers = _ref.skipOthers,\n        skipOthers = _ref$skipOthers === undefined ? true : _ref$skipOthers,\n        _ref$ignore = _ref.ignore,\n        ignore = _ref$ignore === undefined ? false : _ref$ignore;\n\n    _classCallCheck(this, AbstractEdgeTypeSubscriber);\n\n    this.allEdgeTypes = allEdgeTypes;\n    this.priority = priority;\n    this.skipOthers = skipOthers;\n    this.ignore = ignore;\n  }\n\n  /**\n   * DI\n   * @param {Tracker} tracker\n   */\n\n\n  _createClass(AbstractEdgeTypeSubscriber, [{\n    key: 'setTracker',\n    value: function setTracker(tracker) {\n      this.tracker = tracker;\n    }\n\n    /**\n     * Returns all edges stored in the specified tiddler.\n     *\n     * @interface\n     * @param {Tiddler} tObj - the tiddler that holds the references.\n     * @param {Object<TiddlerReference, boolean>} toWL - a whitelist of tiddlers that are allowed to\n     *     be included in the result.\n     * @param {Object<id, EdgeType>} [typeWL] - a whitelist that defines that only Tiddlers that are linked\n     *     via a type specified in the list may be included in the result. If typeWL is not passed it means\n     *     all types are included.\n     * @return {Object<Id, Edge>|null}\n     */\n\n  }, {\n    key: 'loadEdges',\n    value: function loadEdges(tObj, toWL, typeWL) {\n\n      throw new _exception.MissingOverrideError(this, 'loadEdges');\n    }\n\n    /**\n     * Whether or not this subscriber instance can handle an edge of the given type.\n     *\n     * @interface\n     * @param {EdgeType} edgeType\n     * @return boolean\n     */\n\n  }, {\n    key: 'canHandle',\n    value: function canHandle(edgeType) {\n\n      throw new _exception.MissingOverrideError(this, 'canHandle');\n    }\n\n    /**\n     * Called by the Adapter whenever a type is inserted\n     *\n     * @param {Tiddler} tObj - the tiddler that holds the references.\n     * @param {Edge} edge - the edge to be deleted\n     * @param {EdgeType} type\n     */\n\n  }, {\n    key: 'insertEdge',\n    value: function insertEdge(tObj, edge, type) {}\n\n    // optional\n\n    /**\n     * Called by the Adapter whenever a type is deleted\n     *\n     * @param {Tiddler} tObj - the tiddler that holds the references.\n     * @param {Edge} edge - the edge to be deleted\n     * @param {EdgeType} type\n     */\n\n  }, {\n    key: 'deleteEdge',\n    value: function deleteEdge(tObj, edge, type) {\n\n      // optional\n\n    }\n  }]);\n\n  return AbstractEdgeTypeSubscriber;\n}();\n\n/*** Exports *******************************************************/\n\nexports.default = AbstractEdgeTypeSubscriber;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/edgeTypeSubscriber/AbstractEdgeTypeSubscriber.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/AbstractMagicEdgeTypeSubscriber": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/AbstractMagicEdgeTypeSubscriber",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _Edge = require('$:/plugins/felixhayashi/tiddlymap/js/Edge');\n\nvar _Edge2 = _interopRequireDefault(_Edge);\n\nvar _exception = require('$:/plugins/felixhayashi/tiddlymap/js/exception');\n\nvar _AbstractRefEdgeTypeSubscriber = require('$:/plugins/felixhayashi/tiddlymap/js/AbstractRefEdgeTypeSubscriber');\n\nvar _AbstractRefEdgeTypeSubscriber2 = _interopRequireDefault(_AbstractRefEdgeTypeSubscriber);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/AbstractMagicEdgeTypeSubscriber\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/**\n * @constructor\n */\nvar AbstractMagicEdgeTypeSubscriber = function (_AbstractRefEdgeTypeS) {\n  _inherits(AbstractMagicEdgeTypeSubscriber, _AbstractRefEdgeTypeS);\n\n  /**\n   * @inheritDoc\n   */\n  function AbstractMagicEdgeTypeSubscriber(allEdgeTypes, options) {\n    _classCallCheck(this, AbstractMagicEdgeTypeSubscriber);\n\n    // later used for edge retrieval to identify those fields that hold connections\n    var _this = _possibleConstructorReturn(this, (AbstractMagicEdgeTypeSubscriber.__proto__ || Object.getPrototypeOf(AbstractMagicEdgeTypeSubscriber)).call(this, allEdgeTypes, options));\n\n    _this.edgeTypesByFieldName = _utils2.default.makeHashMap();\n\n    for (var id in allEdgeTypes) {\n\n      var edgeType = allEdgeTypes[id];\n      if (_this.canHandle(edgeType)) {\n        _this.edgeTypesByFieldName[edgeType.name] = edgeType;\n      }\n    }\n\n    return _this;\n  }\n\n  /**\n   * Returns all references to other tiddlers stored in the specified tiddler.\n   *\n   * @interface\n   * @param {Tiddler} tObj - the tiddler that holds the references.\n   * @param {String} fieldName - the name of the field to get the reference from.\n   * @param {Object<TiddlerReference, boolean>} toWL - a whitelist of tiddlers that are allowed to\n   *     be included in the result.\n   * @return {Object<Id, Edge>|null}\n   */\n\n\n  _createClass(AbstractMagicEdgeTypeSubscriber, [{\n    key: 'getReferencesFromField',\n    value: function getReferencesFromField(tObj, fieldName, toWL) {\n\n      throw new _exception.MissingOverrideError(this, 'getReferencesFromField');\n    }\n  }, {\n    key: 'getReferences',\n\n\n    /**\n     * @inheritDoc\n     */\n    value: function getReferences(tObj, toWL, typeWL) {\n\n      var refsGroupedByType = _utils2.default.makeHashMap();\n      var fieldNames = tObj.fields;\n\n      for (var fieldName in fieldNames) {\n\n        var type = this.edgeTypesByFieldName[fieldName];\n\n        if (!type || typeWL && !typeWL[type.id]) continue;\n\n        var toRefs = this.getReferencesFromField(tObj, fieldName, toWL);\n\n        if (toRefs && toRefs.length) {\n          refsGroupedByType[type.id] = toRefs;\n        }\n      }\n\n      return refsGroupedByType;\n    }\n  }]);\n\n  return AbstractMagicEdgeTypeSubscriber;\n}(_AbstractRefEdgeTypeSubscriber2.default);\n\n/*** Exports *******************************************************/\n\nexports.default = AbstractMagicEdgeTypeSubscriber;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/edgeTypeSubscriber/AbstractMagicEdgeTypeSubscriber.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/AbstractRefEdgeTypeSubscriber": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/AbstractRefEdgeTypeSubscriber",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _Edge = require('$:/plugins/felixhayashi/tiddlymap/js/Edge');\n\nvar _Edge2 = _interopRequireDefault(_Edge);\n\nvar _exception = require('$:/plugins/felixhayashi/tiddlymap/js/exception');\n\nvar _AbstractEdgeTypeSubscriber = require('$:/plugins/felixhayashi/tiddlymap/js/AbstractEdgeTypeSubscriber');\n\nvar _AbstractEdgeTypeSubscriber2 = _interopRequireDefault(_AbstractEdgeTypeSubscriber);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/AbstractRefEdgeTypeSubscriber\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\n/*** Code **********************************************************/\n\n/**\n * Parent class for all subscribers that retrieve or store\n * non-TiddlyMap edges ({@see TmapEdgeTypeSubscriber) from a tiddler,\n * for example tag or list references.\n */\nvar AbstractRefEdgeTypeSubscriber = function (_AbstractEdgeTypeSubs) {\n  _inherits(AbstractRefEdgeTypeSubscriber, _AbstractEdgeTypeSubs);\n\n  function AbstractRefEdgeTypeSubscriber() {\n    _classCallCheck(this, AbstractRefEdgeTypeSubscriber);\n\n    return _possibleConstructorReturn(this, (AbstractRefEdgeTypeSubscriber.__proto__ || Object.getPrototypeOf(AbstractRefEdgeTypeSubscriber)).apply(this, arguments));\n  }\n\n  _createClass(AbstractRefEdgeTypeSubscriber, [{\n    key: 'loadEdges',\n\n\n    /**\n     * @inheritDoc\n     */\n    value: function loadEdges(tObj, toWL, typeWL) {\n\n      // references to other tiddlers grouped by their edge type\n      var refsByType = this.getReferences(tObj, toWL, typeWL);\n\n      if (!refsByType || !_utils2.default.hasElements(refsByType)) return;\n\n      var fromId = tObj.fields['tmap.id'];\n      var idByT = $tm.tracker.getIdsByTiddlers();\n      var allETy = this.allEdgeTypes;\n      var fromTRef = _utils2.default.getTiddlerRef(tObj);\n\n      var edges = _utils2.default.makeHashMap();\n\n      for (var typeId in refsByType) {\n\n        var toRefs = refsByType[typeId];\n\n        if (!toRefs) {\n          continue;\n        }\n\n        var type = allETy[typeId];\n        for (var i = toRefs.length; i--;) {\n          var toTRef = toRefs[i];\n\n          if (!toTRef || !$tw.wiki.tiddlerExists(toTRef) || _utils2.default.isSystemOrDraft(toTRef) || toWL && !toWL[toTRef]) {\n            continue;\n          }\n\n          var id = type.id + $tw.utils.hashString(fromTRef + toTRef);\n          edges[id] = new _Edge2.default(fromId, idByT[toTRef], type.id, id);\n        }\n      }\n\n      return edges;\n    }\n\n    /**\n     * Returns a list of tiddlers (= tiddler names) that are targeted by the specified tiddler.\n     * Note: All referenced tiddlers have to be grouped by their edge type.\n     *\n     * @interface\n     * @param {Tiddler} tObj - the tiddler that holds the references.\n     * @param {Object<TiddlerReference, boolean>} toWL - a whitelist of tiddlers that are allowed to\n     *     be included in the result.\n     * @param {Object<id, EdgeType>} typeWL - a whitelist that defines that only Tiddlers that are linked\n     *     via a type specified in the list may be included in the result.\n     * @return {Object<string, TiddlerReference[]>|null} a list of referenced tiddlers grouped by their edge type.\n     */\n\n  }, {\n    key: 'getReferences',\n    value: function getReferences(tObj, toWL, typeWL) {\n\n      throw new _exception.MissingOverrideError(this, 'getReferences');\n    }\n  }]);\n\n  return AbstractRefEdgeTypeSubscriber;\n}(_AbstractEdgeTypeSubscriber2.default);\n\n/*** Exports *******************************************************/\n\nexports.default = AbstractRefEdgeTypeSubscriber;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/edgeTypeSubscriber/AbstractRefEdgeTypeSubscriber.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/EdgeTypeSubscriberRegistry": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/EdgeTypeSubscriberRegistry",
            "text": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/EdgeTypeSubscriberRegistry\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/**\n * Registry to store and retrieve EdgeTypeSubcriber modules that are responsible\n * for handling the retrieval, insertion and deletion of EdgeType objects.\n */\nvar EdgeTypeSubscriberRegistry = function () {\n\n  /**\n   * @param {AbstractEdgeTypeSubscriber[]} subscribers\n   * @param {EdgeType[]} allEdgeTypes\n   * @param {Tracker} tracker\n   */\n  function EdgeTypeSubscriberRegistry(subscribers, allEdgeTypes, tracker) {\n    _classCallCheck(this, EdgeTypeSubscriberRegistry);\n\n    this.subscriberClasses = subscribers;\n    this.tracker = tracker;\n\n    this.updateIndex(allEdgeTypes);\n  }\n\n  /**\n   * Gets all matching subscribers for a type.\n   *\n   * @param {EdgeType} edgeType\n   * @returns AbstractEdgeTypeSubscriber[]\n   */\n\n\n  _createClass(EdgeTypeSubscriberRegistry, [{\n    key: \"getAllForType\",\n    value: function getAllForType(edgeType) {\n\n      var allSubscribers = this.allSubscribers;\n      var subscribersForType = [];\n\n      for (var i = 0, l = allSubscribers.length; i < l; i++) {\n\n        if (allSubscribers[i].canHandle(edgeType)) {\n\n          subscribersForType.push(allSubscribers[i]);\n\n          if (allSubscribers[i].skipOthers) {\n            break;\n          }\n        }\n      }\n\n      return subscribersForType;\n    }\n\n    /**\n     * Gets all subscribers.\n     *\n     * @returns AbstractEdgeTypeSubscriber[]\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n\n      return this.allSubscribers;\n    }\n\n    /**\n     * Indexes all subscribers. Moreover, subscribers get linked to the edge\n     * types that currently exist in the wiki.\n     *\n     * This method should be called everytime after an edge type is added or\n     * removed in the system.\n     *\n     * @param {EdgeType[]} allEdgeTypes\n     */\n\n  }, {\n    key: \"updateIndex\",\n    value: function updateIndex(allEdgeTypes) {\n\n      var allSubscribers = [];\n\n      // instantiate and register all active subscriber modules\n      var subscriberClass = this.subscriberClasses;\n      for (var moduleName in subscriberClass) {\n\n        var subscriber = new subscriberClass[moduleName](allEdgeTypes);\n        subscriber.setTracker(this.tracker);\n\n        // ignore all subscribers that have their ignore flag set to false\n        if (subscriber.ignore === true) {\n          continue;\n        }\n\n        allSubscribers.push(subscriber);\n      }\n\n      // sort subscribers by priority\n      allSubscribers.sort(function (s1, s2) {\n        return s2.priority - s1.priority;\n      });\n\n      this.allSubscribers = allSubscribers;\n    }\n  }]);\n\n  return EdgeTypeSubscriberRegistry;\n}();\n\n/*** Exports *******************************************************/\n\nexports.default = EdgeTypeSubscriberRegistry;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/edgeTypeSubscriber/EdgeTypeSubscriberRegistry.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/tmap": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/tmap",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TmapEdgeTypeSubscriber = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _Edge = require('$:/plugins/felixhayashi/tiddlymap/js/Edge');\n\nvar _Edge2 = _interopRequireDefault(_Edge);\n\nvar _AbstractEdgeTypeSubscriber = require('$:/plugins/felixhayashi/tiddlymap/js/AbstractEdgeTypeSubscriber');\n\nvar _AbstractEdgeTypeSubscriber2 = _interopRequireDefault(_AbstractEdgeTypeSubscriber);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/tmap\ntype: application/javascript\nmodule-type: tmap.edgetypehandler\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\n/*** Code **********************************************************/\n\n/**\n * TiddlyMap's original EdgeTypeSubscriber. It will store and retrieve edges by relying on\n * json stored in a tiddler field.\n *\n * @constructor\n */\nvar TmapEdgeTypeSubscriber = function (_AbstractEdgeTypeSubs) {\n  _inherits(TmapEdgeTypeSubscriber, _AbstractEdgeTypeSubs);\n\n  function TmapEdgeTypeSubscriber(allEdgeTypes) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TmapEdgeTypeSubscriber);\n\n    return _possibleConstructorReturn(this, (TmapEdgeTypeSubscriber.__proto__ || Object.getPrototypeOf(TmapEdgeTypeSubscriber)).call(this, allEdgeTypes, _extends({ priority: 0 }, options)));\n  }\n\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(TmapEdgeTypeSubscriber, [{\n    key: 'loadEdges',\n    value: function loadEdges(tObj, toWL, typeWL) {\n\n      var connections = _utils2.default.parseFieldData(tObj, 'tmap.edges');\n      if (!connections) {\n        return;\n      }\n\n      var tById = this.tracker.getTiddlersByIds();\n      var fromId = tObj.fields['tmap.id'];\n\n      var edges = _utils2.default.makeHashMap();\n\n      for (var conId in connections) {\n\n        var con = connections[conId];\n        var toTRef = tById[con.to];\n        if (toTRef && (!toWL || toWL[toTRef]) && (!typeWL || typeWL[con.type])) {\n\n          edges[conId] = new _Edge2.default(fromId, con.to, con.type, conId);\n        }\n      }\n\n      return edges;\n    }\n\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: 'insertEdge',\n    value: function insertEdge(tObj, edge, type) {\n\n      // load existing connections\n      var connections = _utils2.default.parseFieldData(tObj, 'tmap.edges', {});\n\n      // assign new id if not present yet\n      edge.id = edge.id || _utils2.default.genUUID();\n      // add to connections object\n      connections[edge.id] = { to: edge.to, type: type.id };\n\n      // save\n      _utils2.default.writeFieldData(tObj, 'tmap.edges', connections, $tm.config.sys.jsonIndentation);\n\n      return edge;\n    }\n\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: 'deleteEdge',\n    value: function deleteEdge(tObj, edge, type) {\n\n      if (!edge.id) return;\n\n      // load\n      var connections = _utils2.default.parseFieldData(tObj, 'tmap.edges', {});\n\n      // delete\n      delete connections[edge.id];\n\n      // save\n      _utils2.default.writeFieldData(tObj, 'tmap.edges', connections, $tm.config.sys.jsonIndentation);\n\n      return edge;\n    }\n\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: 'canHandle',\n    value: function canHandle(edgeType) {\n\n      return true;\n    }\n  }]);\n\n  return TmapEdgeTypeSubscriber;\n}(_AbstractEdgeTypeSubscriber2.default);\n\n/*** Exports *******************************************************/\n\nexports.TmapEdgeTypeSubscriber = TmapEdgeTypeSubscriber;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/edgeTypeSubscriber/TmapEdgeTypeSubscriber.js.map\n",
            "type": "application/javascript",
            "module-type": "tmap.edgetypehandler"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/field": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/field",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FieldEdgeTypeSubscriber = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _AbstractMagicEdgeTypeSubscriber = require('$:/plugins/felixhayashi/tiddlymap/js/AbstractMagicEdgeTypeSubscriber');\n\nvar _AbstractMagicEdgeTypeSubscriber2 = _interopRequireDefault(_AbstractMagicEdgeTypeSubscriber);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/field\ntype: application/javascript\nmodule-type: tmap.edgetypehandler\n\n@preserve\n\n\\*/\n\n/**\n * The FieldEdgeTypeSubscriber deals with connections that are stored in form of tiddler fields.\n * In this case one field can only hold one connection.\n *\n * If an EdgeType with a \"tw-field\" namespace is inserted or deleted, the type's name\n * is interpreted as field name and the connection is stored or removed in a tiddler\n * field with of that name.\n *\n * E.g. creating an edge between the tiddlers \"Betsy\" and \"Dave\" with the type\n * tw-field:husband will create a field \"husband\" inside the \"Betsy\" tiddler and set\n * \"Dave\" as value.\n\n * Note: A single field can only hold one connection.\n *\n * @see http://tiddlymap.org/#tw-field\n *\n * @inheritDoc\n * @constructor\n */\nvar FieldEdgeTypeSubscriber = function (_AbstractMagicEdgeTyp) {\n  _inherits(FieldEdgeTypeSubscriber, _AbstractMagicEdgeTyp);\n\n  /**\n   * @inheritDoc\n   */\n  function FieldEdgeTypeSubscriber(allEdgeTypes) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, FieldEdgeTypeSubscriber);\n\n    return _possibleConstructorReturn(this, (FieldEdgeTypeSubscriber.__proto__ || Object.getPrototypeOf(FieldEdgeTypeSubscriber)).call(this, allEdgeTypes, _extends({ priority: 10 }, options)));\n  }\n\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(FieldEdgeTypeSubscriber, [{\n    key: 'canHandle',\n    value: function canHandle(edgeType) {\n\n      return edgeType.namespace === 'tw-field';\n    }\n\n    /**\n     * @override\n     */\n\n  }, {\n    key: 'getReferencesFromField',\n    value: function getReferencesFromField(tObj, fieldName, toWL) {\n\n      // wrap in array\n      return [tObj.fields[fieldName]];\n    }\n\n    /**\n     * Stores and maybe overrides an edge in this tiddler\n     */\n\n  }, {\n    key: 'insertEdge',\n    value: function insertEdge(tObj, edge, type) {\n\n      var toTRef = this.tracker.getTiddlerById(edge.to);\n      if (toTRef == null) {\n        // null or undefined\n        return;\n      }\n\n      // only use the name without the private marker or the namespace\n      _utils2.default.setField(tObj, type.name, toTRef);\n\n      return edge;\n    }\n  }, {\n    key: 'deleteEdge',\n\n\n    /**\n     * Deletes an edge in this tiddler\n     */\n    value: function deleteEdge(tObj, edge, type) {\n\n      var toTRef = this.tracker.getTiddlerById(edge.to);\n\n      if (toTRef == null) {\n        // null or undefined\n        return;\n      }\n\n      // only use the name without the private marker or the namespace\n      _utils2.default.setField(tObj, type.name, undefined);\n\n      return edge;\n    }\n  }]);\n\n  return FieldEdgeTypeSubscriber;\n}(_AbstractMagicEdgeTypeSubscriber2.default);\n\n/*** Exports *******************************************************/\n\nexports.FieldEdgeTypeSubscriber = FieldEdgeTypeSubscriber;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/edgeTypeSubscriber/magicEdgeTypeSubscriber/FieldEdgeTypeSubscriber.js.map\n",
            "type": "application/javascript",
            "module-type": "tmap.edgetypehandler"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/filter": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/filter",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FilterEdgeTypeSubstriber = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _AbstractMagicEdgeTypeSubscriber = require('$:/plugins/felixhayashi/tiddlymap/js/AbstractMagicEdgeTypeSubscriber');\n\nvar _AbstractMagicEdgeTypeSubscriber2 = _interopRequireDefault(_AbstractMagicEdgeTypeSubscriber);\n\nvar _widget = require('$:/core/modules/widgets/widget.js');\n\nvar _widget2 = _interopRequireDefault(_widget);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/filter\ntype: application/javascript\nmodule-type: tmap.edgetypehandler\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\n/*** Code **********************************************************/\n\n/**\n * The FilterEdgeTypeSubstriber deals with connections that are stored inside\n * tiddler fields via a dynamic filter.\n *\n * @see http://tiddlymap.org/#tw-filter\n * @see https://github.com/felixhayashi/TW5-TiddlyMap/issues/206\n */\nvar FilterEdgeTypeSubstriber = function (_AbstractMagicEdgeTyp) {\n  _inherits(FilterEdgeTypeSubstriber, _AbstractMagicEdgeTyp);\n\n  /**\n   * @inheritDoc\n   */\n  function FilterEdgeTypeSubstriber(allEdgeTypes) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, FilterEdgeTypeSubstriber);\n\n    return _possibleConstructorReturn(this, (FilterEdgeTypeSubstriber.__proto__ || Object.getPrototypeOf(FilterEdgeTypeSubstriber)).call(this, allEdgeTypes, _extends({ priority: 10 }, options)));\n  }\n\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(FilterEdgeTypeSubstriber, [{\n    key: 'canHandle',\n    value: function canHandle(edgeType) {\n\n      return edgeType.namespace === 'tw-filter';\n    }\n\n    /**\n     * @override\n     */\n\n  }, {\n    key: 'getReferencesFromField',\n    value: function getReferencesFromField(tObj, fieldName, toWL) {\n\n      var filter = tObj.fields[fieldName];\n\n      // Solves https://github.com/felixhayashi/TW5-TiddlyMap/issues/278\n      var parentWidget = new _widget2.default.widget({});\n      parentWidget.setVariable(\"currentTiddler\", tObj.fields.title);\n      var widget = new _widget2.default.widget({}, { \"parentWidget\": parentWidget });\n      //noinspection UnnecessaryLocalVariableJS\n      var toRefs = _utils2.default.getMatches(filter, toWL, widget);\n\n      return toRefs;\n    }\n\n    /**\n     * Stores and maybe overrides an edge in this tiddler\n     */\n\n  }, {\n    key: 'insertEdge',\n    value: function insertEdge(tObj, edge, type) {\n\n      if (!edge.to) {\n        return;\n      }\n\n      // get the name without the private marker or the namespace\n      var name = type.name;\n      var currentFilter = tObj.fields[name] || \"\";\n      var toTRef = this.tracker.getTiddlerById(edge.to);\n      // by treating the toTRef as a list of one, we can make\n      // it safe to append to any filter.\n      // \"tiddler\" -> \"tiddler\"\n      // \"tiddler with spaces\" -> \"[[tiddler with spaces]]\"\n      var safe_toTRef = $tw.utils.stringifyList([toTRef]);\n\n      if (currentFilter.length > 0) {\n        safe_toTRef = \" \" + safe_toTRef;\n      }\n\n      // save\n      _utils2.default.setField(tObj, name, currentFilter + safe_toTRef);\n\n      return edge;\n    }\n  }]);\n\n  return FilterEdgeTypeSubstriber;\n}(_AbstractMagicEdgeTypeSubscriber2.default);\n\n/*** Exports *******************************************************/\n\nexports.FilterEdgeTypeSubstriber = FilterEdgeTypeSubstriber;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/edgeTypeSubscriber/magicEdgeTypeSubscriber/FilterEdgeTypeSubscriber.js.map\n",
            "type": "application/javascript",
            "module-type": "tmap.edgetypehandler"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/list": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/list",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ListEdgeTypeSubscriber = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _AbstractMagicEdgeTypeSubscriber = require('$:/plugins/felixhayashi/tiddlymap/js/AbstractMagicEdgeTypeSubscriber');\n\nvar _AbstractMagicEdgeTypeSubscriber2 = _interopRequireDefault(_AbstractMagicEdgeTypeSubscriber);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/list\ntype: application/javascript\nmodule-type: tmap.edgetypehandler\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\n/*** Code **********************************************************/\n\n/**\n * The ListEdgeTypeSubstriber deals with connections that are stored inside\n * tiddler fields in a tiddler-list format.\n *\n * If an EdgeType with a 'tw-list\" namespace is inserted or deleted, the type's name\n * is interpreted as field name and the list of connections is stored or removed in a tiddler\n * field with of that name. Each outgoing connection to a tiddler is stored by\n * inserting the title the edge is pointing to into a list.\n *\n * Say you the user creates a connection between tiddler \"Dawna Dozal\" and\n * tiddler \"Toney Thacker\" and names the connection \"tw-list:friends\". Then a field\n * named \"friends\" will be created in tiddler \"Dawna Dozal\" and \"Toney Thacker\" will be\n * added to this field.\n *\n * @see http://tiddlymap.org/#tw-list\n */\nvar ListEdgeTypeSubscriber = function (_AbstractMagicEdgeTyp) {\n  _inherits(ListEdgeTypeSubscriber, _AbstractMagicEdgeTyp);\n\n  /**\n   * @inheritDoc\n   */\n  function ListEdgeTypeSubscriber(allEdgeTypes) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, ListEdgeTypeSubscriber);\n\n    return _possibleConstructorReturn(this, (ListEdgeTypeSubscriber.__proto__ || Object.getPrototypeOf(ListEdgeTypeSubscriber)).call(this, allEdgeTypes, _extends({ priority: 10 }, options)));\n  }\n\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(ListEdgeTypeSubscriber, [{\n    key: 'canHandle',\n    value: function canHandle(edgeType) {\n\n      return edgeType.namespace === 'tw-list';\n    }\n\n    /**\n     * @override\n     */\n\n  }, {\n    key: 'getReferencesFromField',\n    value: function getReferencesFromField(tObj, fieldName, toWL) {\n\n      return $tw.utils.parseStringArray(tObj.fields[fieldName]);\n    }\n\n    /**\n     * Stores and maybe overrides an edge in this tiddler\n     */\n\n  }, {\n    key: 'insertEdge',\n    value: function insertEdge(tObj, edge, type) {\n\n      if (!edge.to) {\n        return;\n      }\n\n      // get the name without the private marker or the namespace\n      var name = type.name;\n\n      var list = $tw.utils.parseStringArray(tObj.fields[name]);\n      // we need to clone the array since tiddlywiki might directly\n      // returned the auto-parsed field value (as in case of tags, or list)\n      // and this array would be read only!\n      list = (list || []).slice();\n\n      // transform\n      var toTRef = this.tracker.getTiddlerById(edge.to);\n\n      list.push(toTRef);\n\n      // save\n      _utils2.default.setField(tObj, name, $tw.utils.stringifyList(list));\n\n      return edge;\n    }\n  }, {\n    key: 'deleteEdge',\n\n\n    /**\n     * Deletes an edge in this tiddler\n     */\n    value: function deleteEdge(tObj, edge, type) {\n\n      var list = $tw.utils.parseStringArray(tObj.fields[type.name]);\n      // we need to clone the array since tiddlywiki might directly\n      // returned the auto-parsed field value (as in case of tags, or list)\n      // and this array would be read only!\n      list = (list || []).slice();\n\n      // transform\n      var toTRef = this.tracker.getTiddlerById(edge.to);\n\n      var index = list.indexOf(toTRef);\n      if (index > -1) {\n        list.splice(index, 1);\n      }\n\n      // @see https://github.com/felixhayashi/TW5-TiddlyMap/issues/288\n      var stringList = void 0;\n      if (list.length > 0) {\n        stringList = $tw.utils.stringifyList(list);\n      }\n      // save\n      _utils2.default.setField(tObj, type.name, stringList);\n\n      return edge;\n    }\n  }]);\n\n  return ListEdgeTypeSubscriber;\n}(_AbstractMagicEdgeTypeSubscriber2.default);\n\n/*** Exports *******************************************************/\n\nexports.ListEdgeTypeSubscriber = ListEdgeTypeSubscriber;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/edgeTypeSubscriber/magicEdgeTypeSubscriber/ListEdgeTypeSubscriber.js.map\n",
            "type": "application/javascript",
            "module-type": "tmap.edgetypehandler"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/body/link": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/body/link",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LinkEdgeTypeSubscriber = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _AbstractRefEdgeTypeSubscriber = require('$:/plugins/felixhayashi/tiddlymap/js/AbstractRefEdgeTypeSubscriber');\n\nvar _AbstractRefEdgeTypeSubscriber2 = _interopRequireDefault(_AbstractRefEdgeTypeSubscriber);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/body/link\ntype: application/javascript\nmodule-type: tmap.edgetypehandler\n\n@preserve\n\n\\*/\n\n/**\n * The LinkEdgeTypeSubscriber deals with connections that are stored inside\n * a tiddler' text field.\n *\n * Note: This subscriber only retrieves edges, however doesn't store or delete them.\n *\n * @see http://tiddlymap.org/#tw-body\n */\nvar LinkEdgeTypeSubscriber = function (_AbstractRefEdgeTypeS) {\n  _inherits(LinkEdgeTypeSubscriber, _AbstractRefEdgeTypeS);\n\n  /**\n   * @inheritDoc\n   */\n  function LinkEdgeTypeSubscriber(allEdgeTypes) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, LinkEdgeTypeSubscriber);\n\n    return _possibleConstructorReturn(this, (LinkEdgeTypeSubscriber.__proto__ || Object.getPrototypeOf(LinkEdgeTypeSubscriber)).call(this, allEdgeTypes, _extends({ priority: 20 }, options)));\n  }\n\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(LinkEdgeTypeSubscriber, [{\n    key: 'canHandle',\n    value: function canHandle(edgeType) {\n\n      return edgeType.id === 'tw-body:link';\n    }\n\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: 'getReferences',\n    value: function getReferences(tObj, toWL, typeWL) {\n\n      if (typeWL && !typeWL['tw-body:link']) {\n        return;\n      }\n\n      var toRefs = $tw.wiki.getTiddlerLinks(tObj.fields.title);\n\n      if (!toRefs || !toRefs.length) {\n        return;\n      }\n\n      return { 'tw-body:link': toRefs };\n    }\n  }]);\n\n  return LinkEdgeTypeSubscriber;\n}(_AbstractRefEdgeTypeSubscriber2.default);\n\n/*** Exports *******************************************************/\n\nexports.LinkEdgeTypeSubscriber = LinkEdgeTypeSubscriber;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/edgeTypeSubscriber/refEdgeTypeSubscriber/LinkEdgeTypeSubscriber.js.map\n",
            "type": "application/javascript",
            "module-type": "tmap.edgetypehandler"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/body/transclude": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/body/transclude",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TranscludeEdgeTypeSubscriber = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _AbstractRefEdgeTypeSubscriber = require('$:/plugins/felixhayashi/tiddlymap/js/AbstractRefEdgeTypeSubscriber');\n\nvar _AbstractRefEdgeTypeSubscriber2 = _interopRequireDefault(_AbstractRefEdgeTypeSubscriber);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/modules/edge-type-handler/body/transclude\ntype: application/javascript\nmodule-type: tmap.edgetypehandler\n\n@preserve\n\n\\*/\n\n/**\n * The TranscludeEdgeTypeSubscriber retrieves connections that result tiddler transclusions.\n *\n * Note: This subscriber only retrieves edges, however doesn't store or delete them. It only\n * works if the `$tw.wiki.getTiddlerTranscludes` method is present in the wiki.\n */\nvar TranscludeEdgeTypeSubscriber = function (_AbstractRefEdgeTypeS) {\n  _inherits(TranscludeEdgeTypeSubscriber, _AbstractRefEdgeTypeS);\n\n  /**\n   * @inheritDoc\n   */\n  function TranscludeEdgeTypeSubscriber(allEdgeTypes) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TranscludeEdgeTypeSubscriber);\n\n    return _possibleConstructorReturn(this, (TranscludeEdgeTypeSubscriber.__proto__ || Object.getPrototypeOf(TranscludeEdgeTypeSubscriber)).call(this, allEdgeTypes, _extends({\n      priority: 20,\n      ignore: typeof $tw.wiki.getTiddlerTranscludes !== 'function'\n    }, options)));\n  }\n\n  /**\n   * @inheritDoc\n   */\n\n\n  _createClass(TranscludeEdgeTypeSubscriber, [{\n    key: 'canHandle',\n    value: function canHandle(edgeType) {\n\n      return edgeType.id === 'tw-body:transclude';\n    }\n\n    /**\n     * @inheritDoc\n     */\n\n  }, {\n    key: 'getReferences',\n    value: function getReferences(tObj, toWL, typeWL) {\n\n      if (typeWL && !typeWL['tw-body:transclude']) {\n        return;\n      }\n\n      var toRefs = $tw.wiki.getTiddlerTranscludes(tObj.fields.title);\n\n      if (!toRefs || !toRefs.length) {\n        return;\n      }\n\n      return { 'tw-body:transclude': toRefs };\n    }\n  }]);\n\n  return TranscludeEdgeTypeSubscriber;\n}(_AbstractRefEdgeTypeSubscriber2.default);\n\n/*** Exports *******************************************************/\n\nexports.TranscludeEdgeTypeSubscriber = TranscludeEdgeTypeSubscriber;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/edgeTypeSubscriber/refEdgeTypeSubscriber/TranscludeEdgeTypeSubscriber.js.map\n",
            "type": "application/javascript",
            "module-type": "tmap.edgetypehandler"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/Edge": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/Edge",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/Edge\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\n/*** Code **********************************************************/\n\n/**\n * @constructor\n */\nvar Edge = function Edge(from, to, type, id) {\n  _classCallCheck(this, Edge);\n\n  this.from = from;\n  this.to = to;\n  this.type = type;\n  this.id = id || _utils2.default.genUUID();\n};\n\n/*** Exports *******************************************************/\n\nexports.default = Edge;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/graph/Edge.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/EdgeType": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/EdgeType",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _MapElementType2 = require('$:/plugins/felixhayashi/tiddlymap/js/MapElementType');\n\nvar _MapElementType3 = _interopRequireDefault(_MapElementType2);\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _environment = require('$:/plugins/felixhayashi/tiddlymap/js/lib/environment');\n\nvar env = _interopRequireWildcard(_environment);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/EdgeType\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\n/*** Code **********************************************************/\n\n/**\n * This class is used to abstract edge types. It facilitates the parsing\n * of style information, the translation of type names into actual type data\n * or the persistance of edge type data.\n *\n * Note: EdgeType instances are immutable (frozen).\n */\nvar EdgeType = function (_MapElementType) {\n  _inherits(EdgeType, _MapElementType);\n\n  /**\n   * @param {EdgeTypeId} id\n   * @param {Object} [data] @see http://visjs.org/docs/network/edges.html\n   */\n  function EdgeType(id, data) {\n    _classCallCheck(this, EdgeType);\n\n    // we do not simply use the provided id but disassemble and\n    // reassemble it again to ensure the id is well formatted.\n    var _EdgeType$getIdParts = EdgeType.getIdParts(id),\n        marker = _EdgeType$getIdParts.marker,\n        namespace = _EdgeType$getIdParts.namespace,\n        name = _EdgeType$getIdParts.name;\n\n    id = EdgeType.getId(marker, namespace, name);\n\n    // call the parent constructor\n\n    var _this = _possibleConstructorReturn(this, (EdgeType.__proto__ || Object.getPrototypeOf(EdgeType)).call(this, id, env.path.edgeTypes, EdgeType.fieldMeta, data));\n\n    _this.id = id;\n    _this.marker = marker;\n    _this.name = name;\n    _this.namespace = namespace;\n\n    var arrows = (_this.style || {}).arrows;\n\n    if (arrows) {\n\n      _this.invertedArrow = isArrowEnabled(arrows, 'from');\n      _this.toArrow = isArrowEnabled(arrows, 'to') || isArrowEnabled(arrows, 'middle');\n      // determine if bi arrows (either from+to or no arrows)\n      _this.biArrow = _this.invertedArrow === _this.toArrow;\n\n      if (_this.biArrow) {\n        _this.toArrow = true;\n        _this.invertedArrow = true;\n      }\n    } else {\n\n      _this.toArrow = true;\n    }\n\n    Object.freeze(_this);\n\n    return _this;\n  }\n\n  /**\n   * Returns an object holding the parts that make up the edge type id.\n   *\n   * @param {EdgeTypeId} id\n   * @return {{marker: (*|string), namespace: (*|string), name: (*|string)}}\n   */\n\n\n  _createClass(EdgeType, [{\n    key: 'getLabel',\n    value: function getLabel() {\n\n      return this.label || this.name;\n    }\n  }], [{\n    key: 'getIdParts',\n    value: function getIdParts() {\n      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n\n      id = _utils2.default.getWithoutPrefix(id, env.path.edgeTypes + '/');\n      var match = id.match(edgeTypeRegex) || [];\n\n      return {\n        marker: match[1] || '',\n        namespace: match[3] && match[2] || '',\n        name: match[3] || match[2] || ''\n      };\n    }\n  }, {\n    key: 'getId',\n\n\n    /**\n     * Creates an {@link EdgeTypeId} from a set of parts that make up the id.\n     * If it is not possible to create the id from the parts, the default\n     * edge type 'tmap:unknown' is returned.\n     *\n     * @param {string} marker\n     * @param {string} namespace\n     * @param {string} name\n     * @return {EdgeTypeId}\n     */\n    value: function getId() {\n      var marker = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var name = arguments[2];\n\n\n      return name ? marker + (namespace && namespace + ':') + name : 'tmap:unknown';\n    }\n  }]);\n\n  return EdgeType;\n}(_MapElementType3.default);\n\n/**\n  * @see https://github.com/babel/babel/issues/4854\n  * @param {string} id - Either the edge type id (name)\n  *     or a tiddler reference denoting the type or an\n  *     `EdgeType` object (that is directly bounced back). If the\n  *     id can be translated into a tiddler object that resides in\n  *     the edge type path, then its data is retrieved automatically.\n */\n\n\nEdgeType.getInstance = function (id) {\n  return id instanceof EdgeType ? id : new EdgeType(id);\n};\n\nEdgeType.fieldMeta = _extends({}, _MapElementType3.default.fieldMeta, {\n  'label': {},\n  'show-label': {}\n});\n\n/**\n *\n * @param {Object} arrows\n * @param {('from'|'to'|'middle')} direction\n * @return {boolean}\n */\nvar isArrowEnabled = function isArrowEnabled(arrows, direction) {\n\n  var arrow = arrows[direction];\n\n  if (arrow == null && direction === 'to') {\n    // if the arrow is not further specified and its direction is to\n    // we regard it as enabled.\n    return true;\n  }\n\n  return (typeof arrow === 'undefined' ? 'undefined' : _typeof(arrow)) === 'object' ? arrow.enabled !== false : arrow === true;\n};\n\n/**\n * An edge-type id consists of the following parts of which the\n * first two are optional: `[marker][namespace:]name`\n *\n * The colon is not considered to be part of the namespace.\n */\nvar edgeTypeRegex = new RegExp('^(_?)([^:_][^:]*):?([^:]*)');\n\n/*** Exports *******************************************************/\n\nexports.default = EdgeType;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/graph/EdgeType.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/MapElementType": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/MapElementType",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/MapElementType\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*** Code **********************************************************/\n\n/**\n * @abstract\n */\nvar MapElementType = function () {\n  function MapElementType(id, root, fieldMeta, data) {\n    _classCallCheck(this, MapElementType);\n\n    this.id = id;\n    this.root = root;\n    this._fieldMeta = fieldMeta;\n    this.fullPath = this.root + '/' + this.id;\n    this.isShipped = $tw.wiki.getSubTiddler($tm.path.pluginRoot, this.fullPath);\n\n    // finally get the data\n    this._load(data || this.fullPath);\n  }\n\n  /**\n   * Load the type's data. Depending on the constructor arguments,\n   * the data source can be a tiddler, a type store\n   *\n   * @private\n   */\n\n\n  _createClass(MapElementType, [{\n    key: '_load',\n    value: function _load(data) {\n\n      if (!data) {\n\n        return;\n      }\n\n      if (typeof data === 'string') {\n        // assume id or full path\n\n        var isFullPath = _utils2.default.startsWith(data, this.root);\n        var tRef = isFullPath ? data : this.root + '/' + data;\n        this._loadFromTiddler(tRef);\n      } else if (data instanceof $tw.Tiddler) {\n\n        this._loadFromTiddler(data);\n      } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {\n        // = type or a data object\n\n        for (var field in this._fieldMeta) {\n          this[field] = data[field];\n        }\n      }\n    }\n\n    /**\n     * Retrieve all data from the tiddler provided. If a shadow tiddler\n     * with the same id exists, its data is merged during the load\n     * process.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_loadFromTiddler',\n    value: function _loadFromTiddler(tiddler) {\n\n      var tObj = _utils2.default.getTiddler(tiddler);\n\n      if (!tObj) {\n\n        return;\n      }\n\n      var shadowTObj = $tw.wiki.getSubTiddler($tm.path.pluginRoot, this.fullPath) || {};\n\n      // copy object to allow manipulation of the data\n      var rawData = $tw.utils.extend({}, shadowTObj.fields, tObj.fields);\n      // allow parsers to transform the raw field data\n      for (var field in this._fieldMeta) {\n\n        var parser = this._fieldMeta[field].parse;\n        var rawVal = rawData[field];\n\n        this[field] = parser ? parser.call(this, rawVal) : rawVal;\n      }\n    }\n\n    /**\n     * Method to determine whether or not this type exists. A type\n     * exists if a tiddler with the type's id can be found below\n     * the type's root path.\n     *\n     * @return {boolean} True if the type exists, false otherwise.\n     */\n\n  }, {\n    key: 'exists',\n    value: function exists() {\n\n      return _utils2.default.tiddlerExists(this.fullPath);\n    }\n  }, {\n    key: 'setStyle',\n    value: function setStyle(style, isMerge) {\n\n      // preprocessing: try to turn string into json\n      if (typeof style === 'string') {\n\n        style = _utils2.default.parseJSON(style);\n      }\n\n      // merge or override\n      if ((typeof style === 'undefined' ? 'undefined' : _typeof(style)) === 'object') {\n\n        if (isMerge) {\n\n          _utils2.default.merge(this.style, style);\n        } else {\n\n          this.style = style;\n        }\n      }\n    }\n\n    /**\n     * Store the type object as tiddler in the wiki. If the `tRef`\n     * property is not provided, the default type path prefix\n     * will be used with the type id appended. Stringifiers provided in\n     * the field meta object (that was passed to the constructor) are\n     * called.\n     *\n     * @param {string} [tRef] - If `tRef` is provided, the type\n     *     data will be written into this tiddler and the id property\n     *     is added as extra field value. Only do this is only for\n     *     dumping purposes!\n     * @param {boolean} [silently=false] do not update the modification date\n     */\n\n  }, {\n    key: 'save',\n    value: function save(tRef, silently) {\n\n      if (!tRef) {\n\n        tRef = this.fullPath;\n      } else if (typeof tRef !== 'string') {\n\n        return;\n      }\n\n      // also add an empty text field to guard against\n      // https://github.com/Jermolene/TiddlyWiki5/issues/2025\n      var fields = {\n        title: tRef,\n        text: ''\n      };\n\n      if (!_utils2.default.startsWith(tRef, this.root)) {\n\n        // = not the standard path for storing this type!\n        // in this case we add the id to the output.\n        fields.id = this.id;\n      }\n\n      // allow parsers to transform the raw field data\n      for (var field in this._fieldMeta) {\n\n        var stringify = this._fieldMeta[field].stringify;\n\n        fields[field] = stringify ? stringify.call(this, this[field]) : this[field];\n      }\n\n      if (!this.exists()) {\n        // newly created\n        Object.assign(fields, $tw.wiki.getCreationFields());\n      }\n\n      if (silently !== true) {\n        // add modification date to the output;\n        Object.assign(fields, $tw.wiki.getModificationFields());\n      }\n\n      $tw.wiki.addTiddler(new $tw.Tiddler(fields));\n    }\n  }]);\n\n  return MapElementType;\n}();\n\n/**\n * A list of fields that are used as data identifiers. Only these\n * listed keys are acknowledged by the load and save functions in\n * this class.\n *\n * This object resembles tw's field modules that are used by\n * `boot.js` to decide how fields are parsed and stringified again.\n */\n\n\nMapElementType.fieldMeta = {\n  'description': {},\n  'style': {\n    parse: _utils2.default.parseJSON,\n    stringify: JSON.stringify\n  },\n  'modified': {}, // translation handled by TW's core\n  'created': {} // translation handled by TW's core\n};\n\n/*** Exports *******************************************************/\n\nexports.default = MapElementType;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/graph/MapElementType.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/NodeType": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/NodeType",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _MapElementType2 = require('$:/plugins/felixhayashi/tiddlymap/js/MapElementType');\n\nvar _MapElementType3 = _interopRequireDefault(_MapElementType2);\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/NodeType\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\n/*** Code **********************************************************/\n\n/**\n * Used to define the type of a node.\n *\n * Note: NodeType instances are immutable (frozen).\n */\nvar NodeType = function (_MapElementType) {\n  _inherits(NodeType, _MapElementType);\n\n  function NodeType(id, data) {\n    _classCallCheck(this, NodeType);\n\n    id = typeof id === 'string' ? _utils2.default.getWithoutPrefix(id, $tm.path.nodeTypes + '/') : 'tmap:unknown';\n\n    // call the parent constructor\n\n    var _this = _possibleConstructorReturn(this, (NodeType.__proto__ || Object.getPrototypeOf(NodeType)).call(this, id, $tm.path.nodeTypes, NodeType.fieldMeta, data));\n\n    Object.freeze(_this);\n\n    return _this;\n  }\n\n  /**\n   * Get all tiddlers that inherit this type.\n   *\n   * @param {Array<TiddlerReference>} [src=$tw.wiki.allTitles()] - A list\n   *     of tiddlers that is searched for inheritors.\n   * @return {Array<TiddlerReference>} The inheritors.\n   */\n\n\n  _createClass(NodeType, [{\n    key: 'getInheritors',\n    value: function getInheritors(src) {\n\n      return this.scope ? _utils2.default.getMatches(this.scope, src || $tw.wiki.allTitles()) : [];\n    }\n  }]);\n\n  return NodeType;\n}(_MapElementType3.default);\n\n/**\n * @see https://github.com/babel/babel/issues/4854\n * @param {string} id - Either the edge type id (name)\n *     or a tiddler reference denoting the type or an\n *     `EdgeType` object (that is directly bounced back). If the\n *     id can be translated into a tiddler object that resides in\n *     the edge type path, then its data is retrieved automatically.\n */\n\n\nNodeType.getInstance = function (id) {\n  return id instanceof NodeType ? id : new NodeType(id);\n};\n\nNodeType.fieldMeta = _extends({}, _MapElementType3.default.fieldMeta, {\n  'view': {},\n  'priority': {\n    parse: function parse(raw) {\n      return isNaN(raw) ? 1 : parseInt(raw);\n    },\n    stringify: function stringify(num) {\n      return _utils2.default.isInteger(num) ? num.toString() : '1';\n    }\n  },\n  'scope': {\n    stringify: _utils2.default.getWithoutNewLines\n  },\n  'fa-icon': {},\n  'tw-icon': {}\n});\n\n/*** Exports *******************************************************/\n\nexports.default = NodeType;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/graph/NodeType.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nvar _EdgeType = require('$:/plugins/felixhayashi/tiddlymap/js/EdgeType');\n\nvar _EdgeType2 = _interopRequireDefault(_EdgeType);\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _environment = require('$:/plugins/felixhayashi/tiddlymap/js/lib/environment');\n\nvar env = _interopRequireWildcard(_environment);\n\nvar _exception = require('$:/plugins/felixhayashi/tiddlymap/js/exception');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*** Code **********************************************************/\n\n/**\n * This class abstracts the various pieces that together make up the\n * view such as map, edge filter, node filter, config etc.\n * If {@code isCreate} is not specified, the viewAbstraction will only\n * represent the view and not create it or any missing part of it.\n */\nvar ViewAbstraction = function () {\n\n  /**\n   *\n   * @param {string|ViewAbstraction|Tiddler} view - The view\n   * @param {Object} options\n   * @param {boolean} [options.isCreate] - True if the view should be created and override\n   *     any existing view, false otherwise.\n   */\n  function ViewAbstraction(view) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, ViewAbstraction);\n\n    if (view instanceof ViewAbstraction) {\n\n      // bounce back the object we received\n      return view;\n    }\n\n    this._registerPaths(view);\n\n    if (options.isCreate) {\n\n      if (!this.configTRef) {\n\n        var name = _utils2.default.getRandomLabel({ plural: true });\n        this.configTRef = $tw.wiki.generateNewTitle($tm.path.views + '/' + name);\n      }\n\n      this._createView(options);\n    } else if (!ViewAbstraction.exists(this.getRoot())) {\n      // no valid config path\n\n      throw new ResourceNotFoundException('ViewAbstraction', view);\n    }\n  }\n\n  /**\n   * Returns true if this view cannot be edited.\n   * As a general rule, all views that come as plugins are locked.\n   *\n   * @return {boolean}\n   */\n\n\n  _createClass(ViewAbstraction, [{\n    key: 'isLocked',\n    value: function isLocked() {\n\n      return $tw.wiki.isShadowTiddler(this.configTRef);\n    }\n\n    /**\n     * Gives the view a chance to rebuild its properties cache.\n     *\n     * @param {Updates} updates\n     * @return {boolean} True if changes affect parts of the view.\n     */\n\n  }, {\n    key: 'update',\n    value: function update(updates) {\n      var changedTiddlers = updates.changedTiddlers;\n\n\n      if (updates[env.path.edgeTypes] || _utils2.default.hasKeyWithPrefix(changedTiddlers, this.getRoot())) {\n        this._clearCaches();\n\n        return true;\n      }\n\n      return false;\n    }\n\n    /**\n     * clones the tiddler denoted via tRef and uses it as placeholder\n     * for this view when a widget using this view is displayed in\n     * static mode\n     *\n     * @param {Tiddler} tiddler\n     */\n\n  }, {\n    key: 'addPlaceholder',\n    value: function addPlaceholder(tiddler) {\n\n      _utils2.default.cp(_utils2.default.getTiddlerRef(tiddler), this.snapshotTRef, true);\n    }\n\n    /**\n     * A view exists if the the view's root exists as tiddler in the store.\n     *\n     * @deprecated\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'exists',\n    value: function exists() {\n\n      return ViewAbstraction.exists(this);\n    }\n\n    /**\n     * The path to the config tiddler that represents the view.\n     *\n     * @return {TiddlerReference}\n     */\n\n  }, {\n    key: 'getRoot',\n    value: function getRoot() {\n\n      return this.configTRef;\n    }\n\n    /**\n     * Returns this view's creation date.\n     *\n     * @param {boolean} [asString] True if the returned value should be a string in any case.\n     * @return {string|object|undefined} The creation date in the specified output format.\n     */\n\n  }, {\n    key: 'getCreationDate',\n    value: function getCreationDate(asString) {\n\n      var date = $tw.wiki.getTiddler(this.configTRef).fields['created'];\n\n      if (asString) {\n        // note: th will be translated as well!\n        return date instanceof Date ? $tw.utils.formatDateString(date, 'DDth MMM YYYY') : '';\n      }\n\n      return date;\n    }\n\n    /**\n     * The label of the view (which is basically the root-path's basename).\n     *\n     * @return {string} The label (name) of the view.\n     */\n\n  }, {\n    key: 'getLabel',\n    value: function getLabel() {\n\n      return _utils2.default.getBasename(this.configTRef);\n    }\n\n    /**\n     * Method to remove the view and its configuration.\n     * It will make the view non-existent.\n     *\n     * Note: Do not use the object anymore after you called this function!\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n\n      // delete the view and all tiddlers stored in its path (map, edge-filter etc.)\n      _utils2.default.deleteTiddlers(_utils2.default.getMatches('[prefix[' + this.configTRef + ']]'));\n    }\n\n    /**\n     * Returns all tiddlers include tiddlymap widgets that reference this view.\n     */\n\n  }, {\n    key: 'getOccurrences',\n    value: function getOccurrences() {\n\n      var filter = '[regexp:text[<\\\\$(tiddlymap|tmap).*?view=.' + this.getLabel() + '..*?>]]';\n      return _utils2.default.getMatches(filter);\n    }\n\n    /**\n     * Renames the view.\n     *\n     * @param {string} newLabel\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'rename',\n    value: function rename(newLabel) {\n\n      if (typeof newLabel !== 'string') {\n\n        return false;\n      }\n\n      if (_utils2.default.inArray('/', newLabel)) {\n\n        $tm.notify('A view name must not contain any \"/\"');\n\n        return false;\n      }\n\n      // keep a reference to the old label before we change it\n      var oldLabel = this.getLabel();\n\n      // start the renaming\n      var newRoot = env.path.views + '/' + newLabel;\n      var oldRoot = this.getRoot();\n\n      _utils2.default.mv(oldRoot, newRoot, true);\n\n      // update references\n\n      if ($tm.config.sys.defaultView === oldLabel) {\n        _utils2.default.setEntry($tm.ref.sysUserConf, 'defaultView', newLabel);\n      }\n\n      if ($tm.config.sys.liveTab.fallbackView === oldLabel) {\n        _utils2.default.setEntry($tm.ref.sysUserConf, 'liveTab.fallbackView', newLabel);\n      }\n\n      $tw.wiki.each(function (tObj, tRef) {\n\n        if (tObj.fields['tmap.open-view'] === oldLabel) {\n\n          // update global node data fields referencing this view\n          _utils2.default.setField(tRef, 'tmap.open-view', newLabel);\n\n          return;\n        }\n\n        if (ViewAbstraction.exists(tRef)) {\n\n          // update all local node data referencing this view\n          var view = new ViewAbstraction(tRef);\n          var nodes = view.getNodeData();\n\n          for (var id in nodes) {\n            if (nodes[id]['open-view'] === oldLabel) {\n              nodes[id]['open-view'] = newLabel;\n            }\n          }\n\n          view.saveNodeData(nodes);\n        }\n      });\n\n      // clear caches registered to previous root before registering new paths\n      this._clearCaches();\n      this._registerPaths(newLabel);\n    }\n\n    /**\n     * All configurations that are toggled via checkboxes to have a value\n     * either `true` or `false` can be accessed via this method.\n     *\n     * @param {string} name - The configs name without the `_config` prefix.\n     * @return {boolean} True if the configuration is enabled, false otherwise.\n     */\n\n  }, {\n    key: 'isEnabled',\n    value: function isEnabled(name) {\n\n      return _utils2.default.isTrue(this.getConfig(name), false);\n    }\n\n    /**\n     * Returns a configuration value relating to the given name. If no name\n     * is given, an object with all configurations is returned.\n     *\n     * @param {string} [name] - Instead of all configurations being returned,\n     *     only the configuration named name is returned. The initial \"config.\"\n     *     may be omitted.\n     * @result {string|Object} If `type` is not specified an object containing\n     *     all configurations is returned, otherwise a single value will be returned.\n     */\n\n  }, {\n    key: 'getConfig',\n    value: function getConfig(name) {\n      var _this = this;\n\n      var config = $tw.wiki.getCacheForTiddler(this.configTRef, \"tmap-config\", function () {\n\n        var fields = _utils2.default.getTiddler(_this.configTRef).fields;\n        return _utils2.default.getPropertiesByPrefix(fields, 'config.');\n      });\n\n      var prefixlessName = name && _utils2.default.startsWith(name, 'config.') ? name : 'config.' + name;\n\n      return name ? config[prefixlessName] : config;\n    }\n\n    /**\n     * Enables the api user to modify the view's configuration.\n     *\n     * In case two arguments are provided, the first is assumed to be the property\n     * name and the second the value to be set.\n     *\n     * In case a single object is provided as argument, it is treated as a key-value\n     * collection and each property in this object is saved as config.\n     *\n     * @param {*} args\n     */\n\n  }, {\n    key: 'setConfig',\n    value: function setConfig() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (args[0] == null) {\n        // null or undefined\n\n        return;\n      }\n\n      if (args.length === 1 && _typeof(args[0]) === 'object') {\n\n        for (var prop in args[0]) {\n          this.setConfig(prop, args[0][prop]);\n        }\n      } else if (args.length === 2 && typeof args[0] === 'string') {\n\n        var _prop = _utils2.default.getWithoutPrefix(args[0], 'config.');\n        var val = args[1];\n\n        if (val === undefined) {\n\n          return;\n        }\n\n        var config = this.getConfig();\n\n        if (val === null) {\n\n          $tm.logger('debug', 'Removing config', _prop);\n          delete config['config.' + _prop];\n        } else {\n\n          if (_prop === 'edge_type_namespace') {\n            var match = val.match(/[^:]+/);\n            val = match ? match[0] : '';\n          }\n        }\n\n        $tm.logger('log', 'Setting config', _prop, val);\n        config['config.' + _prop] = val;\n\n        // save\n        $tw.wiki.addTiddler(new $tw.Tiddler(_utils2.default.getTiddler(this.configTRef), config));\n      } else {\n        // not allowed\n\n        throw new (Function.prototype.bind.apply(_exception.InvalidArgumentException, [null].concat(args)))();\n      }\n    }\n\n    /**\n     * Whether this view represents the 'live view'\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'isLiveView',\n    value: function isLiveView() {\n\n      return this.getLabel() === $tm.misc.liveViewLabel;\n    }\n\n    /**\n     * Whether the node is already explicitly contained in the view's node filter,\n     * i.e. whether it is explicitly referenced by its title.\n     *\n     * @private\n     *\n     * @param {Node} node\n     * @return {string}\n     */\n\n  }, {\n    key: '_isNodeIncludedById',\n    value: function _isNodeIncludedById(node) {\n\n      var regex = $tw.utils.escapeRegExp(ViewAbstraction._getNodeIdFilterPart(node));\n\n      return this.getNodeFilter('raw').match(regex);\n    }\n\n    /**\n     * Sets and rebuilds the node filter according to the expression provided.\n     *\n     * @param {string} expr - A tiddlywiki filter expression.\n     * @param {boolean} force\n     */\n\n  }, {\n    key: 'setNodeFilter',\n    value: function setNodeFilter(expr, force) {\n\n      expr = expr.replace(/[\\n\\r]/g, ' ');\n\n      if (this.getNodeFilter('raw') === expr) {\n        // already up to date;\n        // This check is critical to prevent recursion!\n        return;\n      }\n\n      _utils2.default.setField(this.nodeFilterTRef, 'filter', expr);\n\n      $tm.logger('debug', 'Node filter set to', expr);\n    }\n\n    /**\n     * Sets and rebuilds the edge type filter according to the expression provided.\n     *\n     * @param {string} expr - A tiddlywiki filter expression.\n     */\n\n  }, {\n    key: 'setEdgeTypeFilter',\n    value: function setEdgeTypeFilter(expr) {\n\n      expr = expr.replace(/[\\n\\r]/g, ' ');\n\n      if (this.getEdgeTypeFilter('raw') === expr) {\n        // already up to date\n        // This check is critical to prevent recursion!\n        return;\n      }\n\n      _utils2.default.setField(this.edgeTypeFilterTRef, 'filter', expr);\n\n      $tm.logger('debug', 'Edge filter set to', expr);\n    }\n\n    /**\n     * Method to append a filter part to the current filter (*or*-style).\n     * The node's tmap.id will be used in the filter to reference the corresponding tiddler.\n     *\n     * @param {Node} node\n     */\n\n  }, {\n    key: 'addNode',\n    value: function addNode(node) {\n\n      if (!this._isNodeIncludedById(node)) {\n\n        // @see https://github.com/felixhayashi/TW5-TiddlyMap/issues/285\n        if (_utils2.default.isTrue($tm.config.sys.alwaysAddNodeIdToViewFilter) || !_utils2.default.isMatch(node.tRef, this.getNodeFilter('compiled'))) {\n\n          var part = ViewAbstraction._getNodeIdFilterPart(node);\n          var separator = ' ';\n          this.setNodeFilter(this.getNodeFilter('raw') + separator + part);\n        }\n\n        this.saveNodePosition(node);\n      }\n    }\n\n    /**\n     * Removes a node from the the view filter that has been\n     * explicitly added before.\n     *\n     * ATTENTION: Never remove the node data (i.e. style and positions)\n     * from the node-data store. This will be done by a garbage\n     * collector. See Adapter.prototype._removeObsoleteViewData\n     *\n     * @return {boolean} True if node was removed, false otherwise.\n     *     Note: false is also returned if the node did not exist before.\n     */\n\n  }, {\n    key: 'removeNode',\n    value: function removeNode(nodeId) {\n\n      if (!this._isNodeIncludedById(nodeId)) {\n\n        return false;\n      }\n\n      var part = ViewAbstraction._getNodeIdFilterPart(nodeId);\n      var f = this.getNodeFilter('raw').replace(part, '');\n\n      this.setNodeFilter(f);\n\n      if (this.getNodeData(nodeId)) {\n        this.saveNodeData(nodeId, null);\n      }\n\n      return true;\n    }\n\n    /**\n     * Method will return a tiddlywiki edge-type filter that is used to\n     * decide which edge types are displayed by the graph.\n     *\n     * Note: needs to be recalculated if the collection of edge types changed\n     * in the wiki.\n     *\n     * @param {(\"raw\"|\"pretty\"|\"matches\"|\"whitelist\")} [type]\n     *     Use this param to control the output type.\n     * @result {*}\n     *     Depends on the type param:\n     *     - raw: the original filter string\n     *     - pretty: the prettyfied filter string for usage in textareas\n     *     - matches: {Array<string>} all matches\n     *     - whitelist: A lookup table where all matches are true\n     */\n\n  }, {\n    key: 'getEdgeTypeFilter',\n    value: function getEdgeTypeFilter(type) {\n      var _this2 = this;\n\n      var filter = $tw.wiki.getCacheForTiddler(this.edgeTypeFilterTRef, \"tmap-edgeTypeFilter\", function () {\n\n        var allETy = $tm.indeces.allETy;\n        var src = Object.keys(allETy);\n        var tObj = $tw.wiki.getTiddler(_this2.edgeTypeFilterTRef);\n\n        var filter = {};\n        filter.raw = tObj && tObj.fields.filter || '';\n        filter.pretty = _utils2.default.getPrettyFilter(filter.raw);\n        filter.matches = _utils2.default.getEdgeTypeMatches(filter.raw, allETy);\n        filter.whitelist = _utils2.default.getLookupTable(filter.matches);\n\n        return filter;\n      });\n\n      return type ? filter[type] : filter;\n    }\n\n    /**\n     * Whether or not this EdgeType is visible in this view.\n     *\n     * @param {EdgeType|string} id\n     * @return {*}\n     */\n\n  }, {\n    key: 'isEdgeTypeVisible',\n    value: function isEdgeTypeVisible(id) {\n\n      return _utils2.default.isEdgeTypeMatch(_EdgeType2.default.getInstance(id).id, this.getEdgeTypeFilter(\"raw\"));\n    }\n\n    /**\n     * Method will return a tiddlywiki node filter that is used to\n     * decide which nodes are displayed by the graph.\n     *\n     * @param {(\"raw\"|\"pretty\"|\"compiled\")} [type] - Use this param to control the output type.\n     * @result {*}\n     *     Depends on the type param:\n     *     - raw: the original filter string\n     *     - pretty: the prettyfied filter string for usage in textareas\n     *     - compiled: {Array<string>} all matches\n     */\n\n  }, {\n    key: 'getNodeFilter',\n    value: function getNodeFilter(type) {\n      var _this3 = this;\n\n      var filter = $tw.wiki.getCacheForTiddler(this.nodeFilterTRef, \"tmap-nodeFilter\", function () {\n\n        var filter = _utils2.default.makeHashMap();\n        var tObj = $tw.wiki.getTiddler(_this3.nodeFilterTRef);\n\n        filter.raw = tObj && tObj.fields.filter || '';\n        filter.pretty = _utils2.default.getPrettyFilter(filter.raw);\n        filter.compiled = $tw.wiki.compileFilter(filter.raw);\n\n        return filter;\n      });\n\n      return type ? filter[type] : filter;\n    }\n\n    /**\n     * This method will return the node data stored in the view.\n     *\n     * @todo When to delete obsolete data?\n     *\n     * @param {string} nodeId\n     * @result {Hashmap<Id, Object>} A Hashmap with node data.\n     */\n\n  }, {\n    key: 'getNodeData',\n    value: function getNodeData(nodeId) {\n      var _this4 = this;\n\n      var data = $tw.wiki.getCacheForTiddler(this.mapTRef, \"tmap-map\", function () {\n        return _utils2.default.parseFieldData(_this4.mapTRef, 'text', {});\n      });\n\n      return nodeId ? data[nodeId] : data;\n    }\n\n    /**\n     * A view equals another view either\n     *\n     * 1) if the js objects reference the same objects in the js runtime\n     * 2) or if the views have the same root and both views exist\n     *\n     * @param view\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'equals',\n    value: function equals(view) {\n\n      return view === this || ViewAbstraction.exists(view) && new ViewAbstraction(view).getRoot() === this.getRoot();\n    }\n\n    /**\n     * This function will merge the given data in the view's node store.\n     *\n     * If a property is set to null, it will be removed.\n     *\n     * If two arguments are provided, the first parameter is assumed\n     * to be a node id and the second to be the data object. The data\n     * will extend the existing data. If data is not an object, it is\n     * assumed to be a delete directive and consequently the node data\n     * in the store will be deleted.\n     *\n     * Otherwise, if a single object parameter is provided, it is regarded\n     * as a node collection and the whole object is used to extend the store.\n     *\n     * Note: The Adapter will routinely delete node content of nodes that are\n     * not contained in the view anymore.\n     */\n\n  }, {\n    key: 'saveNodeData',\n    value: function saveNodeData() {\n\n      var data = this.getNodeData();\n\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      if (args.length === 2) {\n\n        if (_typeof(args[1]) === 'object') {\n\n          if (args[1] === null) {\n\n            delete data[args[0]];\n          } else {\n\n            data[args[0]] = Object.assign(data[args[0]] || {}, args[1]);\n          }\n        }\n      } else if (args.length === 1 && _typeof(args[0]) === 'object') {\n\n        $tm.logger('log', 'Storing data in', this.mapTRef);\n\n        Object.assign(data, args[0]);\n      } else {\n        // not allowed\n\n        throw new (Function.prototype.bind.apply(_exception.InvalidArgumentException, [null].concat(args)))();\n      }\n\n      _utils2.default.writeFieldData(this.mapTRef, 'text', data, $tm.config.sys.jsonIndentation);\n    }\n\n    /**\n     * Saves a node's position to the store\n     *\n     * @param {Node} node\n     */\n\n  }, {\n    key: 'saveNodePosition',\n    value: function saveNodePosition(node) {\n\n      if (node.id && node.x != null && node.y != null) {\n        // only pass coordinates to prevent other data from being stored!\n        this.saveNodeData(node.id, { x: node.x, y: node.y });\n      }\n    }\n\n    /**\n     * Saves a node's position to the store\n     *\n     * @param {Object} positions\n     */\n\n  }, {\n    key: 'saveNodePositions',\n    value: function saveNodePositions(positions) {\n\n      var nodeData = this.getNodeData();\n\n      for (var id in positions) {\n\n        nodeData[id] = nodeData[id] || {};\n        nodeData[id].x = positions[id].x;\n        nodeData[id].y = positions[id].y;\n      }\n\n      this.saveNodeData(nodeData);\n    }\n\n    /**\n     * Marks the node with the given id as central topic.\n     *\n     * @param nodeId\n     */\n\n  }, {\n    key: 'setCentralTopic',\n    value: function setCentralTopic(nodeId) {\n\n      this.setConfig('central-topic', nodeId);\n    }\n\n    /**\n     * Saves the provided style for the node with the specified id in the view's store.\n     *\n     * Note: The coordinates of the node on the map are not stored via this function.\n     * For this task, use saveNodePosition() instead.\n     *\n     * @param {string} nodeId\n     * @param {Object} style\n     */\n\n  }, {\n    key: 'saveNodeStyle',\n    value: function saveNodeStyle(nodeId, style) {\n\n      // remove any previos style from store;\n      // @TODO: optimize this only null in style var needs to be removed\n      var data = this.getNodeData(nodeId) || {};\n\n      var pos = { x: data.x, y: data.y };\n\n      // tabula rasa! delete all previous properties\n      for (var p in data) {\n        delete data[p];\n      }\n\n      // save new style\n      this.saveNodeData(nodeId, _extends({}, style, pos));\n    }\n\n    /**\n     * The view's configTiddlerRef is stored in different tiddlers (paths).\n     * This function registers these paths to this the view instance.\n     *\n     * @private\n     * @params {ViewAbstraction|string} view\n     */\n\n  }, {\n    key: '_registerPaths',\n    value: function _registerPaths(view, isCreate) {\n\n      // main config is stored here\n      this.configTRef = ViewAbstraction._getRootPath(view);\n\n      // store for node properties (positions and local node styles)\n      this.mapTRef = this.configTRef + '/map';\n\n      // filter stores\n      this.nodeFilterTRef = this.configTRef + '/filter/nodes';\n      this.edgeTypeFilterTRef = this.configTRef + '/filter/edges';\n\n      this.snapshotTRef = this.getRoot() + '/snapshot';\n    }\n\n    /**\n     * This will clear all cached tiddlers related to this view.\n     *\n     * @private\n     * @return {boolean} true if the cache was dirty, false if cache was up-to-date and did\n     */\n\n  }, {\n    key: '_clearCaches',\n    value: function _clearCaches() {\n      // clear all tiddler-caches below this path\n      _utils2.default.getMatches('[prefix[' + this.getRoot() + ']]').forEach(function (tRef) {\n        $tw.wiki.clearCache(tRef);\n      });\n    }\n\n    /**\n     * Will create the config tiddler which means that the view will\n     * start to exist.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_createView',\n    value: function _createView() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          isForce = _ref.isForce,\n          protoView = _ref.protoView,\n          isHidden = _ref.isHidden;\n\n      // destroy any former view that existed in this path\n      if (ViewAbstraction.exists(this)) {\n\n        if (!isForce) {\n\n          return;\n        }\n\n        this.destroy();\n      }\n\n      if (ViewAbstraction.exists(protoView)) {\n        _utils2.default.cp(new ViewAbstraction(protoView).getRoot(), this.configTRef, true);\n      }\n\n      // create new view\n      var fields = {\n        title: this.configTRef,\n        id: _utils2.default.genUUID() // maybe useful for future purposes…\n      };\n\n      if (!isHidden) {\n        fields[$tm.field.viewMarker] = true;\n      }\n\n      $tw.wiki.addTiddler(new $tw.Tiddler(_utils2.default.getTiddler(this.configTRef), // in case we cloned the view\n      fields));\n\n      this.setEdgeTypeFilter(env.filter.defaultEdgeTypeFilter);\n    }\n\n    /**\n     * Will return a filter part that matches the node's id.\n     *\n     * E.g. [field:tmap.id[1748576e-74bb-4165-85bb-0d312e3e4f1f]]\n     *\n     * @private\n     *\n     * @param node\n     * @return {string}\n     */\n\n  }], [{\n    key: '_getNodeIdFilterPart',\n    value: function _getNodeIdFilterPart(node) {\n\n      var id = (typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' ? node.id : node;\n\n      return '[field:tmap.id[' + id + ']]';\n    }\n\n    /**\n     * Will return the path to the config tiddler of this view, aka the view's root.\n     *\n     * @private\n     *\n     * @param {*} view - The constructor param to abstract or create the view.\n     * @result {string|undefined} The view config path.\n     */\n\n  }, {\n    key: '_getRootPath',\n    value: function _getRootPath(view) {\n\n      if (view instanceof ViewAbstraction) {\n\n        return view.configTRef;\n      }\n\n      if (view instanceof $tw.Tiddler) {\n        // is a tiddler object\n\n        view = view.fields.title;\n      }\n\n      if (typeof view === 'string') {\n\n        // remove prefix and slash\n        var label = _utils2.default.getWithoutPrefix(view, $tm.path.views + '/');\n\n        // a valid label must not contain any slashes\n        if (label && !_utils2.default.hasSubString(label, '/')) {\n\n          return $tm.path.views + '/' + label;\n        }\n      }\n    }\n\n    /**\n     * A view exists if the the view's root exists as tiddler in the store.\n     *\n     * @return {ViewAbstraction|string}\n     */\n\n  }, {\n    key: 'exists',\n    value: function exists(view) {\n\n      if (!view) {\n\n        return false;\n      }\n\n      if (view instanceof ViewAbstraction) {\n\n        view = view.configTRef;\n      } else {\n\n        view = ViewAbstraction._getRootPath(view);\n      }\n\n      return _utils2.default.tiddlerExists(view);\n    }\n  }]);\n\n  return ViewAbstraction;\n}();\n\n/*** Exports *******************************************************/\n\nexports.default = ViewAbstraction;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/graph/ViewAbstraction.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/Popup": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/Popup",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**** Code *********************************************************/\n\n/**\n * Installs a hidden popup below `parentDomNode` that may be shown\n * and or hidden.\n *\n * @constructor\n *\n * @param {Element} [parentDomNode] - The popup container. The\n *    popup will create itself in this container.\n * @param {Hashmap} [options] - An options object.\n * @param {string} [options.className] - A classname to be added to\n *    the popup div.\n * @param {int} [options.delay] - The default delay for the popup\n *    show and hide.\n */\nfunction Popup(parentDomNode, options) {\n\n  options = options || {};\n\n  this._parentDomNode = parentDomNode;\n  this._domNode = document.createElement('div');\n  this._domNode.style.display = 'none';\n  this._domNode.className = 'tmap-popup';\n\n  this._parentDomNode.appendChild(this._domNode);\n  $tw.utils.addClass(this._domNode, options.className);\n\n  this._isEnabled = true;\n  this._isPreventShowOrHide = false;\n  this._isHideOnClick = !!options.hideOnClick;\n  this._timeoutShow = null;\n  this._timeoutHide = null;\n  this._isDisplayNoneAfterAnimation = true;\n\n  // delays\n  var val = parseInt(options.leavingDelay);\n  this._hideDelayLeavingPopup = _utils2.default.isInteger(val) ? val : 200;\n\n  val = parseInt(options.hideDelay);\n  this._hideDelay = _utils2.default.isInteger(val) ? val : 200;\n\n  val = parseInt(options.showDelay);\n  this._showDelay = _utils2.default.isInteger(val) ? val : 200;\n\n  // force early binding of functions to this context\n  _utils2.default.bindTo(this, ['_show', '_hide', '_handleEnter', '_handleLeave', '_handleAnimationEnd', '_handleClick']);\n\n  // specify handlers\n  this._listeners = {\n    'mouseenter': this._handleEnter,\n    'mouseleave': this._handleLeave,\n    'click': [this._handleClick, true]\n  };\n\n  var fn = this._handleAnimationEnd;\n  this._listeners[$tw.utils.convertEventName('animationEnd')] = fn;\n  this._listeners[$tw.utils.convertEventName('transitionEnd')] = fn;\n\n  // add handlers\n  _utils2.default.setDomListeners('add', this._domNode, this._listeners, false);\n}\n\n/**\n * When the mouse is inside the popup, the popup will manage closing\n * itself and ignore all closing attempts from outside.\n */\n// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/Popup\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nPopup.prototype._handleEnter = function (ev) {\n\n  //~ console.log(\"_handleEnter\");\n\n  this._isPreventShowOrHide = true;\n};\n\n/**\n * Handler triggered when leaving the popup div.\n */\nPopup.prototype._handleLeave = function (ev) {\n\n  //~ console.log(\"_handleLeave\");\n\n  this._isPreventShowOrHide = false;\n\n  // we need some delay because resizing may cause the mouse to\n  // exit the popup for some miliseconds\n\n  this.hide(this._hideDelayLeavingPopup);\n};\n\nPopup.prototype._handleClick = function (ev) {\n\n  //~ console.log(\"_handleLeave\");\n\n  if (this._isHideOnClick) {\n    this._hide(true);\n  }\n};\n\n/**\n * Handler triggered when leaving the popup div.\n */\nPopup.prototype._handleAnimationEnd = function () {\n\n  if (this._isDisplayNoneAfterAnimation) {\n    //~ console.log(\"display: none\");\n    this._domNode.style.display = 'none';\n  }\n};\n\n/**\n * Immediately hides the popup.\n */\nPopup.prototype._hide = function (isForce) {\n\n  //~ console.log(\"_hide\");\n\n  if (!isForce && this._isPreventShowOrHide) return;\n\n  //~ console.log(\"_hide SUCCESS\");\n\n  this._isDisplayNoneAfterAnimation = true;\n  this._isPreventShowOrHide = false;\n\n  $tw.utils.removeClass(this._domNode, 'tmap-popup-active');\n};\n\n/**\n * Makes the text visible as popup and registers it with the\n * given signature.\n *\n * The popup is spawned on the side that has the most space.\n *\n * @param {*} signature - The signature that has been\n *     passed to {@link show}.\n */\nPopup.prototype._show = function (signature, text) {\n\n  //~ console.log(\"_show\");\n\n  if (this._isPreventShowOrHide || $tm.mouse.ctrlKey || !this._isEnabled) {\n    return;\n  }\n\n  this._domNode.style.display = 'none';\n  $tw.utils.removeClass(this._domNode, 'tmap-popup-active');\n\n  // remove any positioning or modification done before\n  this._domNode.removeAttribute('style');\n\n  // remove any previous content\n  _utils2.default.removeDOMChildNodes(this._domNode);\n  var div = this._domNode.appendChild(document.createElement('div'));\n\n  if (typeof text === 'function') {\n    text(signature, div);\n  } else {\n    div.innerHTML = text;\n  }\n\n  if (!div.childNodes.length) return;\n\n  var parRect = this._parentDomNode.getBoundingClientRect();\n  var x = $tm.mouse.clientX;\n  var y = $tm.mouse.clientY;\n\n  //~ console.log(\"_show SUCCESS\");\n\n  // ATTENTION: display needs to be true before we can get the bounds!\n\n  // make sure that display is block so the animation is executed\n  // and we can retrieve the size of the div.\n  this._domNode.style.display = 'block';\n\n  var popRect = this._domNode.getBoundingClientRect();\n\n  var availSpaceRight = parRect.right - (x + popRect.width);\n  var availSpaceLeft = x - popRect.width - parRect.left;\n  var spawnRight = availSpaceRight > availSpaceLeft;\n\n  var availSpaceBottom = parRect.bottom - (y + popRect.height);\n  var availSpaceTop = y - popRect.height - parRect.top;\n  var spawnBottom = availSpaceBottom > availSpaceTop;\n\n  var shiftLeft = spawnRight ? -15 : popRect.width + 15;\n  var shiftTop = spawnBottom ? -15 : popRect.height + 15;\n\n  this._domNode.style.left = x - parRect.left - shiftLeft + 'px';\n  this._domNode.style.top = y - parRect.top - shiftTop + 'px';\n\n  // …and make sure that it stays block after the animation is done…\n  this._isDisplayNoneAfterAnimation = false;\n  // …and add the class that triggers the animation…\n  $tw.utils.addClass(this._domNode, 'tmap-popup-active');\n};\n\n/**\n * Makes the text visible as popup after a given delay and\n * registers the popup under the specified signature.\n *\n * @param {*} signature - If {@param text} is provided as param and\n *     is a function, then this will be passed later as argument to\n *     text. It therefore acts as means to identify the popup later\n *     on or pass data that survives the delay.\n * @param {string|Function} text - If text\n *     is a string, it will be shown in the popup, otherwise,\n *     if text is a function, it will be executed and it is\n *     expected to populate the popup div passed as second parameter;\n *     the first parameter will be the signature object.\n * @param{delay} delay - Delays the hide operation.\n */\nPopup.prototype.show = function (signature, text, delay) {\n\n  //~ console.log(\"show\", delay);\n\n  this._clearTimeouts();\n\n  delay = _utils2.default.isInteger(delay) ? delay : this._showDelay;\n\n  // start a new timeout\n  this._timeoutShow = setTimeout(this._show, delay, signature, text);\n};\n\n/**\n * Hide the popup.\n *\n * @param {int} delay - Delays the hide operation.\n */\nPopup.prototype.hide = function (delay, isForce) {\n\n  //~ console.log(\"hide\", delay);\n\n  this._clearTimeouts();\n\n  delay = _utils2.default.isInteger(delay) ? delay : this._hideDelay;\n\n  if (isForce || delay === 0) {\n    // @TODO is this really correct?\n    this._hide(isForce);\n  } else {\n    this._timeoutHide = setTimeout(this._hide, delay, isForce);\n  }\n};\n\n/**\n * Completely enable or disable the popup\n */\nPopup.prototype.setEnabled = function (isEnabled) {\n  this._isEnabled = isEnabled;\n};\n\nPopup.prototype.isShown = function () {\n  return this._domNode.style.display === 'block';\n};\n\nPopup.prototype._clearTimeouts = function () {\n\n  clearTimeout(this._timeoutShow);\n  clearTimeout(this._timeoutHide);\n\n  this._timeoutShow = undefined;\n  this._timeoutHide = undefined;\n};\n\n/*** Exports *******************************************************/\n\nexports.default = Popup;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/lib/Popup.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/lib/SelectionRectangle": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/lib/SelectionRectangle",
            "text": "\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/SelectionRectangle\ntype: application/SelectionRectangle\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/**** Code *********************************************************/\n\n/**\n * Represents a rectangle spanned by mouse selection\n *\n * @constructor\n *\n * @param {Element} [parentDomNode] - The popup container. The\n *    popup will create itself in this container.\n * @param {Hashmap} [options] - An options object.\n * @param {string} [options.className] - A classname to be added to\n *    the popup div.\n * @param {int} [options.delay] - The default delay for the popup\n *    show and hide.\n */\nvar SelectionRectangle = function () {\n\n  /**\n   * Sets up the selection with the specified initial offset.\n   *\n   * @param {number} x - offset x\n   * @param {number} y - offset y\n   */\n  function SelectionRectangle(x, y) {\n    _classCallCheck(this, SelectionRectangle);\n\n    this.x1 = x;\n    this.x2 = x;\n\n    this.y1 = y;\n    this.y2 = y;\n  }\n\n  /**\n   * Spans the selection.\n   *\n   * @param {number} x - x coordinate\n   * @param {number} y - y coordinate\n   */\n\n\n  _createClass(SelectionRectangle, [{\n    key: \"span\",\n    value: function span(x, y) {\n\n      this.x2 = x;\n      this.y2 = y;\n    }\n\n    /**\n     * @return {number} width\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n\n      return this.x2 - this.x1;\n    }\n\n    /**\n     * @return {number} height\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n\n      return this.y2 - this.y1;\n    }\n\n    /**\n     * @return {array} an array holding the following data in sequence: x, y, width, height\n     */\n\n  }, {\n    key: \"getRect\",\n    value: function getRect() {\n\n      return [this.x1, this.y1, this.getWidth(), this.getHeight()];\n    }\n\n    /**\n     * @param {number} x - x coordinate\n     * @param {number} y - y coordinate\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isPointWithin\",\n    value: function isPointWithin(_ref) {\n      var x = _ref.x,\n          y = _ref.y;\n      var x1 = this.x1,\n          x2 = this.x2,\n          y1 = this.y1,\n          y2 = this.y2;\n\n\n      var mostLeft = Math.min(x1, x2);\n      var mostRight = Math.max(x1, x2);\n      var mostBottom = Math.min(y1, y2);\n      var mostTop = Math.max(y1, y2);\n\n      return mostLeft < x && x < mostRight && mostBottom < y && y < mostTop;\n    }\n  }]);\n\n  return SelectionRectangle;\n}();\n\n/*** Exports *******************************************************/\n\nexports.default = SelectionRectangle;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/lib/SelectionRectangle.js.map\n",
            "type": "application/SelectionRectangle",
            "module-type": "library"
        },
        "/home/felo/projects/Tiddlywiki/TiddlyWiki5/plugins/felixhayashi/tiddlymap/js/lib/TypeDefs.js": {
            "title": "/home/felo/projects/Tiddlywiki/TiddlyWiki5/plugins/felixhayashi/tiddlymap/js/lib/TypeDefs.js",
            "text": "/**\n * @typedef {string} TiddlerReference\n *\n * A reference (title) that identifies a tiddler.\n */\n\n/**\n * @typedef {$tw.Tiddler|TiddlerReference} Tiddler\n *\n * Either a reference (title) that identifies the tiddler or an object\n * representation.\n */\n\n/**\n * @typedef {string|number} Id\n *\n * An id used to identify a node or tiddler. Ids may only contain characters\n * that are valid when used as tiddlywiki field values.\n */\n\n/**\n * @typedef {Object} Edge\n *\n * @property {Id} id - The id of the edge.\n * @property {Id} from - An id that refers to a {@link Node} and denotes the\n *     from part of an edge.\n * @property {Id} to - An id that refers to a {@link Node} and denotes the\n *     to part of an edge.\n * @property {string} label - The label of the edge that will be displayed\n *     in the rendered graph.\n * @property {string} [view] - An optional viewname to which the edge is\n *     bound to.\n *\n * An edge connects nodes in a vis.Network.\n */\n\n/**\n * @typedef {Object} EdgeTypeSubscriberInfo\n *\n * @property {(\"_\"|undefined)} [marker] - The marker of the edge type.\n * @property {string} [namespace] - The namespace of the edge type.\n * @property {string} [name] - The name of the edge type.\n * @property {boolean} [include=true] - Whether or not this subscriber should be registered.\n */\n\n/**\n * @typedef {Object} Node\n *\n * This object is used by the vis.Network.\n *\n * @property {Id} id - The id of the node.\n * @property {string} label - The label of the node that will be displayed\n *     in the rendered graph.\n */\n\n/**\n * @typedef {Object} Hashmap\n *\n * Sometimes it makes semantically more sense to call an object a hashmap.\n * Then it becomes clear that we are talking about a simple key-value store.\n */\n\n/**\n * @typedef {Array.<*>|Hashmap.<Id, *>|vis.DataSet} Collection\n *\n * A collection contains a group of elements, usually nodes\n * (see {@link NodeCollection}) or edges (see {@link EdgeCollection}).\n *\n * A collection object corresponds to a {@link CollectionTypeString}.\n */\n\n/**\n * @typedef {Array.<Edge>|Hashmap.<Id, Edge>|vis.DataSet} EdgeCollection\n *\n * A collection of edges.\n */\n\n/**\n * @typedef {Array.<Node>|Hashmap.<Id, Node>|vis.DataSet} NodeCollection\n *\n * A collection of nodes.\n */\n\n/**\n * @typedef {Array.<Tiddler>|Hashmap.<Id, Tiddler>} TiddlerCollection\n *\n * A collection of tiddlers.\n */\n\n/**\n * @typedef {string|function} TiddlyWikiFilter\n *\n * A tiddlywiki filter expression or a compiled filter.\n */\n\n/**\n * @typedef {Tiddler|string|ViewAbstraction} View\n *\n * A view is identified either by a tiddler reference (title),\n * a Tiddler instance or a label. Moreover, a ViewAbstraction\n * may be used as view representation.\n */\n\n/**\n * @typedef {array|hashmap|dataset} CollectionTypeString\n *\n * Most of tiddlymap's select statements allow the user to choose one\n * of the specified output types, depending on what is most suitable.\n *\n * The output types relate to the different types of\n * {@link EdgeCollection} and {@link NodeCollection}.\n */\n\n/**\n * @typedef {Object} Position\n *\n * An object containing x, y properties.\n *\n * @property {number} x - The x coordinate.\n * @property {number} y - The y coordinate.\n */\n\n/**\n * @typedef {Object} Updates\n *\n * An object that carries information about wiki changes after a refresh cycle occurred.\n * This is a more advanced form of the changedTiddlers object.\n *\n * @property {Object<TiddlerReference, string>} changedTiddlers\n *    a TiddlyWiki changedTiddlers list that has all draft tiddler changes removed\n * @property {Object<string, boolean>} paths\n *    a list of root paths in which tiddler changes occured.\n */\n\n/**\n * @typedef {string} EdgeTypeId\n *\n * An edge-type id string consists of the following parts of which the\n * first two are optional: `[marker][namespace:]name`\n *\n * Note: The colon is not considered to be part of the namespace but is required\n * if a namespace exists.\n */\n\"use strict\";\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/lib/TypeDefs.js.map\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/config/vis": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/config/vis",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/config/vis\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\nvar visConfig = {\n\n  locale: 'en_EN',\n  clickToUse: false,\n  autoResize: false,\n  height: '100%',\n  width: '100%',\n  configure: {\n    enabled: false\n  },\n  interaction: {\n    dragNodes: true,\n    dragView: true,\n    hideEdgesOnDrag: false,\n    hideNodesOnDrag: false,\n    hover: true,\n    navigationButtons: true,\n    multiselect: true,\n    selectable: true,\n    selectConnectedEdges: true,\n    tooltipDelay: 600,\n    zoomView: false,\n    keyboard: {\n      enabled: false,\n      speed: {\n        x: 10,\n        y: 10,\n        zoom: 0.02\n      },\n      bindToWindow: false\n    }\n  },\n  manipulation: {\n    initiallyActive: true\n  },\n  nodes: {\n    shape: 'box',\n    shadow: {\n      enabled: false\n    },\n    color: {\n      border: '#2B7CE9',\n      background: '#97C2FC'\n    }\n  },\n  edges: {\n    smooth: {\n      enabled: true\n    },\n    color: {\n      color: '#848484',\n      inherit: false\n    },\n    arrows: {\n      to: {\n        enabled: true\n      }\n    }\n  },\n  physics: {\n    forceAtlas2Based: {\n      // <- more repulsion between nodes - 0 - more attraction between nodes ->\n      gravitationalConstant: -300, // default: -50\n      // edge length\n      springLength: 0, // default: 100\n      // <- less stiff edges - 0 - stiffer edges ->\n      springConstant: 0.2, // default: 0.08\n      // pulls the entire network back to the center.\n      centralGravity: 0.015, // default: 0.01\n      // kinetic energy reduction\n      damping: 0.4\n    },\n    solver: 'forceAtlas2Based',\n    stabilization: {\n      enabled: true,\n      iterations: 1000,\n      updateInterval: 10,\n      onlyDynamicEdges: false,\n      fit: false\n    }\n  }\n};\n\nexports.default = visConfig;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/lib/VisConfig.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/lib/environment": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/lib/environment",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\n// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/environment\ntype: application/javascript\n module-type: library\n\n@preserve\n\n\\*/\n\n/*** Code **********************************************************/\n\n/**\n * This module is responsible for registering a global namespace\n * under $tw and registering fundamental path variables.\n *\n * Everything that doesn't change when the global config object is\n * updated. This includes prefixes (paths) and tiddler titles.\n *\n * ATTENTION: The paths are deliberately written in full so they\n * are discovered when a search is performed over the TiddlyMap code.\n */\n\n// **ATTENTION: NO TRAILING SLASHES IN PATHS EVER**\nvar path = exports.path = {\n  pluginRoot: '$:/plugins/felixhayashi/tiddlymap',\n  edgeTypes: '$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes',\n  nodeTypes: '$:/plugins/felixhayashi/tiddlymap/graph/nodeTypes',\n  views: '$:/plugins/felixhayashi/tiddlymap/graph/views',\n  options: '$:/plugins/felixhayashi/tiddlymap/config',\n  dialogs: '$:/plugins/felixhayashi/tiddlymap/dialog',\n  footers: '$:/plugins/felixhayashi/tiddlymap/dialogFooter',\n  tempRoot: '$:/temp/tmap',\n  tempStates: '$:/temp/tmap/state',\n  tempPopups: '$:/temp/tmap/state/popup',\n  localHolders: '$:/temp/tmap/holders'\n};\n\n// static references to important tiddlers\nvar ref = exports.ref = {\n  defaultViewHolder: '$:/plugins/felixhayashi/tiddlymap/misc/defaultViewHolder',\n  graphBar: '$:/plugins/felixhayashi/tiddlymap/misc/advancedEditorBar',\n  sysUserConf: '$:/plugins/felixhayashi/tiddlymap/config/sys/user',\n  visUserConf: '$:/plugins/felixhayashi/tiddlymap/config/vis/user',\n  welcomeFlag: '$:/plugins/felixhayashi/tiddlymap/flag/welcome',\n  focusButton: '$:/plugins/felixhayashi/tiddlymap/misc/focusButton',\n  sysMeta: '$:/plugins/felixhayashi/tiddlymap/misc/meta',\n  liveTab: '$:/plugins/felixhayashi/tiddlymap/hook/liveTab',\n  mainEditor: '$:/plugins/felixhayashi/tiddlymap/hook/editor',\n  sidebarBreakpoint: '$:/themes/tiddlywiki/vanilla/metrics/sidebarbreakpoint'\n};\n\n// some other options\nvar misc = exports.misc = {\n  // if no edge label is specified, this is used as label\n  unknownEdgeLabel: 'tmap:undefined',\n  liveViewLabel: 'Live View',\n  defaultViewLabel: 'Default',\n  mainEditorId: 'main_editor',\n  arrows: { 'in': '⇦', 'out': '➡', 'bi': '⇄' }\n};\n\nvar config = exports.config = {\n  sys: {\n    field: {\n      nodeLabel: 'caption',\n      nodeIcon: 'icon',\n      nodeInfo: 'description',\n      viewMarker: 'isview'\n    },\n    liveTab: {\n      fallbackView: misc.liveViewLabel\n    },\n    suppressedDialogs: {},\n    edgeClickBehaviour: 'manager',\n    debug: 'false',\n    notifications: 'true',\n    popups: {\n      enabled: 'true',\n      delay: '600',\n      width: '240px',\n      height: '140px'\n    },\n    jsonIndentation: '1',\n    alwaysAddNodeIdToViewFilter: 'true',\n    editNodeOnCreate: 'false',\n    singleClickMode: 'false',\n    nodeFilterNeighbours: 'false',\n    editorMenuBar: {\n      showNeighScopeButton: 'true',\n      showRasterMenuButton: 'true',\n      showScreenshotButton: 'true'\n    }\n  }\n};\n\n// some popular filters\nvar filter = exports.filter = {\n  nodeTypes: '[prefix[' + path.nodeTypes + ']]',\n  edgeTypes: '[prefix[' + path.edgeTypes + ']]',\n  views: '[' + config.sys.field.viewMarker + '[true]]',\n  defaultEdgeTypeFilter: '-[prefix[_]] -[[tw-body:link]] -[[tw-list:tags]] -[[tw-list:list]]'\n};\n\nvar allSelector = '[all[tiddlers+shadows]!has[draft.of]]';\n\n// some popular selectors\n// usually used from within tiddlers via the tmap macro\n\nvar s = {\n  allEdgeTypes: allSelector + ' +' + filter.edgeTypes,\n  allNodeTypes: allSelector + ' +' + filter.nodeTypes,\n  allViews: allSelector + ' +' + filter.views,\n  allPotentialNodes: '[all[tiddlers]!is[system]!has[draft.of]]'\n};\n\nvar selector = exports.selector = _extends({}, s, {\n  allEdgeTypesById: s.allEdgeTypes + ' +[removeprefix[' + path.edgeTypes + '/]]',\n  allNodeTypesById: s.allNodeTypes + ' +[removeprefix[' + path.nodeTypes + '/]]',\n  allViewsByLabel: s.allViews + ' +[removeprefix[' + path.views + '/]]'\n});\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/lib/environment.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/exception": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/exception",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/exception\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/**\n * Base class for all Exceptions in TiddlyMap\n */\nvar TiddlyMapError = function (_Error) {\n  _inherits(TiddlyMapError, _Error);\n\n  /**\n   *\n   * @param {string} message\n   * @param {array} payload\n   */\n  function TiddlyMapError(message, payload) {\n    _classCallCheck(this, TiddlyMapError);\n\n    var _this = _possibleConstructorReturn(this, (TiddlyMapError.__proto__ || Object.getPrototypeOf(TiddlyMapError)).call(this, message));\n\n    _this.payload = payload;\n    return _this;\n  }\n\n  _createClass(TiddlyMapError, [{\n    key: 'getPayload',\n    value: function getPayload() {\n      return this.payload;\n    }\n  }]);\n\n  return TiddlyMapError;\n}(Error);\n\n/**\n * Thrown if a css or dom structure is not present but was expected by TiddlyMap.\n */\n\n\nvar EnvironmentError = exports.EnvironmentError = function (_TiddlyMapError) {\n  _inherits(EnvironmentError, _TiddlyMapError);\n\n  function EnvironmentError(aspect) {\n    _classCallCheck(this, EnvironmentError);\n\n    return _possibleConstructorReturn(this, (EnvironmentError.__proto__ || Object.getPrototypeOf(EnvironmentError)).call(this, 'Critical parts of the underlying system changed: ' + aspect));\n  }\n\n  return EnvironmentError;\n}(TiddlyMapError);\n\n/**\n * Thrown if a plugin or any other kind of required dependency is missing.\n */\n\n\nvar DependencyError = exports.DependencyError = function (_TiddlyMapError2) {\n  _inherits(DependencyError, _TiddlyMapError2);\n\n  function DependencyError(dep) {\n    _classCallCheck(this, DependencyError);\n\n    return _possibleConstructorReturn(this, (DependencyError.__proto__ || Object.getPrototypeOf(DependencyError)).call(this, 'TiddlyMap cannot run without: : ' + dep));\n  }\n\n  return DependencyError;\n}(TiddlyMapError);\n\n/**\n * Thrown if an interface method is not fully implemented.\n */\n\n\nvar MissingOverrideError = exports.MissingOverrideError = function (_TiddlyMapError3) {\n  _inherits(MissingOverrideError, _TiddlyMapError3);\n\n  function MissingOverrideError(context, methodName) {\n    _classCallCheck(this, MissingOverrideError);\n\n    return _possibleConstructorReturn(this, (MissingOverrideError.__proto__ || Object.getPrototypeOf(MissingOverrideError)).call(this, context.constructor.name + ' does not override method \"' + methodName + '\"'));\n  }\n\n  return MissingOverrideError;\n}(TiddlyMapError);\n\n/**\n * Thrown if a resource such as a node, edge, view, tiddler etc. cannot be located\n * in the system.\n */\n\n\nvar ResourceNotFoundException = exports.ResourceNotFoundException = function (_TiddlyMapError4) {\n  _inherits(ResourceNotFoundException, _TiddlyMapError4);\n\n  /**\n   * @param {string} resourceType\n   * @param {*} payload\n   */\n  function ResourceNotFoundException(resourceType) {\n    _classCallCheck(this, ResourceNotFoundException);\n\n    for (var _len = arguments.length, payload = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      payload[_key - 1] = arguments[_key];\n    }\n\n    return _possibleConstructorReturn(this, (ResourceNotFoundException.__proto__ || Object.getPrototypeOf(ResourceNotFoundException)).call(this, 'Cannot resolve ' + resourceType, payload));\n  }\n\n  return ResourceNotFoundException;\n}(TiddlyMapError);\n\n/**\n * Thrown if a resource such as a node, edge, view, tiddler etc. cannot be located\n * in the system.\n */\n\n\nvar InvalidArgumentException = exports.InvalidArgumentException = function (_TiddlyMapError5) {\n  _inherits(InvalidArgumentException, _TiddlyMapError5);\n\n  function InvalidArgumentException() {\n    _classCallCheck(this, InvalidArgumentException);\n\n    for (var _len2 = arguments.length, payload = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      payload[_key2] = arguments[_key2];\n    }\n\n    return _possibleConstructorReturn(this, (InvalidArgumentException.__proto__ || Object.getPrototypeOf(InvalidArgumentException)).call(this, 'Invalid or missing argument provided', payload));\n  }\n\n  return InvalidArgumentException;\n}(TiddlyMapError);\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/lib/exceptions.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/URL": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/URL",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/URL\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Code **********************************************************/\n\n/**\n * <<<\n * Lightweight URL manipulation with JavaScript. This library is\n * independent of any other libraries and has pretty simple interface\n * and lightweight code-base. Some ideas of query string parsing\n * had been taken from Jan Wolter.\"\n *\n * @see http://unixpapa.com/js/querystring.html\n * @license MIT\n * @author Mykhailo Stadnyk <mikhus@gmail.com>\n * <<< https://github.com/Mikhus/jsurl\n *\n * @class\n * @param {string} url\n */\nfunction Url(url) {\n  this.paths = function (paths) {\n    var prefix = '',\n        i = 0,\n        s;\n\n    if (paths && paths.length && paths + '' !== paths) {\n      if (this.isAbsolute()) {\n        prefix = '/';\n      }\n\n      for (s = paths.length; i < s; i++) {\n        paths[i] = encode(paths[i]);\n      }\n\n      this.path = prefix + paths.join('/');\n    }\n\n    paths = (this.path.charAt(0) === '/' ? this.path.slice(1) : this.path).split('/');\n\n    for (i = 0, s = paths.length; i < s; i++) {\n      paths[i] = decode(paths[i]);\n    }\n\n    return paths;\n  };\n\n  this.encode = encode;\n  this.decode = decode;\n\n  this.isAbsolute = function () {\n    return this.protocol || this.path.charAt(0) === '/';\n  };\n\n  this.toString = function () {\n    return (this.protocol && this.protocol + '://') + (this.user && encode(this.user) + (this.pass && ':' + encode(this.pass)) + '@') + (this.host && this.host) + (this.port && ':' + this.port) + (this.path && this.path) + (this.query.toString() && '?' + this.query) + (this.hash && '#' + encode(this.hash));\n  };\n\n  parse(this, url);\n}\n\nvar\n// mapping between what we want and <a> element properties\nmap = {\n  protocol: 'protocol',\n  host: 'hostname',\n  port: 'port',\n  path: 'pathname',\n  query: 'search',\n  hash: 'hash'\n},\n    defaultPorts = {\n  'ftp': 21,\n  'gopher': 70,\n  'http': 80,\n  'https': 443,\n  'ws': 80,\n  'wss': 443\n},\n    parse = function parse(self, url) {\n  var d = document,\n      link = d.createElement('a'),\n      url = url || d.location.href,\n      auth = url.match(/\\/\\/(.*?)(?::(.*?))?@/) || [],\n      i;\n\n  link.href = url;\n\n  for (i in map) {\n    self[i] = link[map[i]] || '';\n  }\n\n  // fix-up some parts\n  self.protocol = self.protocol.replace(/:$/, '');\n  self.query = self.query.replace(/^\\?/, '');\n  self.hash = decode(self.hash.replace(/^#/, ''));\n  self.user = decode(auth[1] || '');\n  self.pass = decode(auth[2] || '');\n  self.port = defaultPorts[self.protocol] == self.port || self.port == 0 ? '' : self.port; // IE fix, Android browser fix\n\n  if (!self.protocol && !/^([a-z]+:)?\\/\\//.test(url)) {\n    // is IE and path is relative\n    var base = new Url(d.location.href.match(/(.*\\/)/)[0]),\n        basePath = base.path.split('/'),\n        selfPath = self.path.split('/'),\n        props = ['protocol', 'user', 'pass', 'host', 'port'],\n        s = props.length;\n\n    basePath.pop();\n\n    for (i = 0; i < s; i++) {\n      self[props[i]] = base[props[i]];\n    }\n\n    while (selfPath[0] == '..') {\n      // skip all \"../\n      basePath.pop();\n      selfPath.shift();\n    }\n\n    self.path = (url.charAt(0) != '/' ? basePath.join('/') : '') + '/' + selfPath.join('/');\n  } else {\n    // fix absolute URL's path in IE\n    self.path = self.path.replace(/^\\/?/, '/');\n  }\n\n  self.paths((self.path.charAt(0) == '/' ? self.path.slice(1) : self.path).split('/'));\n\n  parseQs(self);\n},\n    encode = function encode(s) {\n  return encodeURIComponent(s).replace(/'/g, '%27');\n},\n    decode = function decode(s) {\n  s = s.replace(/\\+/g, ' ');\n\n  s = s.replace(/%([ef][0-9a-f])%([89ab][0-9a-f])%([89ab][0-9a-f])/gi, function (code, hex1, hex2, hex3) {\n    var n1 = parseInt(hex1, 16) - 0xE0,\n        n2 = parseInt(hex2, 16) - 0x80;\n\n    if (n1 == 0 && n2 < 32) {\n      return code;\n    }\n\n    var n3 = parseInt(hex3, 16) - 0x80,\n        n = (n1 << 12) + (n2 << 6) + n3;\n\n    if (n > 0xFFFF) {\n      return code;\n    }\n\n    return String.fromCharCode(n);\n  });\n\n  s = s.replace(/%([cd][0-9a-f])%([89ab][0-9a-f])/gi, function (code, hex1, hex2) {\n    var n1 = parseInt(hex1, 16) - 0xC0;\n\n    if (n1 < 2) {\n      return code;\n    }\n\n    var n2 = parseInt(hex2, 16) - 0x80;\n\n    return String.fromCharCode((n1 << 6) + n2);\n  });\n\n  s = s.replace(/%([0-7][0-9a-f])/gi, function (code, hex) {\n    return String.fromCharCode(parseInt(hex, 16));\n  });\n\n  return s;\n},\n    parseQs = function parseQs(self) {\n  var qs = self.query;\n\n  self.query = new function (qs) {\n    var re = /([^=&]+)(=([^&]*))?/g,\n        match;\n\n    while (match = re.exec(qs)) {\n      var key = decodeURIComponent(match[1].replace(/\\+/g, ' ')),\n          value = match[3] ? decode(match[3]) : '';\n\n      if (this[key] != null) {\n        if (!(this[key] instanceof Array)) {\n          this[key] = [this[key]];\n        }\n\n        this[key].push(value);\n      } else {\n        this[key] = value;\n      }\n    }\n\n    this.clear = function () {\n      for (var key in this) {\n\n        if (!(this[key] instanceof Function)) {\n\n          delete this[key];\n        }\n      }\n    };\n\n    this.count = function () {\n      var count = 0,\n          key;\n      for (key in this) {\n\n        if (!(this[key] instanceof Function)) {\n          count++;\n        }\n      }\n      return count;\n    };\n\n    this.isEmpty = function () {\n      return this.count() === 0;\n    };\n\n    this.toString = function () {\n      var s = '',\n          e = encode,\n          i,\n          ii;\n\n      for (i in this) {\n\n        if (this[i] instanceof Function) {\n          continue;\n        }\n\n        if (this[i] instanceof Array) {\n\n          var len = this[i].length;\n\n          if (len) {\n            for (ii = 0; ii < len; ii++) {\n              s += s ? '&' : '';\n\n              s += e(i) + '=' + e(this[i][ii]);\n            }\n          } else {\n            // parameter is an empty array, so treat as\n            // an empty argument\n\n            s += (s ? '&' : '') + e(i) + '=';\n          }\n        } else {\n          s += s ? '&' : '';\n\n          s += e(i) + '=' + e(this[i]);\n        }\n      }\n\n      return s;\n    };\n  }(qs);\n};\n\n/*** Exports *******************************************************/\n\nexports.default = Url;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/lib/url.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bindTo = exports.getNearestRasterPosition = exports.mod = exports.removeDOMChildNodes = exports.setDomListeners = exports.merge = exports.getRandomLabel = exports.getFirstElementByClassName = exports.getImgFromWeb = exports.pickRandom = exports.hasKeyWithPrefix = exports.getWithoutPrefix = exports.getPropertiesByPrefix = exports.removeArrayElement = exports.isTrue = exports.replaceAll = exports.isInteger = exports.findAndRemoveClassNames = exports.getAncestorWithClass = exports.makeHashMap = exports.getWithoutNewLines = exports.joinAndWrap = exports.parseJSON = exports.hasSubString = exports.inArray = exports.getRandomInt = exports.isEqual = exports.identity = exports.base64 = exports.startsWith = exports.getBasename = exports.escapeRegex = exports.hasElements = exports.ucFirst = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\nvar _exception = require('$:/plugins/felixhayashi/tiddlymap/js/exception');\n\n/**\n * Uppercase the first letter of a string.\n */\nvar ucFirst = exports.ucFirst = function ucFirst(string) {\n  return string && string[0].toUpperCase() + string.slice(1);\n};\n\n/**\n * Function to find out whether an object has any enumerable properties\n * or, in case of an array, elements.\n *\n * @param {Object} obj\n * @return {boolean} True if at least one enumerable property exists,\n *     false otherwise.\n */\nvar hasElements = exports.hasElements = function hasElements(obj) {\n  return Object.keys(obj).length > 0;\n};\n\n/**\n * When we do not know the string, we need to escape it.\n * @deprecated use tw's escapeRegExp instead\n */\nvar escapeRegex = exports.escapeRegex = function escapeRegex(str) {\n  return str.replace(/[-$^?.+*[\\]\\\\(){}|]/g, '\\\\$&');\n};\n\n/**\n * Returns the basename of a path.\n * A path is a string with slashes (or another separator).\n *\n * @param {string} path - The path\n * @param {string} [separator='/']\n * @return {string} The basename\n */\nvar getBasename = exports.getBasename = function getBasename(path) {\n  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';\n  return path.substring(path.lastIndexOf(separator) + 1);\n};\n\n/**\n * Helper to increase the code semantics.\n *\n * @param {string} str - The string to work with.\n * @param {string} prefix - The sequence to test.\n * @result {boolean} True if `str` starts with `prefix`, false otherwise.\n */\nvar startsWith = exports.startsWith = function startsWith(str, prefix) {\n  return str.substring(0, prefix.length) === prefix;\n};\n\n/**\n * Converts a string to base64 encoding.\n *\n * To do so, we either choose the native btoa browser function or the Buffer class\n * received via scope.\n *\n * @param {string} str\n */\nvar base64 = exports.base64 = typeof window === 'undefined' ? function (str) {\n  return new Buffer(str).toString('base64');\n} : window.btoa.bind(window);\n\n/**\n * If two objects have the same properties, with the same values\n * then identity identity(obj) === identity(obj2) will return true.\n *\n * @param obj\n * @return string\n */\nvar identity = exports.identity = function identity(obj) {\n  return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null ? JSON.stringify(Object.keys(obj).sort().map(function (key) {\n    return [key, obj[key]];\n  })) : null;\n};\n\n/**\n * Returns true if both objects have the same properties\n * @param obj1\n * @param obj2\n */\nvar isEqual = exports.isEqual = function isEqual(obj1, obj2) {\n  return identity(obj1) === identity(obj2);\n};\n\n/**\n *\n * @param min\n * @param max\n */\nvar getRandomInt = exports.getRandomInt = function getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min) + min);\n};\n\n/**\n * Checks if a value exists in an array. A strict search is used\n * which means that also the type of the needle in the haystack\n * is checked.\n *\n * @param {*} needle - The searched value.\n * @param {Array} haystack - The array.\n * @return Returns true if needle is found in the array, false otherwise.\n */\nvar inArray = exports.inArray = function inArray(needle, haystack) {\n  return haystack.indexOf(needle) !== -1;\n};\n\n/**\n * Checks if a string exists in a string.\n */\nvar hasSubString = exports.hasSubString = function hasSubString(str, sub) {\n  return str.indexOf(sub) !== -1;\n};\n\n/**\n * Try to turn the string into a javascript object. If the\n * transformation fails, return the optionally provided `data` object.\n *\n * @param {string} str - The string to parse.\n * @param {*} data - The default value if the operation fails.\n * @return {*} Either the object resulting from the parsing operation\n *     or `undefined` or `data` if the operation failed.\n */\nvar parseJSON = exports.parseJSON = function parseJSON(str, data) {\n\n  try {\n\n    return JSON.parse(str);\n  } catch (Error) {\n\n    return data;\n  }\n};\n\n/**\n * Joins all elements of an array into a string where all elements\n * are wrapped between `left` and `right`.\n *\n * @param {Array} arr - The array to perform the join on.\n * @param {string} left - The wrapping string for the left side.\n * @param {string} right - The wrapping string for the right side.\n * @param {string} [separator] - The separator between a wrapped element\n *     and the next one. Defaults to space.\n * @return {string} The wrapped string, e.g. `[[hello]] [[world]]`.\n */\nvar joinAndWrap = exports.joinAndWrap = function joinAndWrap(arr, left, right) {\n  var separator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ' ';\n  return left + arr.join(right + separator + left) + right;\n};\n\n/**\n * Remove any newline from a string\n */\nvar getWithoutNewLines = exports.getWithoutNewLines = function getWithoutNewLines(str) {\n  return typeof str === 'string' ? str.replace(/[\\n\\r]/g, ' ') : str;\n};\n\n/**\n * Factory function to return a prototypeless object that is used as\n * map. It only has the property hasOwnProperty in order to to be\n * exchangeble with other framworks that depend on this method like\n * e.g. visjs.\n *\n * @param {Object} [initialValues] - an object whose own properties will be\n *     used to initialize the map.\n */\nvar makeHashMap = exports.makeHashMap = function makeHashMap(initialValues) {\n\n  var map = Object.create(null);\n  Object.defineProperty(map, 'hasOwnProperty', {\n    enumerable: false,\n    configurable: false,\n    writable: false,\n    value: Object.prototype.hasOwnProperty.bind(map)\n  });\n\n  if (initialValues) {\n    for (var key in initialValues) {\n      if (initialValues.hasOwnProperty(key)) {\n        map[key] = initialValues[key];\n      }\n    }\n  }\n\n  return map;\n};\n\n/**\n * If an ancestor that possesses a specified class exists the the\n * element will be returned, otherwise undefined is returned.\n *\n * @param {Element} el\n * @param {string} className\n */\nvar getAncestorWithClass = exports.getAncestorWithClass = function getAncestorWithClass(el, className) {\n\n  if ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) !== 'object' || typeof className !== 'string') {\n    return;\n  }\n\n  while (el.parentNode && el.parentNode !== document) {\n    el = el.parentNode;\n    if (el.classList.contains(className)) {\n      return el;\n    }\n  }\n};\n\n/**\n * Searches the dom for elements that possess a certain class\n * and removes this class from each element.\n *\n * @param {Array<string>} classNames - The class names to remove.\n */\nvar findAndRemoveClassNames = exports.findAndRemoveClassNames = function findAndRemoveClassNames(classNames) {\n\n  for (var i = classNames.length; i--;) {\n    var elements = document.getElementsByClassName(classNames[i]);\n    for (var j = elements.length; j--;) {\n      elements[j].classList.remove(classNames[i]);\n    }\n  }\n};\n\n/**\n * Polyfill until `isInteger` has become official. If the target\n * value is an integer, return true, otherwise return false.\n * If the value is NaN or infinite, return false.\n *\n * @param {*} value - The value to be tested for being an integer.\n * @return {boolean} True if the value is an integer, false otherwise.\n */\nvar isInteger = exports.isInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n *\n * @param {string} str\n * @param defaultReplacement\n * @param subStrings\n * @return {*}\n */\nvar replaceAll = exports.replaceAll = function replaceAll(str) {\n  var defaultReplacement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var subStrings = arguments[2];\n\n\n  for (var i = subStrings.length; i--;) {\n\n    var subString = subStrings[i];\n    var replacement = defaultReplacement;\n\n    if (Array.isArray(subString)) {\n      replacement = subString[1];\n      subString = subString[0];\n    }\n\n    str = str.replace(subString, replacement);\n  }\n\n  return str;\n};\n\n/**\n * Sadly, setting fields with tw means that we lose the type information\n * since field values are persisted as strings and the type is not\n * included.\n *\n * To ensure that flags are always interpreted correctly, the following\n * function exists.\n *\n * We regard the following values as `true` (order matters):\n *\n * # Any string that can be translated into a number unequal `0`\n * # `\"true\"`\n * # Any number unequal `0`\n * # Boolean `true`\n *\n * The following as false (order matters):\n *\n * # Any string that can be translated into number `0`\n * # Every string unequal `\"true\"`\n * # The number `0`\n * # Boolean `false`\n *\n */\nvar isTrue = exports.isTrue = function isTrue(confVal, defVal) {\n\n  if (confVal == null) {\n    return !!defVal;\n  } else if (typeof confVal === 'string') {\n    var n = parseInt(confVal);\n    return isNaN(n) ? confVal === 'true' : n !== 0;\n  } else if (typeof confVal === 'boolean') {\n    return confVal;\n  } else if (typeof confVal === 'number') {\n    return n !== 0;\n  }\n\n  return false;\n};\n\n/**\n * If the array contains the element, the element is removed from\n * the array in-place and the removed element.\n */\nvar removeArrayElement = exports.removeArrayElement = function removeArrayElement(arr, el) {\n\n  var index = arr.indexOf(el);\n  if (index > -1) {\n    return arr.splice(index, 1)[0];\n  }\n};\n\n/**\n * Returns a new object that contains only properties that start with\n * a certain prefix. The prefix is optionally removed from the result.\n *\n * @param {Object} obj\n * @param {string} prefix - The start sequence\n * @param {boolean} [removePrefix=false] - True if the prefix shall be removed\n *     from the resulting property name, false otherwise.\n * @result {object}\n */\nvar getPropertiesByPrefix = exports.getPropertiesByPrefix = function getPropertiesByPrefix(obj, prefix, removePrefix) {\n\n  var r = makeHashMap();\n  for (var p in obj) {\n    if (startsWith(p, prefix)) {\n      r[removePrefix ? p.substr(prefix.length) : p] = obj[p];\n    }\n  }\n\n  return r;\n};\n\n/**\n * Function to remove the prefix of a string\n */\nvar getWithoutPrefix = exports.getWithoutPrefix = function getWithoutPrefix(str, prefix) {\n  return startsWith(str, prefix) ? str.substr(prefix.length) : str;\n};\n\n/**\n *\n */\nvar hasKeyWithPrefix = exports.hasKeyWithPrefix = function hasKeyWithPrefix(obj, prefix) {\n\n  for (var p in obj) {\n    if (startsWith(p, prefix)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n *\n * @param arr\n */\nvar pickRandom = exports.pickRandom = function pickRandom(arr) {\n  return arr[getRandomInt(0, arr.length - 1)];\n};\n\n/**\n * Loads the image from web and passes it to the callback as\n * object url.\n */\nvar getImgFromWeb = exports.getImgFromWeb = function getImgFromWeb(imgUri, callback) {\n\n  if (!imgUri || typeof callback !== 'function') return;\n\n  var xhr = new XMLHttpRequest();\n  xhr.open('GET', imgUri, true);\n  xhr.responseType = 'blob';\n  xhr.onerror = function (e) {\n    console.log(e);\n  };\n  xhr.onload = function (e) {\n    if (this.readyState === 4 && (this.status === 200 || this.status === 0 && this.response.size > 0)) {\n      var blob = this.response;\n      callback(window.URL.createObjectURL(blob));\n    }\n  };\n\n  try {\n    xhr.send();\n  } catch (e) {\n    console.log(e);\n  }\n};\n\n//~ utils.getNestedProperty = function(obj, propPath) {\n//~\n//~ propPath = propPath.split(\".\");\n//~ for (var i = propPath.length; i--;) {\n//~ if (obj !== null && typeof obj === \"object\") {\n//~ obj = obj[propPath[i]];\n//~ }\n//~\n//~ };\n\n/**\n * Works like get `getElementById()` but is based on a class name.\n * It will return the first element inside an optional parent (root)\n * that has a class of this name.\n *\n * @param {string} cls - The class name to search for.\n * @param {Element} [root=document] - The context to search in.\n * @param {boolean} [isRequired=true] - If true, an exception will be\n *     thrown if no element can be retrieved. This is important\n *     when depending on third party modules and class names change!\n * @throws {EnvironmentError} - May be thrown if\n *    `isRequired` is set to true.\n * @return {Element} Either a dom element or null is returned.\n */\nvar getFirstElementByClassName = exports.getFirstElementByClassName = function getFirstElementByClassName(cls, root, isRequired) {\n\n  var el = (root || document).getElementsByClassName(cls)[0];\n  if (!el && (typeof isRequired === 'boolean' ? isRequired : true)) {\n    var text = 'Missing element with class \"' + cls + '\" inside ' + root;\n    throw new _exception.EnvironmentError(text);\n  }\n\n  return el;\n};\n\nvar getRandomLabel = exports.getRandomLabel = function getRandomLabel() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n  var adjective = pickRandom(['exciting', 'notable', 'epic', 'new', 'fancy', 'great', 'cool', 'fresh', 'funky', 'clever']);\n\n  var noun = (options.object || pickRandom(['concept', 'idea', 'thought', 'topic', 'subject'])) + (options.plural ? 's' : '');\n\n  return 'My ' + adjective + ' ' + noun;\n};\n\nvar _merge = function _merge(dest, src) {\n\n  if ((typeof dest === 'undefined' ? 'undefined' : _typeof(dest)) !== 'object') {\n    dest = {};\n  }\n\n  for (var p in src) {\n    if (src.hasOwnProperty(p)) {\n      if (src[p] != null) {\n        // skip null or undefined\n        dest[p] = _typeof(src[p]) === 'object' ? _merge(dest[p], src[p]) : src[p]; // primitive type, stop recursion\n      }\n    }\n  }\n\n  return dest;\n};\n\n/**\n * Merges `src` into `dest` which means that the merge transforms\n * the `dest` object itself. If src and dest both have the same\n * property path, src does only replace the primitive data type\n * at the end of the path.\n *\n * @todo Should null really be skipped or treated as value?\n *\n * @param {Object} dest - The destination object.\n * @param {...Object} sources - At least one object to merge into `dest`.\n * @return {Object} The original `dest` object.\n */\nvar merge = exports.merge = function merge(dest) {\n  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  // start the merging; i = 1 since first argument is the destination\n  for (var i = 0, l = sources.length; i < l; i++) {\n    var src = sources[i];\n    if (src != null && (typeof src === 'undefined' ? 'undefined' : _typeof(src)) === 'object') {\n      dest = _merge(dest, src);\n    }\n  }\n\n  return dest;\n};\n\n/**\n * Adds or removes listeners from the target in capture or\n * non-capture (bubbling) mode.\n *\n * @param {string} task - Either \"add\" or \"remove\". Make sure to\n *     always call add and remove with *excatly* the same listeners\n *     Note: if you use bind, you change the function object.\n * @param {Element} target - The element to attach or remove the\n *     listener to or from.\n * @param {Object<string, (Function|Array)>} listeners - The key is\n *     the event name and the value is either a handler function\n *     or an array where the first index is the handler function and\n *     the second is a boolean that specifies whether to use capture\n *     or not.\n * @param {boolean} [isCapt=false] - Whether to run the handler in\n *     bubbling or capturing phase.\n */\nvar setDomListeners = exports.setDomListeners = function setDomListeners(task, target, listeners, isCapt) {\n\n  isCapt = typeof isCapt === 'boolean' ? isCapt : false;\n  task = task + 'EventListener';\n\n  for (var event in listeners) {\n\n    var l = listeners[event];\n\n    if (typeof l === 'function') {\n\n      target[task](event, l, isCapt);\n    } else {\n      // expect Array\n\n      target[task](event, l[0], typeof l[1] === 'boolean' ? l[1] : isCapt);\n    }\n  }\n};\n\n/**\n * Removes all child nodes of a DOM element. This includes element\n * and non-element objects.\n */\nvar removeDOMChildNodes = exports.removeDOMChildNodes = function removeDOMChildNodes(el) {\n\n  for (var i = el.childNodes.length; i--;) {\n    el.removeChild(el.childNodes[i]);\n  }\n};\n\n/**\n * Implementation of the algebraic modulus operation.\n *\n * In javascript '%' is really a remainder operator, not a modulus.\n * Algebraically speaking, a modulus operation always yields\n * positive results, while '%' in js can yield negative results.\n *\n * Note: divident mod divisor\n *\n * @param {number} divident\n * @param {number} divisor\n * @return {number}\n */\nvar mod = exports.mod = function mod(divident, divisor) {\n\n  var remainder = divident % divisor;\n\n  return Math.floor(remainder >= 0 ? remainder : remainder + divisor);\n};\n\n/**\n * Maps a coordinate to the nearest raster coordinate.\n *\n * @param {number} x\n * @param {number} y\n * @param {number} raster\n * @return {{x: number, y: number}}\n */\nvar getNearestRasterPosition = exports.getNearestRasterPosition = function getNearestRasterPosition(_ref, raster) {\n  var x = _ref.x,\n      y = _ref.y;\n\n\n  var rasterHalf = raster / 2;\n\n  // calculate distances to previous raster lines\n  var distPrevX = mod(x, raster);\n  var distPrevY = mod(y, raster);\n\n  return {\n    x: distPrevX < rasterHalf ? x - distPrevX : x - distPrevX + raster,\n    y: distPrevY < rasterHalf ? y - distPrevY : y - distPrevY + raster\n  };\n};\n\n/**\n * Force early binding of functions to this context.\n *\n * @param context the context to bind this function to (typically `this`)\n * @param {Array<string>} fnNames - The prototype function names\n *     to bind to this context.\n */\nvar bindTo = exports.bindTo = function bindTo(context, fnNames) {\n\n  for (var i = fnNames.length; i--;) {\n    var fn = context[fnNames[i]];\n    context[fnNames[i]] = fn.bind(context);\n  }\n};\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/lib/utils/basic.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/lib/utils/thirdParty": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/lib/utils/thirdParty",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/utils/thirdParty\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/**\n * Modified TW-Code from Navigator widget\n * https://github.com/Jermolene/TiddlyWiki5/blob/master/core/modules/widgets/navigator.js\n */\nvar generateDraftTitle = exports.generateDraftTitle = function generateDraftTitle(title) {\n\n  var c = 0,\n      draftTitle = void 0;\n  do {\n    draftTitle = 'Draft ' + (c ? c + 1 + ' ' : '') + 'of \\'' + title + '\\'';\n    c++;\n  } while ($tw.wiki.tiddlerExists(draftTitle));\n  return draftTitle;\n};\n\n/**\n * Modified TW-Code from Navigator widget\n * https://github.com/Jermolene/TiddlyWiki5/blob/master/core/modules/widgets/navigator.js\n */\nvar makeDraftTiddler = exports.makeDraftTiddler = function makeDraftTiddler(targetTitle) {\n\n  // See if there is already a draft tiddler for this tiddler\n  var draftTitle = $tw.wiki.findDraft(targetTitle);\n  if (draftTitle) {\n    return $tw.wiki.getTiddler(draftTitle);\n  }\n  // Get the current value of the tiddler we're editing\n  var tiddler = $tw.wiki.getTiddler(targetTitle);\n  // Save the initial value of the draft tiddler\n  draftTitle = generateDraftTitle(targetTitle);\n  var draftTiddler = new $tw.Tiddler(tiddler, {\n    title: draftTitle,\n    'draft.title': targetTitle,\n    'draft.of': targetTitle\n  }, $tw.wiki.getModificationFields());\n  $tw.wiki.addTiddler(draftTiddler);\n  return draftTiddler;\n};\n\n/**\n * TW-Code\n * @deprecated delete this in 2016 and use $tw.utils.getFullScreenApis instead\n */\nvar getFullScreenApis = exports.getFullScreenApis = function getFullScreenApis() {\n\n  var d = document,\n      db = d.body,\n      result = {\n    '_requestFullscreen': db.webkitRequestFullscreen !== undefined ? 'webkitRequestFullscreen' : db.mozRequestFullScreen !== undefined ? 'mozRequestFullScreen' : db.msRequestFullscreen !== undefined ? 'msRequestFullscreen' : db.requestFullscreen !== undefined ? 'requestFullscreen' : '',\n    '_exitFullscreen': d.webkitExitFullscreen !== undefined ? 'webkitExitFullscreen' : d.mozCancelFullScreen !== undefined ? 'mozCancelFullScreen' : d.msExitFullscreen !== undefined ? 'msExitFullscreen' : d.exitFullscreen !== undefined ? 'exitFullscreen' : '',\n    '_fullscreenElement': d.webkitFullscreenElement !== undefined ? 'webkitFullscreenElement' : d.mozFullScreenElement !== undefined ? 'mozFullScreenElement' : d.msFullscreenElement !== undefined ? 'msFullscreenElement' : d.fullscreenElement !== undefined ? 'fullscreenElement' : '',\n    '_fullscreenChange': d.webkitFullscreenElement !== undefined ? 'webkitfullscreenchange' : d.mozFullScreenElement !== undefined ? 'mozfullscreenchange' : d.msFullscreenElement !== undefined ? 'MSFullscreenChange' : d.fullscreenElement !== undefined ? 'fullscreenchange' : ''\n  };\n  if (!result._requestFullscreen || !result._exitFullscreen || !result._fullscreenElement) {\n    return null;\n  } else {\n    return result;\n  }\n};\n\n/**\n *\n * Slightly modified by me to allow an optional prefix.\n *\n * For the original code:\n *\n * Copyright (c) 2014, Hugh Kennedy, All rights reserved.\n * Code published under the BSD 3-Clause License\n *\n * @see oringal repo https://github.com/hughsk/flat\n * @see snapshot https://github.com/felixhayashi/flat\n * @see http://opensource.org/licenses/BSD-3-Clause\n */\nvar flatten = exports.flatten = function flatten(target) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n  var delimiter = opts.delimiter || '.';\n  var prefix = opts.prefix || '';\n  var output = {};\n\n  function step(object, prev) {\n    Object.keys(object).forEach(function (key) {\n      var value = object[key];\n      var isarray = opts.safe && Array.isArray(value);\n      var type = Object.prototype.toString.call(value);\n      var isobject = type === '[object Object]' || type === '[object Array]';\n\n      var newKey = prev ? prev + delimiter + key : prefix + key;\n\n      if (!isarray && isobject) {\n        return step(value, newKey);\n      }\n\n      output[newKey] = value;\n    });\n  }\n\n  step(target);\n\n  return output;\n};\n\n/**\n * Copyright (c) 2014, Hugh Kennedy, All rights reserved.\n * Code published under the BSD 3-Clause License\n *\n * @see oringal repo https://github.com/hughsk/flat\n * @see snapshot https://github.com/felixhayashi/flat\n * @see http://opensource.org/licenses/BSD-3-Clause\n */\nvar unflatten = exports.unflatten = function unflatten(target) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n  var delimiter = opts.delimiter || '.';\n  var result = {};\n\n  if (Object.prototype.toString.call(target) !== '[object Object]') {\n    return target;\n  }\n\n  // safely ensure that the key is\n  // an integer.\n  function getkey(key) {\n    var parsedKey = Number(key);\n\n    return isNaN(parsedKey) || key.indexOf('.') !== -1 ? key : parsedKey;\n  }\n\n  Object.keys(target).forEach(function (key) {\n    var split = key.split(delimiter);\n    var key1 = getkey(split.shift());\n    var key2 = getkey(split[0]);\n    var recipient = result;\n\n    while (key2 !== undefined) {\n      if (recipient[key1] === undefined) {\n        recipient[key1] = typeof key2 === 'number' && !opts.object ? [] : {};\n      }\n\n      recipient = recipient[key1];\n      if (split.length > 0) {\n        key1 = getkey(split.shift());\n        key2 = getkey(split[0]);\n      }\n    }\n\n    // unflatten again for 'messy objects'\n    recipient[key1] = unflatten(target[key], opts);\n  });\n\n  return result;\n};\n\n/**\n * An adopted version of pmario's version to create\n * uuids of type RFC4122, version 4 ID.\n *\n * Shortened version:\n * pmario (1.0 - 2011.05.22):\n * http://chat-plugins.tiddlyspace.com/#UUIDPlugin\n *\n * Original version:\n * Math.uuid.js (v1.4)\n * http://www.broofa.com\n * mailto:robert@broofa.com\n *\n * Copyright (c) 2010 Robert Kieffer\n * Dual licensed under the MIT and GPL licenses.\n *\n * ---\n * @see https://github.com/almende/vis/issues/432\n*/\nvar genUUID = exports.genUUID = function () {\n\n  // Private array of chars to use\n  var CHARS = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');\n\n  return function () {\n    var chars = CHARS,\n        uuid = new Array(36);\n\n    var rnd = 0,\n        r;\n    for (var i = 0; i < 36; i++) {\n      if (i == 8 || i == 13 || i == 18 || i == 23) {\n        uuid[i] = '-';\n      } else if (i == 14) {\n        uuid[i] = '4';\n      } else {\n        if (rnd <= 0x02) rnd = 0x2000000 + Math.random() * 0x1000000 | 0;\n        r = rnd & 0xf;\n        rnd = rnd >> 4;\n        uuid[i] = chars[i == 19 ? r & 0x3 | 0x8 : r];\n      }\n    }\n\n    return uuid.join('');\n  };\n}();\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/lib/utils/thirdParty.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/lib/utils/tmap": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/lib/utils/tmap",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSnapshotTitle = exports.getArrayValuesAsHashmapKeys = exports.getLookupTable = exports.keyOfItemWithProperty = exports.keysOfItemsWithProperty = exports.getDublicates = exports.getId = exports.refreshDataSet = exports.drawRaster = exports.getPrettyFilter = exports.groupByProperty = exports.isEdgeTypeMatch = exports.getEdgeTypeMatches = exports.getDataUri = exports.convert = exports.getValues = exports.getIterableCollection = exports.getLabel = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/utils/tmap\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nvar _vis = require('$:/plugins/felixhayashi/vis/vis.js');\n\nvar _vis2 = _interopRequireDefault(_vis);\n\nvar _exception = require('$:/plugins/felixhayashi/tiddlymap/js/exception');\n\nvar _basic = require('$:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic');\n\nvar basicUtils = _interopRequireWildcard(_basic);\n\nvar _wiki = require('$:/plugins/felixhayashi/tiddlymap/js/lib/utils/wiki');\n\nvar wikiUtils = _interopRequireWildcard(_wiki);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * TODO: this method does not seem to be used!\n * @param {Tiddler} tiddler\n * @param {string} aliasField - A tiddler field that contains an\n *     alternative title (e.g. \"caption\").\n * @return {string|undefined} If the `aliasField` exists and is not\n *     empty, the value of the `aliasField` otherwise the tiddler's\n *     title or undefined if the tiddler doesn't exist.\n */\nvar getLabel = exports.getLabel = function getLabel(tiddler, aliasField) {\n  var tObj = wikiUtils.getTiddler(tiddler);\n  return (tObj && tObj.fields[aliasField] ? tObj.fields[aliasField] : tObj.fields.title).replace('\\\\n', '\\n');\n};\n\n/**\n * This function will return a collection object whose data can be\n * via `Object.keys(col)` in a loop.\n *\n * @param {Collection} col - A collection\n * @return {Hashmap} The iterable object.\n */\nvar getIterableCollection = exports.getIterableCollection = function getIterableCollection(col) {\n  return col instanceof _vis2.default.DataSet ? col.get() : col;\n};\n\n/**\n * Extract all the values from a collection. If `col` is an object,\n * only properties are considered that are its own and iterable.\n *\n * @param {Collection} col\n * @return {Array} An array\n */\nvar getValues = exports.getValues = function getValues(col) {\n\n  if (Array.isArray(col)) {\n\n    return col; // bounce back.\n  } else if (col instanceof _vis2.default.DataSet) {\n    // a dataset\n\n    return col.get({ returnType: 'Array' });\n  }\n\n  var result = [];\n  var keys = Object.keys(col);\n  for (var i = keys.length; i--;) {\n    result.push(col[keys[i]]);\n  }\n\n  return result;\n};\n\n/**\n * Transforms a collection of a certain type into a collection of\n * another type.\n *\n * **Attention**: When trying to convert an array into a object, the\n * array will be simply bounced back. Let's hope no one added enumerable\n * properties to Array.prototype :)\n *\n * @param {Collection} col - The collection to convert.\n * @param {CollectionTypeString} [outputType=\"dataset\"] - The output type.\n * @return {Collection} A **new** collection of type `outputType`.\n */\nvar convert = exports.convert = function convert(col, outputType) {\n\n  if ((typeof col === 'undefined' ? 'undefined' : _typeof(col)) !== 'object') {\n    throw new _exception.InvalidArgumentException(col, outputType);\n  }\n\n  if (outputType === 'object') {\n    outputType = 'hashmap';\n  }\n\n  var mapper = {\n    array: function array(col) {\n      return getValues(col);\n    },\n    hashmap: function hashmap(col) {\n      return col instanceof _vis2.default.DataSet ? col.get({ returnType: 'Object' }) : col;\n    },\n    dataset: function dataset(col) {\n      return col instanceof _vis2.default.DataSet ? col : !Array.isArray(col) ? getValues(col) : new _vis2.default.DataSet(col);\n    }\n  };\n\n  return mapper[outputType](col);\n};\n\n/**\n * @param {Tiddler} tiddler\n * @param {string} [type]\n * @param {boolean} [isForceBase64]\n * @return {string}\n */\nvar getDataUri = exports.getDataUri = function getDataUri(tiddler, type, isForceBase64) {\n\n  var imgTObj = wikiUtils.getTiddler(tiddler);\n  type = type || imgTObj.fields.type || 'image/svg+xml';\n  var body = imgTObj.fields.text;\n  var encoding = $tw.config.contentTypeInfo[type].encoding;\n\n  if (type === 'image/svg+xml') {\n\n    // see http://stackoverflow.com/questions/10768451/inline-svg-in-css\n    body = body.replace(/\\r?\\n|\\r/g, ' ');\n\n    if (!basicUtils.hasSubString('xmlns', body)) {\n      // @tiddlywiki it is bad to remove the xmlns attribute!\n\n      body = body.replace(/<svg/, '<svg xmlns=\"http://www.w3.org/2000/svg\"');\n    }\n  }\n\n  if (isForceBase64 && encoding !== 'base64') {\n    encoding = 'base64';\n    body = basicUtils.base64(body);\n  }\n\n  return 'data:' + type + ';' + encoding + ',' + body;\n};\n\n// @todo move this to environment\nvar eTyFiltAutoPrefix = '[all[]] ';\n\n/**\n *\n * @param filter\n * @param titles\n * @return {*}\n */\nvar getEdgeTypeMatches = exports.getEdgeTypeMatches = function getEdgeTypeMatches() {\n  var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var titles = arguments[1];\n\n\n  if (!titles) {\n    titles = wikiUtils.getTiddlersByPrefix($tm.path.edgeTypes + '/', {\n      iterator: 'eachTiddlerPlusShadows',\n      removePrefix: true\n    });\n  }\n\n  if (titles != null && !Array.isArray(titles)) {\n    titles = Object.keys(titles);\n  }\n\n  return wikiUtils.getMatches(eTyFiltAutoPrefix + filter, titles);\n};\n\nvar isEdgeTypeMatch = exports.isEdgeTypeMatch = function isEdgeTypeMatch(title) {\n  var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return wikiUtils.isMatch(title, eTyFiltAutoPrefix + filter);\n};\n\n/**\n *\n */\nvar groupByProperty = exports.groupByProperty = function groupByProperty(col, prop) {\n\n  col = getIterableCollection(col);\n\n  var result = basicUtils.makeHashMap();\n  var keys = Object.keys(col);\n\n  for (var i in keys) {\n\n    var item = col[keys[i]];\n    var val = item[prop];\n\n    if (val == null) {\n      // null or undefined\n\n      // @todo use exception class\n      throw 'Cannot group by property ' + prop;\n    } else {\n\n      if (!Array.isArray(result[val])) {\n        result[val] = [];\n      }\n      result[val].push(item);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Turns the filter expression in a nicely formatted (but unusable)\n * text, making it easier to edit long filter expressions.\n *\n * @param {string} expr - A valid filter expression.\n * @result {string} A formatted (unusable) filter expression.\n */\nvar getPrettyFilter = exports.getPrettyFilter = function getPrettyFilter(expr) {\n\n  // remove outer spaces and separate operands\n  expr = expr.trim().replace('][', '] [');\n\n  // regex to identify operands\n  var re = /[+-]?\\[.+?[\\]\\}\\>]\\]/g;\n\n  // get operands\n  var operands = expr.match(re);\n\n  // replace operands with dummies and trim again to avoid trailing spaces\n  expr = expr.replace(re, ' [] ').trim();\n\n  // turn it into an array\n  var stringsPlusDummies = expr.split(/\\s+/);\n\n  var operandIndex = 0;\n  var parts = [];\n  for (var i = 0, l = stringsPlusDummies.length; i < l; i++) {\n    parts[i] = stringsPlusDummies[i] === '[]' ? operands[operandIndex++] : stringsPlusDummies[i];\n  }\n\n  return parts.join('\\n');\n};\n\n/**\n * This function will draw a raster on the network canvas that will\n * adjust to the network's current scaling factor and viewport offset.\n *\n * @param {CanvasRenderingContext2D} ctx - The canvas's context passed by vis.\n * @param {number} scaleFactor - The current scale factor of the network.\n * @param {Object} viewCenter - Virtual center point of the view.\n * @param {number} rasterSize - The size of the squares that are drawn.\n * @param {string} color - A string parsed as CSS color value.\n */\nvar drawRaster = exports.drawRaster = function drawRaster(ctx, scaleFactor, viewCenter, rasterSize) {\n  var color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '#D9D9D9';\n\n  // from now on the most central raster point\n  var _basicUtils$getNeares = basicUtils.getNearestRasterPosition(viewCenter, rasterSize),\n      centerX = _basicUtils$getNeares.x,\n      centerY = _basicUtils$getNeares.y;\n\n  var scaledWidth = ctx.canvas.width / scaleFactor;\n  var scaledHeight = ctx.canvas.height / scaleFactor;\n\n  // some extra lines to ensure the canvas is completely filled with lines\n  var extraLines = rasterSize * 2;\n\n  // calculate the space that is required to draw the rasters\n  var hSpace = Math.ceil(scaledWidth / rasterSize / 2) * rasterSize + extraLines;\n  var vSpace = Math.ceil(scaledHeight / rasterSize / 2) * rasterSize + extraLines;\n\n  // align the space to the center points and calculate the offsets\n  var left = centerX - hSpace;\n  var right = centerX + hSpace;\n  var top = centerY - vSpace;\n  var bottom = centerY + vSpace;\n\n  ctx.beginPath();\n\n  // draw vertical lines\n  for (var x = left; x < right; x += rasterSize) {\n    ctx.moveTo(x, top);\n    ctx.lineTo(x, bottom);\n  }\n\n  // draw horizontal lines\n  for (var y = top; y <= bottom; y += rasterSize) {\n    ctx.moveTo(left, y);\n    ctx.lineTo(right, y);\n  }\n\n  ctx.strokeStyle = color;\n  ctx.fillStyle = color;\n  ctx.stroke();\n};\n\n/**\n * Updates a dataset.\n *\n * Note: never use the dataset's update() method, it does not properly remove\n * obsolete properties! – use remove and add instead.\n *\n * @param {vis.DataSet} [ds] - The dataset to be updated\n * @param {Hashmap<id, Node>} ltNew - Lookup table that contains the *new* set of nodes.\n */\nvar refreshDataSet = exports.refreshDataSet = function refreshDataSet(ds, ltNew) {\n\n  var ltOld = ds.get({ returnType: 'Object' });\n\n  var inserted = [];\n  var updated = [];\n  var withoutPosition = [];\n  var removed = [];\n\n  for (var id in ltNew) {\n\n    if (ltOld[id]) {\n      // element already exists in graph\n\n      if (basicUtils.isEqual(ltOld[id], ltNew[id])) {\n        // simply keep element\n        continue;\n      }\n\n      updated.push(id);\n      ds.remove(id);\n    } else {\n\n      inserted.push(id);\n    }\n\n    if (ltNew[id].x === undefined) {\n      withoutPosition.push(id);\n    }\n\n    ds.add(ltNew[id]);\n  }\n\n  for (var _id in ltOld) {\n    if (!ltNew[_id]) {\n      removed.push(_id);\n      ds.remove(_id);\n    }\n  }\n\n  return {\n    withoutPosition: withoutPosition,\n    inserted: inserted,\n    updated: updated,\n    removed: removed\n  };\n};\n\n/**\n * Returns the tmap id that is stored in a designated field in the tiddler.\n *\n * @param tiddler\n * @return {string} the tmap id of this tiddler\n */\nvar getId = exports.getId = function getId(tiddler) {\n  return wikiUtils.getTiddler(tiddler).fields['tmap.id'];\n};\n\n/**\n * Returns all other tiddlers that have the same tmap.id field entry.\n *\n * Note: typically tiddlers don't have the same id assigned, however,\n * this can happen when tiddlers are imported or cloned.\n *\n * @param {Tiddler} tiddler\n * @return {array<TiddlerReference>} a list of tiddlers with the same id as the\n *    provided tiddler (excluding the provided tiddler itself).\n */\nvar getDublicates = exports.getDublicates = function getDublicates(tiddler) {\n\n  var id = getId(tiddler);\n\n  if (!id) {\n\n    return [];\n  }\n\n  var tiddlers = wikiUtils.getTiddlersWithField('tmap.id', id, { limit: 2 });\n  delete tiddlers[wikiUtils.getTiddlerRef(tiddler)];\n\n  return Object.keys(tiddlers);\n};\n\n/**\n * Function that searches an array for an object with a property\n * having a certain value.\n *\n * Attention: Not the item itself but the item's key is returned.\n *\n * @param {Collection} col - The collection to search in.\n * @param {string} key - The property name to look for.\n * @param {*} [val] - An optional value that the object's property must have\n *     in order to match.\n * @param {number} [limit] - An optional result limit (>0) to stop the search.\n * @return {Array<Id>} An array containing the indeces of matching items.\n */\nvar keysOfItemsWithProperty = exports.keysOfItemsWithProperty = function keysOfItemsWithProperty(col, key, val, limit) {\n\n  col = getIterableCollection(col);\n\n  var keys = Object.keys(col);\n  var result = [];\n\n  limit = typeof limit === 'number' ? limit : keys.length;\n\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var index = keys[i];\n    if (_typeof(col[index]) === 'object' && col[index][key]) {\n      if (!val || col[index][key] === val) {\n        result.push(index);\n        if (result.length === limit) {\n          break;\n        }\n      }\n    }\n  }\n\n  return result;\n};\n\n/**\n *\n * @param col\n * @param key\n * @param val\n * @return {*}\n */\nvar keyOfItemWithProperty = exports.keyOfItemWithProperty = function keyOfItemWithProperty(col, key, val) {\n  return keysOfItemsWithProperty(col, key, val, 1)[0];\n};\n\n/**\n * In a collection where all elements have a **distinct** property\n * `lookupKey`, use the value of each element's `lookupKey` as key\n * to identify the object. If no property `lookupKey` is specified,\n * the collection's values are used as keys and `true` is used as value,\n * however, if the used keys are not strings, an error is thrown.\n *\n * @param {Collection} col - The collection for which to create a lookup table.\n * @param {string} [lookupKey] - The property name to use as index in\n *     the lookup table. If not specified, the collection values are tried\n *     to be used as indeces.\n * @return {Hashmap} The lookup table.\n */\nvar getLookupTable = exports.getLookupTable = function getLookupTable(col, lookupKey) {\n\n  col = getIterableCollection(col);\n\n  var lookupTable = basicUtils.makeHashMap();\n  var keys = Object.keys(col);\n\n  for (var i = 0, l = keys.length; i < l; i++) {\n\n    var key = keys[i];\n    var idx = lookupKey ? col[key][lookupKey] : col[key];\n    var type = typeof idx === 'undefined' ? 'undefined' : _typeof(idx);\n\n    if (type === 'string' && idx !== '' || type === 'number') {\n      if (!lookupTable[idx]) {\n        // doesn't exist yet!\n        lookupTable[idx] = lookupKey ? col[key] : true;\n        continue;\n      }\n    }\n\n    // @todo use exception class\n    throw new Error('Cannot use \"' + idx + '\" as lookup table index');\n  }\n\n  return lookupTable;\n};\n\n/**\n * Alias for {@link getLookupTable}\n */\nvar getArrayValuesAsHashmapKeys = exports.getArrayValuesAsHashmapKeys = getLookupTable;\n\n/**\n *\n * @param viewLabel\n * @param type\n */\nvar getSnapshotTitle = exports.getSnapshotTitle = function getSnapshotTitle(viewLabel, type) {\n  return 'Snapshot \\u2013 ' + viewLabel + ' (' + new Date().toDateString() + ').' + (type || 'png');\n};\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/lib/utils/tmap.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/utils": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/utils",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.utils = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/utils\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nvar _basic = require('$:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic');\n\nvar basicUtils = _interopRequireWildcard(_basic);\n\nvar _thirdParty = require('$:/plugins/felixhayashi/tiddlymap/js/lib/utils/thirdParty');\n\nvar thirdPartyUtils = _interopRequireWildcard(_thirdParty);\n\nvar _wiki = require('$:/plugins/felixhayashi/tiddlymap/js/lib/utils/wiki');\n\nvar wikiUtils = _interopRequireWildcard(_wiki);\n\nvar _tmap = require('$:/plugins/felixhayashi/tiddlymap/js/lib/utils/tmap');\n\nvar tMapUtils = _interopRequireWildcard(_tmap);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*** Code **********************************************************/\n\n/**\n * A utilities class that contains universally used helper functions\n * to abbreviate code and make my life easier.\n *\n * ATTENTION: This module must not require any other tiddlymap file\n * in order to avoid cyclic dependencies. For the same reason,\n * it must also not access the `$tm.*` object.\n *\n * Exceptions to this restriction:\n *   - The utils module may access all `$tm.*` properties\n *     defined in startup.environment.\n *   - The utils module may require vendor libs or tiddlymap libs\n *     that only require vendor libs themselves.\n *\n * @see Dom utilities {@link https://github.com/Jermolene/TiddlyWiki5/blob/master/core/modules/utils/*}\n * @namespace utils\n */\nvar utils = exports.utils = _extends({}, basicUtils, thirdPartyUtils, wikiUtils, tMapUtils);\n\nexports.default = utils;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/lib/utils/utils.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/lib/utils/wiki": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/lib/utils/wiki",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.touch = exports.addTiddler = exports.getTiddlersByPrefix = exports.getTiddlerWithField = exports.getTiddlersWithField = exports.deleteByPrefix = exports.cp = exports.mv = exports.addTWlisteners = exports.getChildWidgetByProperty = exports.getMergedTiddlers = exports.isSystemOrDraft = exports.isDraft = exports.setText = exports.getText = exports.isLeftVersionGreater = exports.getEntry = exports.setEntry = exports.clone = exports.writeFieldData = exports.parseFieldData = exports.isPreviewed = exports.notify = exports.registerTransclude = exports.getElementNode = exports.getTiddlerNode = exports.getTranscludeNode = exports.isMatch = exports.getMatches = exports.moveFieldValues = exports.deleteTiddlers = exports.setField = exports.setSidebarTab = exports.tiddlerExists = exports.getField = exports.getTiddler = exports.getTiddlerRef = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _exception = require('$:/plugins/felixhayashi/tiddlymap/js/exception');\n\nvar _basic = require('$:/plugins/felixhayashi/tiddlymap/js/lib/utils/basic');\n\nvar basicUtils = _interopRequireWildcard(_basic);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/lib/utils/wiki\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\n/**\n * Gets a tiddler reference from a tRef or tObj\n *\n * @param {Tiddler|string} tiddler - A tiddler reference or object.\n * @return {TiddlerReference|null} A tiddler reference (title)\n */\nvar getTiddlerRef = exports.getTiddlerRef = function getTiddlerRef(tiddler) {\n\n  if (tiddler instanceof $tw.Tiddler) {\n\n    return tiddler.fields.title;\n  } else if (typeof tiddler === 'string') {\n\n    return tiddler;\n  } else {\n\n    throw new _exception.InvalidArgumentException(tiddler);\n  }\n};\n\n/**\n * Similar to {@code wiki.getTiddler()} but also accepts a tObj as\n * argument, thus, making it unnecessary to always differentiate or remember\n * if we are dealing with an object or a reference.\n *\n * @see https://github.com/Jermolene/TiddlyWiki5/blob/master/boot/boot.js#L866\n * @param {Tiddler} tiddler - A tiddler reference or object.\n * @return {Tiddler} A tiddler object.\n */\nvar getTiddler = exports.getTiddler = function getTiddler(tiddler) {\n  return $tw.wiki.getTiddler(tiddler instanceof $tw.Tiddler ? tiddler.fields.title : tiddler);\n};\n\n/**\n * Get a tiddler's field value. If the field does not exist or\n * its value is an empty string, return the default or an empty\n * string.\n */\nvar getField = exports.getField = function getField(tiddler, field) {\n  var defValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n\n  var tObj = getTiddler(tiddler);\n  return !tObj ? defValue : tObj.fields[field] || defValue;\n};\n\n/**\n * Checks if tiddlers (including shadow tiddlers) exist.\n *\n * @param {Tiddler} tiddler\n * @return {boolean} True if the tiddler exists, false otherwise\n */\nvar tiddlerExists = exports.tiddlerExists = function tiddlerExists(tiddler) {\n\n  if (!tiddler) {\n    return false;\n  }\n\n  var tRef = getTiddlerRef(tiddler);\n\n  return Boolean(tRef && ($tw.wiki.tiddlerExists(tRef) || $tw.wiki.isShadowTiddler(tRef)));\n};\n\nvar setSidebarTab = exports.setSidebarTab = function setSidebarTab(tRef) {\n\n  setText(getTiddlersByPrefix('$:/state/tab/sidebar-')[0], tRef);\n};\n\n/**\n * Set a tiddler field to a given value.\n *\n * Setting the title field to another value will clone the tiddler.\n * In this case, better use @link{clone} as this is\n * semantically stronger.\n *\n * This method is guarded against\n * https://github.com/Jermolene/TiddlyWiki5/issues/2025\n *\n * @return {$tw.Tiddler|undefined} The tiddler object containing\n *     the field with the assigned value.\n */\nvar setField = exports.setField = function setField(tiddler, field, value) {\n\n  if (!tiddler || !field) {\n    return;\n  }\n\n  var tRef = getTiddlerRef(tiddler);\n  var fields = _defineProperty({\n    title: tRef\n  }, field, value);\n\n  // do not use any tObj provided, it may result in a lost update!\n  var tObj = $tw.wiki.getTiddler(tRef, true);\n\n  if (field !== 'text' && tObj && !tObj.fields.text) {\n    fields.text = '';\n  }\n\n  tObj = new $tw.Tiddler(tObj, fields);\n  $tw.wiki.addTiddler(tObj);\n\n  return tObj;\n};\n\n/**\n * Pendant to tw native {@code addTiddlers()}.\n *\n * Also removes tiddlers from the river.\n *\n * @param {TiddlerCollection} tiddlers - A collection of tiddlers\n * to be removed.\n */\nvar deleteTiddlers = exports.deleteTiddlers = function deleteTiddlers(tiddlers) {\n\n  var keys = Object.keys(tiddlers);\n  var storyList = $tw.wiki.getTiddlerList('$:/StoryList');\n\n  for (var i = keys.length; i--;) {\n    var tRef = getTiddlerRef(tiddlers[keys[i]]);\n    if (!$tw.wiki.tiddlerExists(tiddlers[keys[i]])) {\n      // this check is important!\n      // see https://github.com/Jermolene/TiddlyWiki5/issues/1919\n      continue;\n    }\n\n    var index = storyList.indexOf(tRef);\n    if (index !== -1) {\n      // tiddler is displayed in river\n      storyList.splice(index, 1);\n      setField('$:/StoryList', 'list', storyList);\n    }\n\n    // finally delete the tiddler;\n\n\n    $tw.wiki.deleteTiddler(tRef);\n  }\n};\n\nvar moveFieldValues = exports.moveFieldValues = function moveFieldValues(oldName, newName, isRemoveOldField, isIncludeSystemTiddlers, tiddlers) {\n\n  if (oldName === newName) return;\n\n  var allTiddlers = tiddlers || $tw.wiki.allTitles();\n\n  for (var i = allTiddlers.length; i--;) {\n\n    var tObj = getTiddler(allTiddlers[i]);\n\n    if (tObj.isDraft() || !tObj.fields[oldName]) {\n      continue;\n    }\n\n    if (!isIncludeSystemTiddlers && $tw.wiki.isSystemTiddler(allTiddlers[i])) {\n      continue;\n    }\n\n    var fields = _defineProperty({}, newName, tObj.fields[oldName]);\n\n    if (isRemoveOldField) {\n      fields[oldName] = undefined;\n    }\n    $tw.wiki.addTiddler(new $tw.Tiddler(tObj, fields));\n  }\n};\n\n/**\n * This function returns all tiddlers that match the filter.\n *\n * @Todo: skip drafts! Or not?\n *\n * @param {TiddlyWikiFilter} filter - The filter to use.\n * @param {TiddlerCollection} [tiddlers] - A set of tiddlers used as\n *     source. If not defined, all tiddlers and system tiddlers are\n *     selected. Shadows are *not* included.\n * @return {Array.<TiddlerReference>}\n */\nvar getMatches = exports.getMatches = function getMatches(filter, tiddlers, widget) {\n\n  // use wiki as default source\n  var source = undefined;\n\n  // shortcuts for performance\n  var wiki = $tw.wiki;\n\n  if (typeof filter === 'string') {\n    filter = wiki.compileFilter(filter);\n  }\n\n  // if a source is provided, create an iterator callback\n  if (tiddlers != null && (typeof tiddlers === 'undefined' ? 'undefined' : _typeof(tiddlers)) === 'object') {\n\n    if (!Array.isArray(tiddlers)) {\n      tiddlers = Object.keys(tiddlers);\n    }\n\n    source = function source(callback) {\n      for (var i = tiddlers.length; i--;) {\n        var tObj = wiki.getTiddler(tiddlers[i]);\n        callback(tObj, tiddlers[i]);\n      }\n    };\n  }\n\n  return filter.call(wiki, source, widget);\n};\n\n/**\n * Tries to match a single tiddler object against a filter.\n * Returns a boolean value.\n *\n * @param {Tiddler} tiddler - The object to apply the filter to.\n * @param {TiddlyWikiFilter} filter - The filter to use.\n * @return {boolean} True if the tiddler matches the filter, false otherwise.\n */\nvar isMatch = exports.isMatch = function isMatch(tiddler, filter) {\n  return getTiddlerRef(tiddler) === getMatches(filter, [getTiddlerRef(tiddler)])[0];\n};\n\n/**\n *\n * @param {Tiddler} tiddler\n * @param {boolean} isBlock\n */\nvar getTranscludeNode = exports.getTranscludeNode = function getTranscludeNode(tiddler, isBlock) {\n  return {\n    type: 'transclude',\n    attributes: {\n      tiddler: {\n        type: 'string',\n        value: getTiddlerRef(tiddler) } },\n    children: [],\n    isBlock: !!isBlock\n  };\n};\n\n/**\n *\n * @param {Tiddler} tiddler\n */\nvar getTiddlerNode = exports.getTiddlerNode = function getTiddlerNode(tiddler) {\n  return {\n    type: 'tiddler',\n    attributes: {\n      tiddler: {\n        type: 'string', value: getTiddlerRef(tiddler) } },\n    children: []\n  };\n};\n\n/**\n *\n * @param type\n * @param className\n * @param text\n */\nvar getElementNode = exports.getElementNode = function getElementNode(type, className, text) {\n  return {\n    type: 'element',\n    tag: type,\n    attributes: {\n      class: {\n        type: 'string',\n        value: className } },\n    children: text ? [{ type: 'text', text: text }] : []\n  };\n};\n\n/**\n *\n * @param {Widget} widget\n * @param {string} name\n * @param {Tiddler} tiddler\n * @return {*}\n */\nvar registerTransclude = exports.registerTransclude = function registerTransclude(widget, name, tiddler) {\n\n  // if an instance exists, remove it\n  basicUtils.removeArrayElement(widget.children, widget[name]);\n\n  widget[name] = widget.makeChildWidget(getTranscludeNode(tiddler, true));\n  widget.children.push(widget[name]);\n\n  return widget[name];\n};\n\n/**\n * This function uses the tw-notification mechanism to display a\n * temporary message.\n *\n * @see https://github.com/Jermolene/TiddlyWiki5/blob/master/core/modules/utils/dom/notifier.js\n * @param {string} message - A short message to display.\n */\nvar notify = exports.notify = function notify(message) {\n\n  // @todo add to environment\n  var notifyTiddlerRef = '$:/temp/tiddlymap/notify';\n\n  $tw.wiki.addTiddler(new $tw.Tiddler({\n    title: notifyTiddlerRef,\n    text: message\n  }));\n\n  $tw.notifier.display(notifyTiddlerRef);\n};\n\n/**\n * The function allows to detect whether a widget is displayed\n * in preview or not.\n */\nvar isPreviewed = exports.isPreviewed = function isPreviewed(widget) {\n  if (!widget) {\n    return false;\n  }\n\n  // TODO: in the wiki utils we should not know about TiddlyMap domNode property!\n  if (widget.domNode.isTiddlyWikiFakeDom) {\n    return true;\n  }\n\n  if (widget.getVariable('tv-tiddler-preview')) {\n    return true;\n  } else {\n    // fallback for < v5.1.9\n    var cls = 'tc-tiddler-preview-preview';\n    // TODO: in the wiki utils we should not know about TiddlyMap domNode property!\n    return !!basicUtils.getAncestorWithClass(widget.parentDomNode, cls);\n  }\n};\n\n/**\n * Parse json from field or return default value on error.\n *\n * @param {Tiddler} tiddler - The tiddler containing the json.\n * @param {string} field - The field with the json data.\n * @param {Object} [data] - An optional default value.\n * @return {*} Either the parsed data or the default data.\n */\nvar parseFieldData = exports.parseFieldData = function parseFieldData(tiddler) {\n  var field = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'text';\n  var data = arguments[2];\n\n\n  var tObj = getTiddler(tiddler);\n\n  if (!tObj) {\n    return data;\n  }\n\n  return basicUtils.parseJSON(tObj.fields[field], data);\n};\n\n/**\n * Serialize json data and store it in a tiddler's field.\n *\n * @param {Tiddler} tiddler - The tiddler to store the json in.\n * @param {string} field - The field that will store the json.\n * @param {Object} data - The json data.\n * @param {int} [indent = 0] - the indentation\n */\nvar writeFieldData = exports.writeFieldData = function writeFieldData(tiddler, field, data, indent) {\n\n  if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {\n    return;\n  }\n\n  indent = parseInt(indent);\n  indent = indent > 0 && field === 'text' ? indent : 0;\n\n  setField(tiddler, field, JSON.stringify(data, null, indent));\n};\n\n/**\n * Clone a tiddler and give it another title.\n * This means the tiddlers are equal except from their titles.\n */\nvar clone = exports.clone = function clone(src, dest) {\n\n  setField(src, 'title', dest);\n};\n\n/**\n * Set the value of a data tiddler entry (index) to a given value\n */\nvar setEntry = exports.setEntry = function setEntry(tiddler, prop, value) {\n\n  $tw.wiki.setText(getTiddlerRef(tiddler), null, prop, value);\n};\n\n/**\n * Get the value of a data tiddler entry (index)\n */\nvar getEntry = exports.getEntry = function getEntry(tiddler, prop, defValue) {\n\n  var data = $tw.wiki.getTiddlerData(getTiddlerRef(tiddler), {});\n  return data[prop] == null ? defValue : data[prop];\n};\n\n//~ utils.getNestedProperty = function(obj, propPath) {\n//~\n//~ propPath = propPath.split(\".\");\n//~ for (var i = propPath.length; i--;) {\n//~ if (obj !== null && typeof obj === \"object\") {\n//~ obj = obj[propPath[i]];\n//~ }\n//~\n//~ };\n\n/**\n * Compare versions.\n * @return {boolean} Unlike `$tw.utils.checkVersions`, this function\n * only returns true if the left argument is greater than the right\n * argument.\n */\nvar isLeftVersionGreater = exports.isLeftVersionGreater = function isLeftVersionGreater(v1, v2) {\n  return v1 !== v2 && $tw.utils.checkVersions(v1, v2);\n};\n\n/**\n *\n * @param tiddler\n * @param defValue\n */\nvar getText = exports.getText = function getText(tiddler, defValue) {\n  return getField(tiddler, 'text', defValue);\n};\n\n/**\n *\n * @param tiddler\n * @param value\n */\nvar setText = exports.setText = function setText(tiddler, value) {\n\n  setField(tiddler, 'text', value);\n};\n\n/**\n * Checks whether a tiddler is a draft or not.\n *\n * @param {Tiddler} tiddler - The tiddler to check on.\n */\nvar isDraft = exports.isDraft = function isDraft(tiddler) {\n\n  var tObj = getTiddler(tiddler);\n  return tObj && tObj.isDraft();\n};\n\n/**\n * Get a tiddler's text or otherwise return a default text.\n */\nvar isSystemOrDraft = exports.isSystemOrDraft = function isSystemOrDraft(tiddler) {\n  return $tw.wiki.isSystemTiddler(getTiddlerRef(tiddler)) || isDraft(tiddler);\n};\n\n/**\n * Function to merge an array of tiddlers into a single tiddler.\n *\n * @param {Array<TiddlerReference|Tiddler>} tiddlers - The\n *     tiddlers to merge.\n * @param {string} [title=null] - The title where the result is\n *     written to. If not specified, the first array item is used\n *     as output title.\n */\nvar getMergedTiddlers = exports.getMergedTiddlers = function getMergedTiddlers(tiddlers, title) {\n\n  if (!Array.isArray(tiddlers)) {\n    return;\n  }\n\n  // turn all array elements into tiddler objects\n  for (var i = tiddlers.length; i--;) {\n    tiddlers[i] = getTiddler(tiddlers[i]);\n  }\n\n  if (!tiddlers.length) {\n    return;\n  }\n\n  tiddlers.push({ title: title || tiddlers[0].fields.title }, $tw.wiki.getModificationFields(), $tw.wiki.getCreationFields());\n\n  // add context for `apply()` function\n  tiddlers.unshift(null);\n\n  return new (Function.prototype.bind.apply($tw.Tiddler, tiddlers))();\n};\n\n/**\n * Depth first search\n */\nvar getChildWidgetByProperty = exports.getChildWidgetByProperty = function getChildWidgetByProperty(widget, prop, val) {\n\n  var children = widget.children;\n  for (var i = children.length; i--;) {\n    var child = children[i];\n    if (child[prop] === val) {\n      return child;\n    } else {\n      child = getChildWidgetByProperty(child, prop, val);\n      if (child) {\n        return child;\n      }\n    }\n  }\n};\n\n/**\n * Register listeners to widget using a hashmap.\n *\n * @param {Hashmap<Key, Function>} listeners - The listeners to attach.\n * @param {Widget} widget - the widget to attach the listeners to.\n * @param {Object} context - The context to bind the listeners to.\n */\nvar addTWlisteners = exports.addTWlisteners = function addTWlisteners(listeners, widget, context) {\n\n  for (var id in listeners) {\n    widget.addEventListener(id, listeners[id].bind(context));\n  }\n};\n\n/**\n * Renames all tiddler titles that are prefixed with `oldPrefix`\n * into titles that are prefixed with `newPrefix` by replacing\n * `oldPrefix` with `newPrefix`.\n *\n * The force option somewhat ensures atomicity.\n *\n * @param {string} oldPrefix - Moves all tiddlers with this prefix.\n * @param {string} newPrefix - All tiddlers moved tiddlers will\n *     receive this new prefix.\n * @param {boolean} [isForce=false] - If a new title would override\n *     an existing title, and `force` is not set, then nothing will\n *     happen and undefined is returned by the function.\n * @param {boolean} [isDelete=true] - True, if the tiddlers with the\n *     old prefix should be deleted or false, if they should be kept.\n * @returns {Object<string, string>} - A hashmap that maps the old\n *     and the new path.\n */\nvar mv = exports.mv = function mv(oldPrefix, newPrefix, isForce, isDelete) {\n\n  if (oldPrefix === newPrefix || !oldPrefix || !newPrefix) {\n    return;\n  }\n\n  isForce = typeof isForce === 'boolean' ? isForce : false;\n  isDelete = typeof isDelete === 'boolean' ? isDelete : true;\n\n  // prepare\n  var targets = getTiddlersByPrefix(oldPrefix);\n  var fromToMapper = basicUtils.makeHashMap();\n\n  for (var i = targets.length; i--;) {\n\n    var oldTRef = targets[i];\n    var newTRef = oldTRef.replace(oldPrefix, newPrefix);\n    if ($tw.wiki.tiddlerExists(newTRef) && !isForce) {\n      return; // undefined\n    }\n    fromToMapper[oldTRef] = newTRef;\n  }\n\n  for (var _oldTRef in fromToMapper) {\n\n    setField(_oldTRef, 'title', fromToMapper[_oldTRef]);\n    if (isDelete) {\n      $tw.wiki.deleteTiddler(_oldTRef);\n    }\n  }\n\n  return fromToMapper;\n};\n\n/**\n * Clones all tiddler titles that are prefixed with `oldPrefix`\n * into titles that are instead prefixed with `newPrefix`.\n *\n * The force option somewhat ensures atomicity.\n *\n * @param {string} oldPrefix - Moves all tiddlers with this prefix.\n * @param {string} newPrefix - All tiddlers moved tiddlers will\n *     receive this new prefix.\n * @param {boolean} [isForce=false] - If a new title would override\n *     an existing title, and `force` is not set, then nothing will\n *     happen and undefined is returned by the function.\n * @returns {Object<string, string>} - A hashmap that maps the old\n *     and the new path.\n */\nvar cp = exports.cp = function cp(oldPrefix, newPrefix, isForce) {\n  return mv(oldPrefix, newPrefix, isForce, false);\n};\n\n/**\n * Delete all tiddlers with a given prefix.\n *\n * @param {string} prefix - The prefix\n */\nvar deleteByPrefix = exports.deleteByPrefix = function deleteByPrefix(prefix, tiddlers) {\n\n  if (!prefix) {\n    return;\n  }\n\n  tiddlers = tiddlers || $tw.wiki.allTitles();\n\n  var deletedTiddlers = [];\n  for (var i = tiddlers.length; i--;) {\n    if (basicUtils.startsWith(tiddlers[i], prefix)) {\n      $tw.wiki.deleteTiddler(tiddlers[i]);\n      deletedTiddlers.push(deletedTiddlers[i]);\n    }\n  }\n\n  return deletedTiddlers;\n};\n\n/**\n * Returns all tiddlers that possess a property with a certain value.\n *\n * @param {string} fieldName - The property name to look for.\n * @param {string} [value] - If provided, the field's value must\n *     equal this value in order to match.\n * @param {Hashmap} [options] - Further options.\n * @param {TiddlerCollection} [options.tiddlers=$tw.wiki.allTitles()] - A collection\n *     of tiddlers to perform the search on.\n * @param {boolean} [options.isIncludeDrafts=false] - True if drafts of the found\n *     tiddlers are also included in the result set.\n * @param {number} [options.limit] - A positive number delimiting the maximum\n *     number of results.\n *     tiddlers are also included in the result set.\n * @return {Hashmap.<TiddlerReference, Tiddler>} Result\n */\nvar getTiddlersWithField = exports.getTiddlersWithField = function getTiddlersWithField(fieldName, value) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\n  var tiddlers = options.tiddlers || $tw.wiki.allTitles();\n  var isIncludeDrafts = options.isIncludeDrafts === true;\n  var result = basicUtils.makeHashMap();\n  var keys = Object.keys(tiddlers);\n  var hasOwnProp = $tw.utils.hop;\n  var limit = options.limit || 0;\n\n  for (var i = keys.length; i--;) {\n\n    var tObj = getTiddler(tiddlers[keys[i]]);\n    var fields = tObj.fields;\n    if (hasOwnProp(fields, fieldName) && (!hasOwnProp(fields, 'draft.of') || isIncludeDrafts)) {\n      if (!value || fields[fieldName] === value) {\n        result[fields.title] = tObj;\n        if (--limit === 0) {\n          break;\n        }\n      }\n    }\n  }\n\n  return result;\n};\n\n/**\n *\n * @param name\n * @param value\n */\nvar getTiddlerWithField = exports.getTiddlerWithField = function getTiddlerWithField(name, value) {\n  return Object.keys(getTiddlersWithField(name, value, { limit: 1 }))[0];\n};\n\n/**\n * Iterates over all tiddlers in a given way and returns tiddlers\n * whose title matches the prefix string.\n *\n * @param {string} prefix - The prefix to match\n * @param {Hashmap} [options] - An options object.\n * @param {string} [options.iterator=\"each\"] - A tw store iterator\n *    function, e.g. \"eachShadow\" or \"ShadowPlusTiddlers\".\n * @param {boolean} [options.removePrefix= false] - Whether to remove\n *     the prefix or to leave it.\n * @return {Array<string>} The matches with or without the prefix.\n */\nvar getTiddlersByPrefix = exports.getTiddlersByPrefix = function getTiddlersByPrefix(prefix) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n  var removePrefix = options.removePrefix === true;\n  var result = [];\n  var iterator = $tw.wiki[options.iterator || 'each'];\n\n  iterator(function (tObj, tRef) {\n    if (basicUtils.startsWith(tRef, prefix)) {\n      result.push(removePrefix ? basicUtils.getWithoutPrefix(tRef, prefix) : tRef);\n    }\n  });\n\n  return result;\n};\n\n/**\n * Advanced addTiddler method.\n *\n * It adds timestamps and only adds the tiddler if it doesn't exist\n * yet or the force option is used.\n *\n * This method is guarded against\n * https://github.com/Jermolene/TiddlyWiki5/issues/2025\n */\nvar addTiddler = exports.addTiddler = function addTiddler(tiddler, isForce) {\n\n  var tObj = getTiddler(tiddler);\n\n  if (!isForce && tObj) {\n    return tObj;\n  }\n\n  tObj = new $tw.Tiddler({\n    title: tiddler,\n    text: ''\n  }, $tw.wiki.getModificationFields(), $tw.wiki.getCreationFields());\n\n  $tw.wiki.addTiddler(tObj);\n\n  return tObj;\n};\n\nvar touch = exports.touch = function touch(tRef) {\n  setField(tRef, 'modified', new Date());\n};\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/lib/utils/wiki.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/macro/tmap": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/macro/tmap",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.params = exports.name = exports.run = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; // @preserve\n/*\\\ntitle: $:/plugins/felixhayashi/tiddlymap/js/macro/tmap\ntype: application/javascript\nmodule-type: macro\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nvar _EdgeType = require('$:/plugins/felixhayashi/tiddlymap/js/EdgeType');\n\nvar _EdgeType2 = _interopRequireDefault(_EdgeType);\n\nvar _ViewAbstraction = require('$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction');\n\nvar _ViewAbstraction2 = _interopRequireDefault(_ViewAbstraction);\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*** Code **********************************************************/\n\nvar name = 'tmap';\nvar params = getParamSlots(5);\n\n/**\n * @this MacroCallWidget\n * @return {string} the result of the operation or an empty string.\n * @private\n */\nfunction run() {\n\n  this.substVarRefs = this.substituteVariableReferences;\n\n  var fn = command[arguments[0]];\n  var result = null;\n\n  if (typeof fn === 'function') {\n    var args = Array.prototype.slice.call(arguments, 1);\n    result = fn.apply(this, args);\n  }\n\n  return typeof result === 'string' ? result : '';\n}\n\n/**\n * unfortunately tw forces us to specify params in advance so I\n * will reserve some argument slots here.\n * @private\n */\nfunction getParamSlots(maxArgs) {\n\n  var arr = [];\n  for (var i = 0; i < maxArgs; i++) {\n    arr.push({ name: 'arg' + i });\n  }\n\n  return arr;\n}\n\n/**\n * In connection with tiddlymap, this macro allows us to access\n * system information from within tiddlers as well as to execute\n * some util functions.\n *\n * Every command will be called with `this` pointing to the current\n * MacroCallWidget instance!\n *\n * @private\n */\nvar command = _utils2.default.makeHashMap();\n\n/**\n * Returns the basename of the string\n *\n * @see {@link utils.basename}\n */\ncommand.basename = function (separator) {\n\n  var str = this.getVariable('currentTiddler');\n  return _utils2.default.getBasename(str, separator);\n};\n\n/**\n * TW messes with svg urls so we always use base64 encoding when\n * a data uri is requested as macro call\n */\ncommand.datauri = function (tiddler, type) {\n\n  return _utils2.default.getDataUri(tiddler, type, true);\n};\n\ncommand.testJSON = function (fieldName) {\n\n  var tObj = $tw.wiki.getTiddler(this.getVariable('currentTiddler'));\n\n  try {\n    JSON.parse(tObj.fields[fieldName]);\n    return 'valid';\n  } catch (SyntaxError) {\n    return 'malformed';\n  }\n};\n\ncommand.splitAndSelect = function (separator, index) {\n\n  var str = this.getVariable('currentTiddler');\n  var result = str.split(separator)[index];\n\n  return result != null ? result : str;\n};\n\ncommand.concat = function () {\n\n  var str = '';\n  for (var i = 1, l = arguments.length; i < l; i++) {\n    str += arguments[i];\n  }\n  return str;\n};\n\ncommand.uuid = function () {\n\n  return _utils2.default.genUUID();\n};\n\ncommand.regRepl = function () {\n\n  var oldStr = this.substVarRefs(arguments[0]);\n  var regStr = arguments[1];\n  var newStr = this.substVarRefs(arguments[2]);\n  var regFlags = this.substVarRefs(arguments[4]);\n\n  return oldStr.replace(new RegExp(regStr, regFlags), newStr);\n};\n\ncommand.halfOfString = function () {\n\n  var str = this.substVarRefs(arguments[0]);\n\n  if (!str) {\n    return '';\n  }\n\n  return str.substr(0, Math.ceil(str.length / 2));\n};\n\ncommand.isETyVisible = function (view, userInput) {\n\n  view = new _ViewAbstraction2.default(view);\n\n  var id = command.getETyId.call(this, view, userInput);\n\n  return '' + view.isEdgeTypeVisible(id);\n};\n\ncommand.getETyId = function (view, userInput) {\n\n  view = new _ViewAbstraction2.default(view);\n\n  var type = _EdgeType2.default.getInstance(userInput || this.getVariable('currentTiddler'));\n\n  if (!type.namespace) {\n    var _EdgeType$getIdParts = _EdgeType2.default.getIdParts(type.id),\n        marker = _EdgeType$getIdParts.marker,\n        _name = _EdgeType$getIdParts.name;\n\n    var namespace = view.getConfig('edge_type_namespace');\n\n    type = _EdgeType2.default.getInstance(_EdgeType2.default.getId(marker, namespace, _name));\n  }\n\n  return type.id;\n};\n\ncommand.scale = function () {\n\n  var str = '';\n  for (var i = 1, l = parseInt(arguments[0]); i < l; i++) {\n    str += '[[' + i + ']]';\n  }\n  return str;\n};\n\ncommand.mergeFields = function () {\n\n  var tObj = _utils2.default.getTiddler(arguments[0]);\n  var prefix = arguments[1];\n  var separator = arguments[2] || ' ';\n\n  if (!tObj) return;\n\n  var fields = _utils2.default.getPropertiesByPrefix(tObj.fields, prefix);\n  var str = '';\n  for (var name in fields) {\n\n    if (typeof fields[name] === 'string') {\n\n      str += fields[name] + separator;\n    }\n  }\n  return str;\n};\n\ncommand.option = function (path, unit) {\n\n  if (typeof $tm == \"undefined\") {\n    // this macro is referenced from css which means we cannot\n    // expect $tm to exist, e.g when rendering static css\n    // @see https://github.com/felixhayashi/TW5-TiddlyMap/issues/257#issuecomment-427343226\n    return '';\n  }\n\n  var prop = $tm;\n  var propertyPath = path.split('.');\n\n  for (var i = 0; i < propertyPath.length; i++) {\n    if ((typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) == 'object' && prop[propertyPath[i]]) {\n      prop = prop[propertyPath[i]];\n    }\n  }\n\n  // TODO: ugly, use regex\n  if (unit && typeof prop === 'string' && _utils2.default.hasSubString(unit) && prop.lastIndexOf(unit) + unit.length === prop.length) {\n    prop = prop + unit;\n  }\n\n  return prop;\n};\n\n/*** Exports *******************************************************/\n\nexports.run = run;\nexports.name = name;\nexports.params = params;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/macro/MapMacro.js.map\n",
            "type": "application/javascript",
            "module-type": "macro"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/Adapter": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/Adapter",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/Adapter\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nvar _ViewAbstraction = require('$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction');\n\nvar _ViewAbstraction2 = _interopRequireDefault(_ViewAbstraction);\n\nvar _EdgeType = require('$:/plugins/felixhayashi/tiddlymap/js/EdgeType');\n\nvar _EdgeType2 = _interopRequireDefault(_EdgeType);\n\nvar _NodeType = require('$:/plugins/felixhayashi/tiddlymap/js/NodeType');\n\nvar _NodeType2 = _interopRequireDefault(_NodeType);\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _Edge = require('$:/plugins/felixhayashi/tiddlymap/js/Edge');\n\nvar _Edge2 = _interopRequireDefault(_Edge);\n\nvar _vis = require('$:/plugins/felixhayashi/vis/vis.js');\n\nvar _vis2 = _interopRequireDefault(_vis);\n\nvar _environment = require('$:/plugins/felixhayashi/tiddlymap/js/lib/environment');\n\nvar env = _interopRequireWildcard(_environment);\n\nvar _contrastcolour = require('$:/core/modules/macros/contrastcolour.js');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/***************************** CODE ********************************/\n\n/**\n * This library acts as an abstraction layer above the tiddlywiki\n * system. All the provided methods give the api-user the chance\n * to interact with tiddlywiki as if it was a simple graph database.\n *\n * Everything that is related to retrieving or inserting nodes and\n * edges is handled by the adapter class.\n *\n * You don't need to create your own instance of this class.\n * The adapter service may be accessed from anywhere using\n * `$tm.apapter`.\n *\n * @constructor\n */\nvar Adapter = function () {\n\n  /**\n   * @param {Tracker} tracker\n   * @param {EdgeTypeSubscriberRegistry} edgeTypeSubscriberRegistry\n   */\n  function Adapter(tracker, edgeTypeSubscriberRegistry) {\n    _classCallCheck(this, Adapter);\n\n    this.getTiddlerById = tracker.getTiddlerById.bind(tracker);\n    this.getId = tracker.getIdByTiddler.bind(tracker);\n    this.assignId = tracker.assignId.bind(tracker);\n\n    this.edgeTypeSubscriberRegistry = edgeTypeSubscriberRegistry;\n\n    this.indeces = $tm.indeces;\n    this.wiki = $tw.wiki;\n\n    this.visShapesWithTextInside = _utils2.default.getLookupTable(['ellipse', 'circle', 'database', 'box', 'text']);\n  }\n\n  /**\n   * This function will delete the specified edge object from the system.\n   *\n   * @param {Edge} edge - The edge to be deleted. The edge necessarily\n   *     needs to possess an `id` and a `from` property.\n   * @return {Edge} The deleted edge is returned.\n   */\n\n\n  _createClass(Adapter, [{\n    key: 'deleteEdge',\n    value: function deleteEdge(edge) {\n\n      return this._processEdge(edge, 'delete');\n    }\n\n    /**\n     * Persists an edge by storing the vector (from, to, type).\n     *\n     * @param {Edge} edge - The edge to be saved. The edge necessarily\n     *     needs to possess a `to` and a `from` property.\n     * @return {Edge} The newly inserted edge.\n     */\n\n  }, {\n    key: 'insertEdge',\n    value: function insertEdge(edge) {\n\n      return this._processEdge(edge, 'insert');\n    }\n\n    /**\n     * Removes multiple edges from several stores.\n     *\n     * @param {EdgeCollection} edges - The edges to be deleted.\n     */\n\n  }, {\n    key: 'deleteEdges',\n    value: function deleteEdges(edges) {\n\n      edges = _utils2.default.convert(edges, 'array');\n      for (var i = edges.length; i--;) {\n        this.deleteEdge(edges[i]);\n      }\n    }\n\n    /**\n     * Private function to handle the insertion or deletion of an edge.\n     * It prepares the process according to the action type and delegates\n     * the task to more specific functions.\n     *\n     * @private\n     * @return {Edge} The processed edge.\n     */\n\n  }, {\n    key: '_processEdge',\n    value: function _processEdge(edge, action) {\n\n      $tm.logger('debug', 'Edge', action, edge);\n\n      // get from-node and corresponding tiddler\n      var fromTRef = this.getTiddlerById(edge.from);\n\n      if (!fromTRef || !_utils2.default.tiddlerExists(fromTRef)) {\n        return;\n      }\n\n      var tObj = _utils2.default.getTiddler(fromTRef);\n      var type = this.indeces.allETy[edge.type] || _EdgeType2.default.getInstance(edge.type);\n      var handlers = this.edgeTypeSubscriberRegistry.getAllForType(type);\n      var fn = action + 'Edge';\n\n      for (var i = handlers.length; i--;) {\n        handlers[i][fn](tObj, edge, type);\n      }\n\n      // if type didn't exist yet, create it\n      if (action === 'insert' && !type.exists()) {\n        type.save();\n      }\n\n      return edge;\n    }\n\n    /**\n     * This function will return an adjacency list for the nodes\n     * present in the current system. The list may be restricted by\n     * optional filters.\n     *\n     * @param {string} [groupBy='to'] - Specifies by which property the\n     *     adjacency list is indexed. May be either 'from' or 'to'.\n     * @param {Hashmap} [opts] - An optional options object.\n     * @param {Hashmap} [opts.typeWL] - A whitelist lookup-table\n     *    that restricts which edge-types are included.\n     * @param {Hashmap} [opts.edges] - A set of edges on which basis\n     *     the adjacency list is build. If not provided,\n     *     all edges in the system are considered.\n     * @return {Object<Id, Array<Edge>>} For each key (a node id) an\n     *     array of edges pointing 'from' (or 'to'; depends on `groupBy`)\n     *     is supplied as value.\n     */\n\n  }, {\n    key: 'getAdjacencyList',\n    value: function getAdjacencyList(groupBy) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n      $tm.start('Creating adjacency list');\n\n      if (!opts.edges) {\n        var tRefs = _utils2.default.getMatches(env.selector.allPotentialNodes);\n        opts.edges = this.getEdgesForSet(tRefs, opts.toWL, opts.typeWL);\n      }\n\n      var adjList = _utils2.default.groupByProperty(opts.edges, groupBy || 'to');\n\n      $tm.stop('Creating adjacency list');\n\n      return adjList;\n    }\n\n    /**\n     * This function will return all neighbours of a graph denoted by\n     * a set of tiddlers.\n     *\n     * @todo parts of this code may be outsourced into a function to\n     * prevent repeating code.\n     *\n     * @param {Array<TiddlerReference>} matches - The original set that\n     *     defines the starting point for the neighbourhood discovery\n     * @param {Hashmap} [opts] - An optional options object.\n     * @param {Hashmap} [opts.typeWL] - A whitelist lookup-table\n     *    that restricts which edges are travelled to reach a neighbour.\n     * @param {Hashmap} [opts.edges] - An initial set of edges that is\n     *    used in the first step to reach immediate neighbours, if no\n     *    set of edges is specified, all exsisting edges will be considered.\n     * @param {number} [opts.steps] - An integer value that specifies\n     *    the scope of the neighbourhood. A node is considered a neighbour\n     *    if it can be reached within the given number of steps starting\n     *    from original set of tiddlers returned by the node filter.\n     * @param {Hashmap} [opts.addProperties] - a hashmap\n     *     containing properties to be added to each node.\n     *     For example:\n     *     {\n     *       group: 'g1',\n     *       color: 'red'\n     *     }\n     * @return {Object} An object of the form:\n     *     {\n     *       nodes: { *all neighbouring nodes* },\n     *       edges: { *all edges connected to neighbours* },\n     *     }\n     */\n\n  }, {\n    key: 'getNeighbours',\n    value: function getNeighbours(matches) {\n      var _this = this;\n\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n      $tm.start('Get neighbours');\n\n      var addProperties = opts.addProperties,\n          toWL = opts.toWL,\n          typeWL = opts.typeWL,\n          steps = opts.steps;\n      var allETy = this.indeces.allETy;\n\n      // index of all tiddlers have already are been visited, either by\n      // having been included in the original set, or by having been\n      // recorded as neighbour during the discovery.\n\n      var visited = _utils2.default.getArrayValuesAsHashmapKeys(matches);\n      var view = _ViewAbstraction2.default.exists(opts.view) ? new _ViewAbstraction2.default(opts.view) : null;\n      var allEdgesLeadingToNeighbours = _utils2.default.makeHashMap();\n      var allNeighbours = _utils2.default.makeHashMap();\n      var maxSteps = parseInt(steps) > 0 ? steps : 1;\n      var direction = opts.direction || view && view.getConfig('neighbourhood_directions');\n      var isWalkBoth = !direction || direction === 'both';\n      var isWalkIn = isWalkBoth || direction === 'in';\n      var isWalkOut = isWalkBoth || direction === 'out';\n\n      // in order to apply the node-filter also to neighbours we need to make it\n      // include all tiddlers in the filter's source (e.g. a tiddler and a few neighbours)\n      // and then apply the filter – which now has the chance to take away tiddlers\n      // a few filters from the set\n      var neighFilter = view && '[all[]] ' + view.getNodeFilter('raw');\n\n      // adjacency receives whitelists through opts\n      var adjList = this.getAdjacencyList('to', opts);\n\n      var addAsNeighbour = function addAsNeighbour(edge, role, neighboursOfThisStep) {\n        allEdgesLeadingToNeighbours[edge.id] = edge;\n        var tRef = _this.getTiddlerById(edge[role]);\n\n        if (view && _utils2.default.isTrue($tm.config.sys.nodeFilterNeighbours) && !_utils2.default.isMatch(tRef, neighFilter)) {\n          return;\n        }\n\n        if (!visited[tRef]) {\n          visited[tRef] = true;\n          var node = _this.makeNode(tRef, addProperties);\n          if (node) {\n            // saveguard against obsolete edges or other problems\n            // record node\n            allNeighbours[node.id] = node;\n            neighboursOfThisStep.push(tRef);\n          }\n        }\n      };\n\n      // needed later\n      var step = void 0;\n\n      // loop if still steps to be taken and we have a non-empty starting set\n      for (step = 0; step < maxSteps && matches.length; step++) {\n\n        // neighbours that are discovered in the current step;\n        // starting off from the current set of matches;\n        var neighboursOfThisStep = [];\n\n        // loop over all nodes in the original set\n        for (var i = matches.length; i--;) {\n\n          if (_utils2.default.isSystemOrDraft(matches[i])) {\n            // = this might happen if the user manually created edges\n            // that link to a system/draft tiddler or if the original\n            // set contained system/draft tiddlers.\n            continue;\n          }\n\n          // get all outgoing edges\n          // = edges originating from the starting set and point outwards\n          var outgoing = this.getEdges(matches[i], toWL, typeWL);\n          for (var id in outgoing) {\n\n            var t = allETy[outgoing[id].type];\n            if (isWalkBoth || isWalkOut && t.toArrow || isWalkIn && t.invertedArrow) {\n\n              addAsNeighbour(outgoing[id], 'to', neighboursOfThisStep);\n            }\n          }\n\n          // get all incoming edges\n          // = edges originating from outside pointing to the starting set\n          var incoming = adjList[this.getId(matches[i])];\n          if (!incoming) {\n            continue;\n          }\n\n          for (var j = incoming.length; j--;) {\n            var _t = allETy[incoming[j].type];\n            if (isWalkBoth || isWalkIn && _t.toArrow || isWalkOut && _t.invertedArrow) {\n              addAsNeighbour(incoming[j], 'from', neighboursOfThisStep);\n            }\n          }\n        }\n\n        // the current set of newly discovered neighbours forms the\n        // starting point for the next discovery\n        matches = neighboursOfThisStep;\n      }\n\n      var neighbourhood = {\n        nodes: allNeighbours,\n        edges: allEdgesLeadingToNeighbours\n      };\n\n      $tm.logger('debug', 'Retrieved neighbourhood', neighbourhood, 'steps', step);\n\n      $tm.stop('Get neighbours');\n\n      return neighbourhood;\n    }\n\n    /**\n     * This function will assemble a graph object based on the supplied\n     * node and edge filters. Optionally, a neighbourhood may be\n     * merged into the graph neighbourhood.\n     *\n     * @param {string|ViewAbstraction} [view] - The view in which\n     *     the graph will be displayed.\n     * @param {string|ViewAbstraction} [filter] - If supplied,\n     *     this will act as node filter that defines which nodes\n     *     are to be displayed in the graph; a possible view node filter\n     *     would be ignored.\n     * @param {Hashmap} [edgeTypeWL] - A whitelist lookup-table\n     *     that restricts which edges are travelled to reach a neighbour.\n     * @param {number} [neighbourhoodScope] - An integer value that\n     *     specifies the scope of the neighbourhood in steps.\n     *     See {@link Adapter#getNeighbours}\n     * @return {Object} An object of the form:\n     *     {\n     *       nodes: { *all nodes in the graph* },\n     *       edges: { *all edges in the graph* },\n     *     }\n     *     Neighbours will be receive the 'tmap:neighbour' type.\n     */\n\n  }, {\n    key: 'getGraph',\n    value: function getGraph() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          view = _ref.view,\n          filter = _ref.filter,\n          edgeTypeWL = _ref.edgeTypeWL,\n          neighbourhoodScope = _ref.neighbourhoodScope;\n\n      $tm.start('Assembling Graph');\n\n      view = _ViewAbstraction2.default.exists(view) ? new _ViewAbstraction2.default(view) : null;\n      var matches = _utils2.default.getMatches(filter || view && view.getNodeFilter('compiled'));\n      var neighScope = parseInt(neighbourhoodScope || view && view.getConfig('neighbourhood_scope'));\n      var typeWL = edgeTypeWL || view && view.getEdgeTypeFilter('whitelist');\n      var toWL = _utils2.default.getArrayValuesAsHashmapKeys(matches);\n\n      var graph = {\n        edges: this.getEdgesForSet(matches, toWL, typeWL),\n        nodes: this.selectNodesByReferences(matches, {\n          view: view,\n          outputType: 'hashmap'\n        })\n      };\n\n      if (neighScope) {\n        var neighbours = this.getNeighbours(matches, {\n          steps: neighScope,\n          view: view,\n          typeWL: typeWL,\n          addProperties: {\n            group: 'tmap:neighbour'\n          }\n        });\n\n        // add neighbours (nodes and edges) to graph\n        Object.assign(graph.nodes, neighbours.nodes);\n        Object.assign(graph.edges, neighbours.edges);\n\n        if (view && view.isEnabled('show_inter_neighbour_edges')) {\n          var nodeTRefs = this.getTiddlersByIds(neighbours.nodes);\n          // this time we need a whitelist based on the nodeTRefs\n          var _toWL = _utils2.default.getArrayValuesAsHashmapKeys(nodeTRefs);\n          Object.assign(graph.edges, this.getEdgesForSet(nodeTRefs, _toWL));\n        }\n      }\n\n      // this is pure maintainance!\n      removeObsoleteViewData(graph.nodes, view);\n\n      // add styles to nodes\n      this.attachStylesToNodes(graph.nodes, view);\n\n      $tm.stop('Assembling Graph');\n\n      $tm.logger('debug', 'Assembled graph:', graph);\n\n      return graph;\n    }\n\n    /**\n     * Returns all edges stored in a given tiddler. Any edge stored in a\n     * tiddler is orginally an outgoing edge. Depending on how the user\n     * changes the arrow head (by manipulating the Visjs edge-type style),\n     * the edge may change its orientation and become an incoming edge or\n     * bi-directional. Therefore, the edges retrieved may be incoming,\n     * outgoing or both!\n     *\n     * Returned edges may be of the following type:\n     *\n     * - Edges stored in the tiddler text (=links).\n     * - Edges stored in fields denoted by magic edge-types.\n     * - TiddlyMap edges stored in a json format\n     *\n     * @param {Tiddler} tiddler - A tiddler reference or object from\n     *     which to retrieve the edges.\n     * @param {Hashmap<TiddlerReference, boolean>} [toWL]\n     *     A hashmap on which basis it is decided, whether to include\n     *     an edge that leads to a certain tiddler in the result or not.\n     *     In this case, all edges stored in the tiddler are treated as\n     *     outgoing and the arrow head is ignored. If not specified,\n     *     all edges are included.\n     * @param {Hashmap<string, boolean>} [typeWL]\n     *     A hashmap on which basis it is decided, whether to include\n     *     an edge of a given type in the result or not. If not\n     *     specified, all edges are included.\n     */\n\n  }, {\n    key: 'getEdges',\n    value: function getEdges(tiddler, toWL, typeWL) {\n\n      var tObj = _utils2.default.getTiddler(tiddler);\n\n      if (!tObj || _utils2.default.isSystemOrDraft(tObj)) {\n        return;\n      }\n\n      var allETy = this.indeces.allETy;\n\n      var edges = _utils2.default.makeHashMap();\n      var eTySubscribers = this.edgeTypeSubscriberRegistry.getAll();\n\n      for (var i = 0, l = eTySubscribers.length; i < l; i++) {\n        Object.assign(edges, eTySubscribers[i].loadEdges(tObj, toWL, typeWL));\n      }\n\n      for (var id in edges) {\n\n        var edge = edges[id];\n\n        // check exists for historical reasons...\n        if (!edge.from || !edge.to) {\n          continue;\n        }\n\n        var type = allETy[edge.type] || _EdgeType2.default.getInstance(edge.type);\n        addStyleToEdge(edges[id], type);\n\n        edges[id] = edge;\n      }\n\n      return edges;\n    }\n\n    /**\n     * The method will return all outgoing edges for a subset of tiddlers.\n     *\n     * @param {Array<Tiddler>} tiddlers - The set of tiddlers to consider.\n     * @param toWL\n     * @param typeWL\n     * @return {Hashmap<Id, Edge>} An edge collection.\n     */\n\n  }, {\n    key: 'getEdgesForSet',\n    value: function getEdgesForSet(tiddlers, toWL, typeWL) {\n\n      var edges = _utils2.default.makeHashMap();\n      for (var i = tiddlers.length; i--;) {\n        Object.assign(edges, this.getEdges(tiddlers[i], toWL, typeWL));\n      }\n\n      return edges;\n    }\n\n    /**\n     * Select all edges of a given type.\n     *\n     * @param {string|EdgeType} type - Either the edge type id (name) or an EdgeType object.\n     */\n\n  }, {\n    key: 'selectEdgesByType',\n    value: function selectEdgesByType(type) {\n\n      var typeWL = _utils2.default.makeHashMap(_defineProperty({}, _EdgeType2.default.getInstance(type).id, true));\n\n      return this.getEdgesForSet(this.getAllPotentialNodes(), null, typeWL);\n    }\n\n    /**\n     *\n     * @return {*}\n     */\n\n  }, {\n    key: 'getAllPotentialNodes',\n    value: function getAllPotentialNodes() {\n\n      return _utils2.default.getMatches($tm.selector.allPotentialNodes);\n    }\n  }, {\n    key: '_processEdgesWithType',\n\n\n    /**\n     * Deletes or renames all edges of a given type.\n     *\n     * @param {string|EdgeType} type - Either the edge type id (name) or an EdgeType object.\n     * @param {('rename'|'delete')} [action='delete']\n     * @param {string} [newName]\n     */\n    value: function _processEdgesWithType(type, _ref2) {\n      var action = _ref2.action,\n          newName = _ref2.newName;\n\n\n      type = _EdgeType2.default.getInstance(type);\n\n      $tm.logger('debug', 'Processing edges', type, action);\n\n      // get edges\n      var edges = this.selectEdgesByType(type);\n\n      if (action === 'rename') {\n\n        // clone type first to prevent auto-creation\n        new _EdgeType2.default(newName, type).save();\n      }\n\n      for (var id in edges) {\n\n        this._processEdge(edges[id], 'delete');\n\n        if (action === 'rename') {\n          edges[id].type = newName;\n          this._processEdge(edges[id], 'insert');\n        }\n      }\n\n      // finally remove the old type\n      this.wiki.deleteTiddler(type.fullPath);\n    }\n\n    /**\n     * Returns a set of nodes that corresponds to a set of tiddlers.\n     *\n     * @param {TiddlerCollection} tiddlers - A collection of tiddlers.\n     * @param {Hashmap} [addProperties] - a hashmap\n     * @param {CollectionTypeString} [outputType='dataset'] - The result type.\n     *\n     * @return {NodeCollection} A collection of a type specified in the options.\n     */\n\n  }, {\n    key: 'selectNodesByReferences',\n    value: function selectNodesByReferences(tiddlers) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          addProperties = _ref3.addProperties,\n          outputType = _ref3.outputType;\n\n      var result = _utils2.default.makeHashMap();\n      var keys = Object.keys(tiddlers);\n\n      for (var i = keys.length; i--;) {\n\n        var node = this.makeNode(tiddlers[keys[i]], addProperties);\n        if (node) {\n          result[node.id] = node;\n        }\n      }\n\n      return _utils2.default.convert(result, outputType);\n    }\n\n    /**\n     * Retrieve nodes based on the a list of ids that corrspond to tiddlers\n     * id fields.\n     *\n     * @param {Array.<Id>|Hashmap.<Id, *>|vis.DataSet} nodeIds - The ids of the tiddlers\n     *     that represent the nodes.\n     * @param {Hashmap} [options] - See {@link Adapter#selectNodesByReferences}.\n     * @return {NodeCollection} A collection of a type specified in the options.\n     */\n\n  }, {\n    key: 'selectNodesByIds',\n    value: function selectNodesByIds(nodeIds, options) {\n\n      var tRefs = this.getTiddlersByIds(nodeIds);\n\n      return this.selectNodesByReferences(tRefs, options);\n    }\n\n    /**\n     * Select a single node by id.\n     *\n     * @param {Id} id - A node's id\n     * @param {Hashmap} [options]\n     *     Except from the outputType option, all options\n     *     are inherited from {@link Adapter#selectNodesByIds}.\n     * @return {Node|undefined} A node or nothing.\n     */\n\n  }, {\n    key: 'selectNodeById',\n    value: function selectNodeById(id, options) {\n\n      options = Object.assign({}, options, { outputType: 'hashmap' });\n      var result = this.selectNodesByIds([id], options);\n\n      return result[id];\n    }\n\n    /**\n     * Deletes a node type from the system.\n     * @param {NodeType|string} type - the node type id or the actual NodeType\n     */\n\n  }, {\n    key: 'removeNodeType',\n    value: function removeNodeType(type) {\n\n      type = _NodeType2.default.getInstance(type);\n      this.wiki.deleteTiddler(type.fullPath);\n    }\n\n    /**\n     * Gets a Node representation for a tiddler.\n     *\n     * @param {Tiddler} tiddler - the tiddler to represent as node\n     * @param {Object} protoNode - default node properties\n     *\n     * @return {Node|void}\n     */\n\n  }, {\n    key: 'makeNode',\n    value: function makeNode(tiddler, protoNode) {\n\n      var tObj = _utils2.default.getTiddler(tiddler);\n\n      if (!tObj || _utils2.default.isSystemOrDraft(tObj)) return;\n\n      // merge(!) so later node manipulations do not affect other nodes\n      var node = _utils2.default.merge({}, protoNode);\n\n      // note: assignId() will not assign an id if the tiddler already has one\n      node.id = this.assignId(tObj);\n\n      // backreference to tiddler;\n      // https://github.com/felixhayashi/TW5-TiddlyMap/issues/304\n      node.tRef = tObj.fields.title;\n\n      // add label\n      var label = tObj.fields[$tm.field.nodeLabel];\n      node.label = (label && $tm.field.nodeLabel !== 'title' ? this.wiki.renderText('text/plain', 'text/vnd-tiddlywiki', label) : tObj.fields.title).replace('\\\\n', '\\n');\n\n      return node;\n    }\n\n    /**\n     * Return node styles that are inherited from system styles or node types.\n     *\n     * @param nodes\n     * @return {Object<TiddlerReference, Object>}\n     */\n\n  }, {\n    key: 'getInheritedNodeStyles',\n    value: function getInheritedNodeStyles(nodes) {\n\n      var src = this.getTiddlersByIds(nodes);\n      var protoByTRef = {};\n      var glNTy = this.indeces.glNTy;\n\n      for (var i = glNTy.length; i--;) {\n        var type = glNTy[i];\n\n        var inheritors = [];\n        if (type.id === 'tmap:neighbour') {\n          // special case\n          for (var id in nodes) {\n\n            if (nodes[id].group === 'tmap:neighbour') {\n\n              inheritors.push(this.getTiddlerById(id));\n            }\n          }\n        } else {\n          inheritors = type.getInheritors(src);\n        }\n\n        for (var j = inheritors.length; j--;) {\n          var tRef = inheritors[j];\n          var proto = protoByTRef[tRef] = protoByTRef[tRef] || {};\n          proto.style = _utils2.default.merge(proto.style || {}, type.style);\n\n          // ATTENTION: only override proto icons when the type provides\n          // an icon since otherwise we might erase previously\n          // inherited icons.\n          if (type['fa-icon']) {\n            proto['fa-icon'] = type['fa-icon'];\n          } else if (type['tw-icon']) {\n            proto['tw-icon'] = type['tw-icon'];\n          }\n        }\n      }\n\n      return protoByTRef;\n    }\n\n    /**\n     * Adds styles to nodes.\n     *\n     * @param {Object<string, Node>} nodes\n     * @param {ViewAbstraction|string} view\n     */\n\n  }, {\n    key: 'attachStylesToNodes',\n    value: function attachStylesToNodes(nodes, view) {\n\n      view = _ViewAbstraction2.default.exists(view) ? new _ViewAbstraction2.default(view) : null;\n\n      var inheritedStyles = this.getInheritedNodeStyles(nodes);\n      var viewNodeData = view ? view.getNodeData() : _utils2.default.makeHashMap();\n      var isStaticMode = view && !view.isEnabled('physics_mode');\n\n      for (var id in nodes) {\n\n        var tRef = this.getTiddlerById(id);\n        var tObj = this.wiki.getTiddler(tRef);\n        var fields = tObj.fields;\n        var node = nodes[id];\n        var icon = void 0;\n\n        // == group styles ==\n\n        var inheritedStyle = inheritedStyles[tRef];\n\n        if (inheritedStyle) {\n\n          _utils2.default.merge(node, inheritedStyle.style);\n          icon = getIcon(inheritedStyle['fa-icon'], inheritedStyle['tw-icon']);\n        }\n\n        // == global node styles ==\n\n        // background color\n        if (fields.color) {\n          node.color = fields.color;\n        }\n\n        // global node style from vis editor\n        if (fields['tmap.style']) {\n          _utils2.default.merge(node, _utils2.default.parseJSON(fields['tmap.style']));\n        }\n\n        icon = getIcon(fields['tmap.fa-icon'], fields['icon']) || icon;\n\n        // == local node styles ==\n\n        // local node style and positions\n\n        var nodeData = viewNodeData[id];\n\n        if (nodeData) {\n\n          _utils2.default.merge(node, nodeData);\n          if (isStaticMode) {\n            // fix x if x-position is set; same for y\n            node.fixed = {\n              x: node.x != null,\n              y: node.y != null\n            };\n          }\n\n          icon = getIcon(nodeData['fa-icon'], nodeData['tw-icon']) || icon;\n        }\n\n        // == tweaks ==\n\n        var isColorObject = node.color !== null && _typeof(node.color) === 'object';\n        // color/border-color may be undefined\n        var color = isColorObject ? node.color.background : node.color;\n\n        node.color = {\n          background: color,\n          border: isColorObject ? node.color.border : undefined\n        };\n\n        // ATTENTION: this function needs to be called after color is assigned\n        addNodeIcon(node, icon);\n\n        // determine font color if not defined via a group- or node-style;\n        // in case of global and local default styles, the user is responsible\n        // him- or herself to adjust the font\n        node.font = node.font || {};\n\n        if (node.shape && !this.visShapesWithTextInside[node.shape]) {\n          node.font.color = 'black'; // force a black color\n        } else if (!node.font.color && color) {\n          node.font.color = (0, _contrastcolour.run)(color, color, 'black', 'white');\n        }\n\n        if (node.shape === 'icon' && _typeof(node.icon) === 'object') {\n          node.icon.color = color;\n        }\n      }\n\n      if (view) {\n        var _node = nodes[view.getConfig('central-topic')];\n        if (_node) {\n          _utils2.default.merge(_node, this.indeces.glNTyById['tmap:central-topic'].style);\n        }\n      }\n    }\n\n    /**\n     * This function will remove all tiddlers from the wiki that correspond\n     * to a node in the collection. Drafts are also removed. The default\n     * storylist is updated eventually.\n     * call deleteNode which does the following\n     * 1. get id using IdByT\n     * 2. remove id using adapter.deleteEdgesByTo(idByT[tRef])\n     * 3. remove from all indeces\n     *\n     * @see: https://github.com/Jermolene/TiddlyWiki5/issues/1550\n     *\n     * @param {Node|string} node.\n     */\n\n  }, {\n    key: 'deleteNode',\n    value: function deleteNode(node) {\n\n      if (!node) {\n        return;\n      }\n\n      var id = (typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' ? node.id : node;\n      var tRef = this.getTiddlerById(id);\n\n      // delete tiddler and remove it from the river; this will\n      // automatically remove the global node style and the outgoing edges\n\n      if (tRef) {\n        // checking for tRef is needed;\n        // see: https://github.com/Jermolene/TiddlyWiki5/issues/1919\n        _utils2.default.deleteTiddlers([tRef]);\n      }\n\n      // delete local node-data in views containing the node\n\n      var viewRefs = _utils2.default.getMatches(env.selector.allViews);\n      for (var i = viewRefs.length; i--;) {\n        var view = new _ViewAbstraction2.default(viewRefs[i]);\n        view.removeNode(id);\n      }\n\n      // remove obsolete connected edges\n\n      var neighbours = this.getNeighbours([tRef]);\n      this.deleteEdges(neighbours.edges);\n\n      // -------------------------------------------\n      // NEVER DELETE AN INDEX THAT ALREADY EXISTED!\n      // -------------------------------------------\n      // Some instances may have cached the index and get confused!\n      // It does not do harm to leave indeces as is since we do not\n      // iterate over them(!) and when a tiddler has the same title or\n      // id as a deleted tiddler, which is highly unlikely, then it will\n      // simply override the index, which is totally fine. The indeces\n      // are refreshed on every boot anyway so it is not a big deal.\n      //\n      // THEREFORE:\n      //\n      // DO NOT DO delete this.tById[id];\n      // DO NOT DO delete this.idByT[tRef];\n    }\n\n    /**\n     * Delete all nodes from the system.\n     *\n     * @param {string[]} ids ids\n     */\n\n  }, {\n    key: 'deleteNodes',\n    value: function deleteNodes(ids) {\n\n      for (var i = ids.length; i--;) {\n        this.deleteNode(ids[i]);\n      }\n    }\n\n    /**\n     * Create a new tiddler that gets a non-existant title and is opened\n     * for edit. If a view is registered, the fields of the tiddler match\n     * the current view. If arguments network and position are specified,\n     * the node is also inserted directly into the graph at the given\n     * position.\n     *\n     * @TODO: Description is obsolete!\n     *\n     * @param {object} node A node object to be inserted\n     * @param {ViewAbstraction|string} view - used to set positions and register the node to\n     * @param {Tiddler} protoTiddler\n     */\n\n  }, {\n    key: 'insertNode',\n    value: function insertNode() {\n      var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var view = arguments[1];\n      var protoTiddler = arguments[2];\n\n\n      // title might has changed after generateNewTitle()\n      node.label = this.wiki.generateNewTitle(node.label || _utils2.default.getRandomLabel());\n\n      // add to tiddler store\n      var tObj = new $tw.Tiddler({ text: '' }, // https://github.com/Jermolene/TiddlyWiki5/issues/2025\n      protoTiddler, {\n        title: node.label, // force title\n        'tmap.id': null // force empty id (generated later)\n      }, this.wiki.getModificationFields(), this.wiki.getCreationFields());\n\n      this.wiki.addTiddler(tObj);\n\n      node = this.makeNode(tObj, node);\n\n      if (_ViewAbstraction2.default.exists(view)) {\n        new _ViewAbstraction2.default(view).addNode(node);\n      }\n\n      return node;\n    }\n\n    /**\n     * Retrieve tiddlers based on the a list of corresponding ids.\n     *\n     * @param {Array.<Id>|Hashmap.<Id, *>|vis.DataSet} nodeIds - The ids.\n     * @return {Array<TiddlerReference>} The resulting tiddlers.\n     */\n\n  }, {\n    key: 'getTiddlersByIds',\n    value: function getTiddlersByIds(nodeIds) {\n\n      // transform into a hashmap with all values being true\n      if (Array.isArray(nodeIds)) {\n        nodeIds = _utils2.default.getArrayValuesAsHashmapKeys(nodeIds);\n      } else if (nodeIds instanceof _vis2.default.DataSet) {\n        nodeIds = _utils2.default.getLookupTable(nodeIds, 'id'); // use id field as key\n      }\n\n      var result = [];\n      for (var id in nodeIds) {\n        var tRef = this.getTiddlerById(id);\n        if (tRef) {\n          result.push(tRef);\n        }\n      }\n\n      return result;\n    }\n  }]);\n\n  return Adapter;\n}();\n\n/**** Helper *******************************************************/\n\n/**\n * Returns the short symbol identifier (`&#xf2bc;` → `f206`).\n *\n * @param str FontAwesome id\n * @return {string}\n */\n\n\nvar getFAdigits = function getFAdigits(str) {\n  return str.length === 4 ? str : str.substr(3, 4);\n};\n\n/**\n * Adds an icon to the specified node.\n *\n * @param {Node} node\n * @param {Object} icon\n */\nvar addNodeIcon = function addNodeIcon(node, icon) {\n\n  if (!icon) {\n    return;\n  }\n\n  // Font Awesome style\n\n  if (icon.fa) {\n\n    node.shape = 'icon';\n    node.icon = {\n      shape: 'icon',\n      face: 'FontAwesome',\n      color: node.color,\n      code: String.fromCharCode('0x' + getFAdigits(icon.fa))\n    };\n\n    if (node.size) {\n      node.icon.size = node.size;\n    }\n\n    return;\n  }\n\n  // TiddlyWiki stored icons\n\n  if (icon.tw) {\n\n    var imgTObj = _utils2.default.getTiddler(icon.tw);\n\n    if (!imgTObj) {\n      return;\n    }\n\n    if (imgTObj.fields['_canonical_uri']) {\n      // image is a url address\n\n      node.image = imgTObj.fields['_canonical_uri'];\n      node.shape = 'image';\n    } else if (imgTObj.fields.text) {\n\n      node.image = _utils2.default.getDataUri(imgTObj);\n      node.shape = 'image';\n    }\n  }\n};\n\n/**\n * Garbage collector for obsolete node data.\n *\n * @param {Object<string, Node>} nodes\n * @param {ViewAbstraction|string} view\n */\nvar removeObsoleteViewData = function removeObsoleteViewData(nodes, view) {\n\n  if (!_ViewAbstraction2.default.exists(view) || !nodes) {\n    return;\n  }\n\n  view = new _ViewAbstraction2.default(view);\n\n  var data = view.getNodeData();\n\n  var obsoleteDataItems = 0;\n  for (var id in data) {\n    if (nodes[id] === undefined && data[id] != null) {\n      // we only set this to undefined as deletion would\n      // slow down V8, however, this necessarily requires\n      // a safeguard agains recursion: data[id] != null\n\n      data[id] = undefined;\n      obsoleteDataItems++;\n    }\n  }\n\n  if (obsoleteDataItems) {\n    $tm.logger('debug', '[Cleanup]', 'Removed obsolete node data:', view.getLabel(), obsoleteDataItems);\n    view.saveNodeData(data);\n  }\n};\n\n/**\n * Sets up an edge object that is ready to be consumed by vis.\n *\n * @param {Edge} edge\n * @param {EdgeType} type\n */\nvar addStyleToEdge = function addStyleToEdge(edge, type) {\n\n  edge = Object.assign(edge, type.style);\n\n  if (_utils2.default.isTrue(type['show-label'], true)) {\n    edge.label = type.getLabel();\n  }\n};\n\nvar getIcon = function getIcon(faIcon, twIcon) {\n  return faIcon && { fa: faIcon } || twIcon && { tw: twIcon };\n};\n\n/*** Exports *******************************************************/\n\nexports.default = Adapter;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/services/Adapter.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/CallbackManager": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/CallbackManager",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/CallbackManager\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Makes it possible to register callbacks for tiddler changes.\n */\nvar CallbackManager = function () {\n  function CallbackManager() {\n    _classCallCheck(this, CallbackManager);\n\n    this.callbacks = _utils2.default.makeHashMap();\n    this.logger = $tm.logger;\n    this.wiki = $tw.wiki;\n  }\n\n  /**\n   * The callback mechanism allows to dynamically listen to tiddler\n   * changes without hardcoding a change-check for a tiddler name\n   * in the refresh function.\n   *\n   * @param {TiddlerReference} tRef - A tiddler whose change triggers\n   *     the callback.\n   * @param {function} callback - A function that is called when the\n   *     tiddler has changed.\n   * @param {boolean} [isDeleteOnCall=true] - True if to delete the\n   *     callback once it has been called, false otherwise.\n   */\n\n\n  _createClass(CallbackManager, [{\n    key: 'add',\n    value: function add(tRef, callback) {\n      var isDeleteOnCall = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n\n      this.logger('debug', 'A callback was registered for changes of \"' + tRef + '\"');\n      this.callbacks[tRef] = {\n        execute: callback,\n        isDeleteOnCall: isDeleteOnCall\n      };\n    }\n  }, {\n    key: 'remove',\n\n\n    /**\n     * Removes the callback from the list of tiddler callbacks.\n     */\n    value: function remove(refOrRefList) {\n\n      if (!refOrRefList) {\n        return;\n      }\n\n      if (typeof refOrRefList === 'string') {\n        refOrRefList = [refOrRefList];\n      }\n\n      for (var i = refOrRefList.length; i--;) {\n        var tRef = refOrRefList[i];\n        if (this.callbacks[tRef]) {\n          this.logger('debug', 'Deleting callback for \"' + tRef + '\"');\n          delete this.callbacks[tRef];\n        }\n      }\n    }\n  }, {\n    key: 'refresh',\n\n\n    /**\n     * this method has to be implemented at the top of the refresh method.\n     * It checks for changed tiddlers that have\n     * registered callbacks. If `deleteOnCall` was specified during\n     * registration of the callback, the callback will be deleted\n     * automatically.\n     */\n    value: function refresh(changedTiddlers) {\n\n      if (this.callbacks.length == 0) {\n        return;\n      }\n\n      for (var tRef in changedTiddlers) {\n\n        if (!this.callbacks[tRef]) {\n          continue;\n        }\n\n        if (this.wiki.getTiddler(tRef)) {\n\n          this.logger('debug', 'Executing a callback for: ' + tRef);\n          this.callbacks[tRef].execute(tRef);\n\n          // a continue prevents deleting the callback\n          if (!this.callbacks.isDeleteOnCall) {\n            continue;\n          }\n        }\n\n        this.remove(tRef);\n      }\n    }\n  }]);\n\n  return CallbackManager;\n}();\n\n/*** Exports *******************************************************/\n\nexports.default = CallbackManager;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/services/CallbackManager.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/startup/caretaker": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/startup/caretaker",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.startup = exports.synchronous = exports.before = exports.after = exports.platforms = exports.name = undefined;\n\nvar _rebuilders;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/startup/caretaker\ntype: application/javascript\nmodule-type: startup\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nvar _vis = require('$:/plugins/felixhayashi/tiddlymap/js/config/vis');\n\nvar _vis2 = _interopRequireDefault(_vis);\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _Fixer = require('$:/plugins/felixhayashi/tiddlymap/js/Fixer');\n\nvar _Fixer2 = _interopRequireDefault(_Fixer);\n\nvar _Adapter = require('$:/plugins/felixhayashi/tiddlymap/js/Adapter');\n\nvar _Adapter2 = _interopRequireDefault(_Adapter);\n\nvar _tracker = require('$:/plugins/felixhayashi/tiddlymap/js/services/tracker');\n\nvar _tracker2 = _interopRequireDefault(_tracker);\n\nvar _EdgeTypeSubscriberRegistry = require('$:/plugins/felixhayashi/tiddlymap/js/EdgeTypeSubscriberRegistry');\n\nvar _EdgeTypeSubscriberRegistry2 = _interopRequireDefault(_EdgeTypeSubscriberRegistry);\n\nvar _DialogManager = require('$:/plugins/felixhayashi/tiddlymap/js/DialogManager');\n\nvar _DialogManager2 = _interopRequireDefault(_DialogManager);\n\nvar _CallbackManager = require('$:/plugins/felixhayashi/tiddlymap/js/CallbackManager');\n\nvar _CallbackManager2 = _interopRequireDefault(_CallbackManager);\n\nvar _ViewAbstraction = require('$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction');\n\nvar _ViewAbstraction2 = _interopRequireDefault(_ViewAbstraction);\n\nvar _EdgeType = require('$:/plugins/felixhayashi/tiddlymap/js/EdgeType');\n\nvar _EdgeType2 = _interopRequireDefault(_EdgeType);\n\nvar _NodeType = require('$:/plugins/felixhayashi/tiddlymap/js/NodeType');\n\nvar _NodeType2 = _interopRequireDefault(_NodeType);\n\nvar _vis3 = require('$:/plugins/felixhayashi/vis/vis.js');\n\nvar _vis4 = _interopRequireDefault(_vis3);\n\nvar _environment = require('$:/plugins/felixhayashi/tiddlymap/js/lib/environment');\n\nvar env = _interopRequireWildcard(_environment);\n\nvar _URL = require('$:/plugins/felixhayashi/tiddlymap/js/URL');\n\nvar _URL2 = _interopRequireDefault(_URL);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/*** Code **********************************************************/\n\n/**\n * This module is responsible for registering a global namespace\n * under $tw and loading (and refreshing) the configuration and services.\n *\n * Attention: Careful with the order of the function calls in this\n * functions body!\n *\n */\nvar init = function init() {\n\n  window.$tm = _extends({}, env, { utils: _utils2.default, url: new _URL2.default(window.location.href) });\n\n  // cleanup previous session\n  cleanup();\n\n  registerPublicClasses($tm);\n\n  // build and integrate global options\n  updateGlobals($tm);\n\n  // register meta file (if not done yet)\n  createMetaFile($tm.logger);\n\n  // create indeces\n  var indeces = attachIndeces($tm);\n\n  // create services\n  var services = getInitializedServices(indeces);\n  Object.assign($tm, services);\n\n  // load defaults\n  loadDefaultView($tm.config.sys.defaultView);\n\n  // Run the fixer to update older wikis\n  services.fixer.fix();\n\n  // all graphs need to register here. @see routineWalk()\n  $tm.registry = [];\n  setInterval(routineCheck, 5000);\n\n  // AT THE VERY END: register change listener with the callback manager\n  registerChangeListener($tm.callbackManager);\n\n  // register DOM listeners\n  registerMousemoveListener();\n  registerClickListener();\n\n  // check for fullscreen directives\n  if ($tm.url.query['tmap-enlarged']) {\n    prepareFullscreenStart($tm.url);\n  }\n\n  // issue notification\n  $tm.logger('warn', 'TiddlyMap\\'s caretaker successfully started');\n};\n\n/**\n * Injects dependencies and registers services\n *\n * @param indeces\n * @return Object\n */\nvar getInitializedServices = function getInitializedServices(indeces) {\n\n  var tracker = new _tracker2.default(fixer);\n\n  // inject modules\n  var handler = $tw.modules.applyMethods('tmap.edgetypehandler');\n  var edgeTypeSubscriberRegistry = new _EdgeTypeSubscriberRegistry2.default(handler, indeces.allETy, tracker);\n\n  // attach the adapter object to the tiddlymap namespace\n  var adapter = new _Adapter2.default(tracker, edgeTypeSubscriberRegistry);\n\n  var callbackManager = new _CallbackManager2.default();\n  var dialogManager = new _DialogManager2.default(callbackManager);\n\n  var fixer = new _Fixer2.default(adapter, $tm.logger, indeces.glNTy);\n\n  return {\n    edgeTypeSubscriberRegistry: edgeTypeSubscriberRegistry,\n    tracker: tracker,\n    adapter: adapter,\n    callbackManager: callbackManager,\n    dialogManager: dialogManager,\n    fixer: fixer\n  };\n};\n\n/**\n * make classes available for console users\n */\nvar registerPublicClasses = function registerPublicClasses(parent) {\n  parent.keycharm = _vis4.default.keycharm;\n  parent.NodeType = _NodeType2.default;\n  parent.EdgeType = _EdgeType2.default;\n  parent.ViewAbstraction = _ViewAbstraction2.default;\n};\n\n/**\n * This function will append the global options to the tree. In case\n * this function is called again, only the option leafs are rebuild\n * so a process may safely store a reference to a branch of the option\n * tree as the reference doesn't change.\n *\n * ATTENTION: For the path options, no trailing or double slashes!\n * This is NOT unix where paths are normalized (// is not rewritten to /).\n *\n * @see\n *   - [TW5] Is there a designated place for TW plugins to store stuff in the dom?\n *     https://groups.google.com/forum/#!topic/tiddlywikidev/MZZ37XiVcvY\n * @param {object} parent The root where to insert the options into\n */\nvar attachOptions = function attachOptions(parent) {\n\n  var p = parent;\n\n  // default configurations mixed with user config\n  if (!p.config) p.config = _utils2.default.makeHashMap();\n\n  // Never modify the imported config objects; instead, merge them\n  // into a new object\n\n  // attention! it is a tw-data-tiddler!\n  p.config.sys = _utils2.default.merge(p.config.sys, _utils2.default.unflatten($tw.wiki.getTiddlerData(env.ref.sysUserConf)));\n\n  // CAREFUL: Never merge directly into the default vis config object\n  p.config.vis = _utils2.default.merge({}, _vis2.default, _utils2.default.parseFieldData(env.ref.visUserConf));\n\n  // a shortcut for fields property\n  if (!p.field) p.field = _utils2.default.makeHashMap();\n  $tw.utils.extend(p.field, p.config.sys.field);\n};\n\n/**\n * This function will cache/index some tiddler properties as javascript\n * objects for faster access.\n */\nvar attachIndeces = function attachIndeces(parent) {\n\n  $tm.start('Attaching Indeces');\n\n  parent.indeces = parent.indeces || {};\n\n  updateNodeTypesIndeces(parent.indeces);\n  updateEdgeTypesIndeces(parent.indeces);\n\n  $tm.stop('Attaching Indeces');\n\n  return parent.indeces;\n};\n\n/**\n * For faster access to node-type styles, we store all node-type\n * objects as indeces in a table.\n *\n * Types without a filter are not indexed since they are either\n * special types that TiddlyMap manually assignes (e.g. tmap:neighbour,\n * or tmap:selected).\n *\n * Indeces added to the indeces chain:\n * 1. glNTy – all global node types\n *\n * @param {Object} [parent] - The global indeces object indeces.\n *     If not stated, $tm.indeces is used.\n * @param {Array<TiddlerReference>} [allTiddlers] - The tiddlers to\n *     use as basis for this index. If not stated, all tiddlers in\n *     the wiki are used.\n */\nvar updateNodeTypesIndeces = function updateNodeTypesIndeces(parent) {\n\n  parent = parent || $tm.indeces;\n\n  var typePath = $tm.path.nodeTypes;\n  var glNTy = parent.glNTy = [];\n  var glNTyById = parent.glNTyById = _utils2.default.makeHashMap();\n\n  $tw.wiki.eachTiddlerPlusShadows(function (tObj, tRef) {\n    if (_utils2.default.startsWith(tRef, typePath)) {\n      var type = _NodeType2.default.getInstance(tRef);\n      glNTyById[type.id] = type;\n      glNTy.push(type);\n    }\n  });\n\n  glNTy.sort(function (a, b) {\n    return a.priority - b.priority;\n  });\n};\n\nvar updateEdgeTypesIndeces = function updateEdgeTypesIndeces(parent) {\n\n  parent = parent || $tm.indeces;\n\n  var typePath = $tm.path.edgeTypes;\n  var allETy = parent.allETy = _utils2.default.makeHashMap();\n\n  $tw.wiki.eachTiddlerPlusShadows(function (tObj, tRef) {\n\n    if (_utils2.default.startsWith(tRef, typePath)) {\n\n      var et = _EdgeType2.default.getInstance(tRef);\n      allETy[et.id] = et;\n    }\n  });\n\n  if ($tm.edgeTypeSubscriberRegistry) {\n    $tm.edgeTypeSubscriberRegistry.updateIndex(allETy);\n  }\n};\n\n/**\n * This function attaches all the top level functions to the\n * tiddlymap namespace.\n *\n * This will add the\n * 1. global logger method,\n * 2. the notify method\n * 3. the stopwatch methods `start` and `stop`.\n *\n * @param {Hashmap} parent - The parent object to attach the options to.\n */\nvar attachFunctions = function attachFunctions(parent) {\n\n  var fn = parent;\n  var nirvana = function nirvana() {/* /dev/null */};\n\n  if (_utils2.default.isTrue($tm.config.sys.debug, false) && console) {\n\n    /**\n     * A logging mechanism that uses the first argument as type and\n     * passes all consequent arguments as console arguments. The\n     * reason for this functions existence is to be able to switch\n     * off the logging without redirecting every single console function\n     * such as log, debug, warn etc. Plus, we have more control over\n     * the logging.\n     *\n     * @see http://stackoverflow.com/questions/5538972/console-log-apply-not-working-in-ie9\n     * @see http://stackoverflow.com/questions/9521921/why-does-console-log-apply-throw-an-illegal-invocation-error\n     *\n     * @param {string} type - The type of the message (debug, info, warning…)\n     *     which is exactly the same as in `console[type]`.\n     * @param {...*} message - An infinite number of arguments to be printed\n     *     (just like console).\n     */\n    fn.logger = function () /* type, [messages,] messages */{\n      if (arguments.length < 2) return;\n      var args = Array.prototype.slice.call(arguments);\n      var arg1 = args.shift(args);\n      var type = console.hasOwnProperty(arg1) ? arg1 : 'debug';\n      console[type].apply(console, args);\n    };\n\n    fn.start = function (timerName) {\n      console.time('[timer] ' + timerName);\n    };\n\n    fn.stop = function (timerName) {\n      console.timeEnd('[timer] ' + timerName);\n    };\n  } else {\n\n    fn.logger = fn.start = fn.stop = nirvana;\n  }\n\n  fn.notify = _utils2.default.isTrue($tm.config.sys.notifications) ? _utils2.default.notify : nirvana;\n};\n\n/**\n * This periodic check is needed to trigger a cleanup if a graph is\n * removed since a graph itself cannot react to its destruction.\n * This includes removing listeners that were not attached to the\n * local container or calling the vis destructor.\n *\n * @todo Specify which functions are required for widgets that register\n * themselves in the registry.\n */\nvar routineCheck = function routineCheck() {\n\n  for (var i = $tm.registry.length; i--;) {\n    var widget = $tm.registry[i];\n\n    if (!widget.destruct || !widget.isZombieWidget) return; // no duck!\n\n    if (widget.isZombieWidget()) {\n      // removed!\n      $tm.logger('warn', 'a widget will be removed');\n      $tm.registry.splice(i, 1);\n      widget.destruct();\n    }\n  }\n};\n\n/**\n * Every widget that has registered itself in the registry\n * will receive the `updates` object. The `updates` object is a more\n * advanced\n *\n * @param {Updates} updates\n */\nvar dispatchUpdates = function dispatchUpdates(updates) {\n\n  var registry = $tm.registry;\n  for (var i = registry.length; i--;) {\n\n    var widget = registry[i];\n\n    if (widget.update && widget.isZombieWidget && !widget.isZombieWidget()) {\n      widget.update(updates);\n    }\n  }\n};\n\n/**\n * We need to do this check as TiddlyWiki does not allow us to hook into the\n * clone process to find out whether a node was cloned.\n *\n * @param tObj\n */\nvar checkForClone = function checkForClone(tObj) {\n\n  var tRefs = _utils2.default.getDublicates(tObj);\n\n  if (!tRefs.length) {\n    return;\n  }\n\n  // remove any defined edges\n  _utils2.default.setField(tObj, 'tmap.edges', undefined);\n\n  // force override id\n  $tm.tracker.assignId(tObj, true);\n\n  // inform the user about what we did\n  $tm.dialogManager.open('dublicateIdInfo', {\n    param: {\n      changedTiddler: tObj.fields.title,\n      filter: _utils2.default.joinAndWrap(tRefs, '[[', ']]'),\n      id: _utils2.default.getId(tObj)\n    }\n  });\n};\n\n/**\n * Builds and registers globals and the functions that depend on them.\n */\nvar updateGlobals = function updateGlobals(parent) {\n\n  attachOptions($tm);\n  attachFunctions($tm);\n\n  // attention: logger() cannot be called before functions are rebuild\n  $tm.logger('warn', 'Rebuilt globals');\n};\n\nvar lastCurrentTiddler = null;\nvar updateLiveViewTrigger = function updateLiveViewTrigger(changedTiddlers) {\n\n  if (changedTiddlers['$:/HistoryList']) {\n    var tRef = _utils2.default.getField('$:/HistoryList', 'current-tiddler');\n  } else if (changedTiddlers['$:/temp/focussedTiddler']) {\n    var tRef = _utils2.default.getField('$:/temp/focussedTiddler', 'text');\n  }\n\n  if (tRef != null && lastCurrentTiddler !== tRef) {\n    lastCurrentTiddler = tRef;\n    _utils2.default.setField('$:/temp/tmap/currentTiddler', 'text', tRef);\n  }\n};\n\n/**\n * Only for debugging\n */\nvar printChanges = function printChanges(changedTiddlers, loopCount) {\n\n  if (!_utils2.default.isTrue($tm.config.sys.debug, false)) return;\n\n  $tm.logger('warn', '=== Refresh ' + loopCount + ' ===');\n\n  for (var tRef in changedTiddlers) {\n\n    var c = changedTiddlers[tRef].deleted ? '[Deleted]' : '[Modified]';\n\n    $tm.logger('warn', c, tRef, $tw.wiki.getTiddler(tRef));\n  }\n};\n\n/**\n * Saves the last mousemove event under $tm.mouse\n */\nvar registerMousemoveListener = function registerMousemoveListener() {\n\n  $tm.mouse = {};\n\n  var fn = function fn(evt) {\n    $tm.mouse = evt;\n  };\n  window.addEventListener('mousemove', fn, false);\n};\n\n/**\n * @TODO: suggest this to Jeremy for TW popup handling\n */\nvar registerClickListener = function registerClickListener() {\n\n  var tempPopups = $tm.path.tempPopups;\n  window.addEventListener('click', function (evt) {\n\n    var popupStates = _utils2.default.getTiddlersByPrefix(tempPopups);\n\n    for (var i = popupStates.length; i--;) {\n      if (_utils2.default.getText(popupStates[i])) break;\n    }\n\n    if (i === -1) return;\n\n    if (!$tw.utils.hasClass(evt.target, 'tc-drop-down') && !_utils2.default.getAncestorWithClass(evt.target, 'tc-drop-down')) {\n      // = clicked on an element that isn't a dropdown or inside one\n      for (var i = popupStates.length; i--;) {\n        _utils2.default.setText(popupStates[i], '');\n      }\n    }\n  }, false);\n};\n\n/**\n * Registers a change listener that will dispatch\n * @param callbackManager\n */\nvar registerChangeListener = function registerChangeListener(callbackManager) {\n\n  var loopCount = 0;\n\n  $tw.wiki.addEventListener('change', function (changedTiddlers) {\n\n    $tm.start('Caretaker handling changes');\n\n    printChanges(changedTiddlers, loopCount++);\n    callbackManager.refresh(changedTiddlers);\n\n    var updates = { changedTiddlers: {} };\n\n    for (var tRef in changedTiddlers) {\n\n      var tObj = _utils2.default.getTiddler(tRef);\n\n      if (tObj && tObj.isDraft()) {\n        continue;\n      }\n\n      var isHandled = handleTiddlerChange(tRef, tObj, updates);\n\n      if (isHandled) {\n        updates.changedTiddlers[tRef] = changedTiddlers[tRef];\n      }\n    }\n\n    dispatchUpdates(updates);\n\n    // NOTE: changes will affect the next refresh cycle\n    updateLiveViewTrigger(changedTiddlers);\n\n    $tm.stop('Caretaker handling changes');\n  });\n};\n\n/**\n * Mapping of paths and callbacks that should be invoked if tiddlers\n * within theses paths change.\n */\nvar rebuilders = (_rebuilders = {}, _defineProperty(_rebuilders, env.path.options, updateGlobals), _defineProperty(_rebuilders, env.path.nodeTypes, updateNodeTypesIndeces), _defineProperty(_rebuilders, env.path.edgeTypes, updateEdgeTypesIndeces), _rebuilders);\n\n/**\n * This function will deal with tiddler changes and will log changes\n * to the provided `updates` object.\n *\n * @param {TiddlerReference} tRef\n * @param {$tw.Tiddler} tObj\n * @param {Updates} updates\n */\nvar handleTiddlerChange = function handleTiddlerChange(tRef, tObj, updates) {\n\n  if ($tw.wiki.isSystemTiddler(tRef)) {\n\n    for (var path in rebuilders) {\n      if (_utils2.default.startsWith(tRef, path) && !updates[path]) {\n        $tm.logger('warn', '[System change]', path);\n        rebuilders[path]();\n        updates[path] = true;\n      }\n    }\n  } else if (tObj) {\n    // created or modified\n\n    if (tObj.fields.text === undefined) {\n      // sic; '' is ok\n      // to make sure that the tiddler's body is fully loaded\n      // we postpone the handling of the tiddler\n      // see https://github.com/felixhayashi/TW5-TiddlyMap/issues/222#issuecomment-268978764\n      $tw.wiki.dispatchEvent('lazyLoad', tRef);\n\n      return false;\n    }\n\n    checkForClone(tObj);\n\n    // call assignId IN ANY CASE to make sure the index\n    // stays intact, also after a renaming operation\n    $tm.tracker.assignId(tObj);\n  } else {\n    // deleted or renamed\n\n    var id = $tm.tracker.getIdByTiddler(tRef);\n\n    if (!id) {\n      // ignore tiddler without id\n      return false;\n    }\n\n    var tRefWithId = _utils2.default.getTiddlerWithField('tmap.id', id);\n\n    if (tRefWithId) {\n      // only renamed\n\n      $tm.logger('warn', '[Renamed]', tRef, 'into', tRefWithId);\n    } else {\n      // removed\n\n      // remove node; any edges pointing in/out; update indeces\n      // CAREFUL with recursion here!\n      $tm.adapter.deleteNode(id);\n    }\n  }\n\n  return true;\n};\n\n/**\n * Remove temp files from previous session.\n */\nvar cleanup = function cleanup() {\n\n  _utils2.default.deleteByPrefix('$:/temp/felixhayashi');\n  _utils2.default.deleteByPrefix('$:/temp/tiddlymap');\n  _utils2.default.deleteByPrefix('$:/temp/tmap');\n};\n\n/**\n * Register the view that should be displayed at startup.\n */\nvar loadDefaultView = function loadDefaultView(defaultView) {\n\n  if (defaultView) {\n    _utils2.default.setText(env.ref.defaultViewHolder, $tm.config.sys.defaultView);\n  }\n};\n\n/**\n * Init the wiki so we can start the main editor with the specified\n * view in fullscreen mode.\n *\n * @param {ViewAbstraction|string} view\n */\nvar prepareFullscreenStart = function prepareFullscreenStart(view) {\n  var _env$ref = env.ref,\n      mainEditor = _env$ref.mainEditor,\n      defaultViewHolder = _env$ref.defaultViewHolder;\n\n\n  _utils2.default.setSidebarTab(mainEditor);\n\n  if (_ViewAbstraction2.default.exists(view)) {\n    view = new _ViewAbstraction2.default(view);\n    _utils2.default.setField(defaultViewHolder, 'text', view.getLabel());\n  }\n};\n\n/**\n * The meta file keeps track of installation data.\n */\nvar createMetaFile = function createMetaFile(logger) {\n\n  if (_utils2.default.tiddlerExists(env.ref.sysMeta)) {\n    return;\n  }\n\n  logger('warn', 'Creating meta file');\n\n  var plugin = $tw.wiki.getTiddler(env.path.pluginRoot);\n\n  $tw.wiki.setTiddlerData(env.ref.sysMeta, {\n    // the version originally installed\n    originalVersion: plugin.fields.version,\n    // the data structure in use corresponds to version x\n    // if the structure is obsolete, it will be automatically\n    // fixed by the fixer module.\n    dataStructureState: '0.6.9',\n    // whether or not to display a welcome message\n    showWelcomeMessage: true\n  });\n};\n\n/*** Exports *******************************************************/\n\nvar name = exports.name = 'tmap.caretaker';\nvar platforms = exports.platforms = ['browser'];\nvar after = exports.after = ['startup'];\nvar before = exports.before = ['rootwidget'];\nvar synchronous = exports.synchronous = true;\nvar startup = exports.startup = init;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/services/Caretaker.js.map\n",
            "type": "application/javascript",
            "module-type": "startup"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/DialogManager": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/DialogManager",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/DialogManager\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _CallbackManager = require('$:/plugins/felixhayashi/tiddlymap/js/CallbackManager');\n\nvar _CallbackManager2 = _interopRequireDefault(_CallbackManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * The DialogManager is responsible for preparing, displaying and\n * finalizing all the dialogs.\n */\nvar DialogManager = function () {\n\n  /**\n   * @param {CallbackManager} callbackManager - A callback manager that\n   *     is informed about changed tiddlers and keeps track of the\n   *     various tiddlers produced during the dialog process.\n   * @param {Object} [context] - An optional *this*-reference to bind the\n   *     callback of each called dialog to. Otherwise, the callback of\n   *     each dialog has to be bound manually to the callback if required.\n   */\n  function DialogManager(callbackManager, context) {\n    _classCallCheck(this, DialogManager);\n\n    // create callback registry\n    this.callbackManager = callbackManager;\n    this.context = context;\n  }\n\n  /**\n   * This function opens a dialog based on a skeleton and some fields and eventually\n   * calls a callback once the dialog is closed. The callback contains an indicator\n   * whether the dialog subject was confirmed or the operation cancelled. In any\n   * case the output tiddler is passed to the callback. Each dialog may write its\n   * changes to this tiddler in order to store the dialog result and make it available\n   * to the callback.\n   *\n   * How does it work?\n   *\n   * The output of the dialog process is stored in a temporary tiddler that is only known\n   * to the current instance of the dialog. This way it is ensured that only the dialog process\n   * that created the temporary tiddler will retrieve the result. Now we are able to\n   * provide unambigous and unique correspondance to dialog callbacks.\n    * Any dialog output is stored in a unique output-tiddler. Once there is a result,\n   * a new result tiddler is created with indicators how to interpret the output.\n   * The result tiddler can be understood as exit code that is independent of the output.\n   * It is the result tiddler that triggers the dialog callback that was registered before.\n   * the output is then read immediately from the output-tiddler.\n   *\n   * @param {string} templateId - The dialog id which is the basename of\n   *     the template title.\n   * @param {Hashmap} [param] - All properties (except those with special meanings)\n   *     of param will be accessible as variables in the modal\n   * @param {string} [param.subtitle] -\n   * @param {string} [param.cancelButtonLabel] - The label of the cancel button.\n   * @param {string} [param.confirmButtonLabel] - The label of the confirm button.\n   * @param {function} [callback] - A function with the signature\n   *     function(isConfirmed, outputTObj). `outputTObj` contains data\n   *     produced by the dialog (can be undefined even if confirmed!).\n   *     Be careful: the tiddler that outputTObj represents is deleted immediately.\n   * @return {$tw.Tiddler} The dialog tddler object with all its fields.\n   */\n\n\n  _createClass(DialogManager, [{\n    key: 'open',\n    value: function open(templateId) {\n      var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var callback = arguments[2];\n\n\n      if (_utils2.default.isTrue($tm.config.sys.suppressedDialogs[templateId], false)) {\n        $tm.logger('warning', 'Suppressed dialog', templateId);\n        return;\n      }\n\n      $tm.logger('debug', 'Dialog param object', param);\n\n      if (typeof callback === 'function' && this.context) {\n        callback = callback.bind(this.context);\n      }\n\n      // create a temporary tiddler reference for the dialog\n      var dialogTRef = $tm.path.tempRoot + '/dialog-' + _utils2.default.genUUID();\n\n      // get the dialog template\n      var skeleton = _utils2.default.getTiddler($tm.path.dialogs + '/' + templateId);\n\n      // fields used to handle the dialog process\n      var dialog = {\n        title: dialogTRef,\n        buttons: skeleton.fields['buttons'] || 'ok_cancel',\n        classes: 'tmap-modal-content ' + skeleton.fields['classes'],\n        output: dialogTRef + '/output',\n        result: dialogTRef + '/result',\n        temp: dialogTRef + '/temp',\n        template: skeleton.fields.title,\n        templateId: templateId,\n        currentTiddler: dialogTRef + '/output',\n        text: _utils2.default.getText($tm.path.dialogs)\n      };\n\n      _utils2.default.touch(dialog.output);\n\n      if (param.dialog) {\n\n        if (param.dialog.preselects) {\n\n          // register preselects\n          $tw.wiki.addTiddler(new $tw.Tiddler({ title: dialog.output }, _utils2.default.flatten(param.dialog.preselects)));\n\n          // remove preselects from param object\n          delete param.dialog.preselects;\n        }\n\n        // extend the dialog object with parameters provided by the user\n        _utils2.default.merge(dialog, param.dialog);\n      }\n\n      // force the footer to be set to the wrapper\n      // the footer wrapper will determine the footer from the\n      // buttons field/variable\n      dialog.footer = _utils2.default.getText($tm.path.footers);\n\n      // flatten dialog and param object\n      dialog = _utils2.default.flatten(dialog);\n      param = _utils2.default.flatten(param);\n\n      var fn = function fn(tRef) {\n\n        DialogManager.getElement('hidden-close-button').click();\n\n        var triggerTObj = $tw.wiki.getTiddler(tRef);\n        var isConfirmed = triggerTObj.fields.text;\n\n        var outputTObj = null;\n        if (isConfirmed) {\n          outputTObj = $tw.wiki.getTiddler(dialog.output);\n        } else {\n          $tm.notify('operation cancelled');\n        }\n\n        if (typeof callback === 'function') {\n          callback(isConfirmed, outputTObj);\n        }\n\n        // close and remove all tiddlers used by the dialog\n        _utils2.default.deleteByPrefix(dialogTRef);\n      };\n\n      // add trigger\n      this.callbackManager.add(dialog.result, fn, true);\n\n      // create dialog\n      var dialogTiddler = new $tw.Tiddler(skeleton, param, dialog);\n      $tw.wiki.addTiddler(dialogTiddler);\n\n      $tm.logger('debug', 'Opening dialog', dialogTiddler);\n\n      $tw.rootWidget.dispatchEvent({\n        type: 'tm-modal',\n        param: dialogTiddler.fields.title,\n        paramObject: dialogTiddler.fields\n      });\n\n      DialogManager.addKeyBindings();\n\n      return dialogTiddler;\n    }\n  }], [{\n    key: 'getElement',\n    value: function getElement(name) {\n\n      return _utils2.default.getFirstElementByClassName('tmap-' + name);\n    }\n\n    /**\n     * This method will search for form elements that have the class\n     * `tmap-trigger-field` set, which means that TiddlyMap shall\n     * perform a button press when a key combo occurs while the field\n     * has focus. To know which button to press on what key event,\n     * it looks for classes of the form: tmap-triggers-BUTTONNAME-on-KEYCOMBO.\n     */\n\n  }, {\n    key: 'addKeyBindings',\n    value: function addKeyBindings() {\n\n      var keys = $tm.keycharm({\n        container: _utils2.default.getFirstElementByClassName('tc-modal')\n      });\n\n      var re = /tmap-triggers-(.+?)-on-(.+?)(?:\\s|$)/;\n      var triggers = document.getElementsByClassName('tmap-trigger-field');\n\n      var _loop = function _loop(i) {\n        var classNames = triggers[i].className.split(' ');\n\n        var _loop2 = function _loop2(j) {\n          var matches = classNames[j].match(re);\n          if (!matches) {\n            // don't care\n            return 'continue';\n          }\n          var buttonName = matches[1];\n          var key = matches[2];\n          var buttonElement = DialogManager.getElement(buttonName);\n          if (!buttonElement) {\n            return 'continue';\n          }\n          keys.bind(key, function () {\n            if (document.getElementsByClassName(classNames[j]).length) {\n              // only click button if trigger is active (i.e. still in focus)\n              // see https://github.com/felixhayashi/TW5-TiddlyMap/issues/280\n              buttonElement.click();\n            }\n          });\n        };\n\n        for (var j = classNames.length; j--;) {\n          var _ret2 = _loop2(j);\n\n          if (_ret2 === 'continue') continue;\n        }\n      };\n\n      for (var i = triggers.length; i--;) {\n        _loop(i);\n      }\n    }\n  }]);\n\n  return DialogManager;\n}();\n\n/*** Exports *******************************************************/\n\nexports.default = DialogManager;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/services/DialogManager.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/Fixer": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/Fixer",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/Fixer\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _ViewAbstraction = require('$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction');\n\nvar _ViewAbstraction2 = _interopRequireDefault(_ViewAbstraction);\n\nvar _EdgeType = require('$:/plugins/felixhayashi/tiddlymap/js/EdgeType');\n\nvar _EdgeType2 = _interopRequireDefault(_EdgeType);\n\nvar _NodeType = require('$:/plugins/felixhayashi/tiddlymap/js/NodeType');\n\nvar _NodeType2 = _interopRequireDefault(_NodeType);\n\nvar _environment = require('$:/plugins/felixhayashi/tiddlymap/js/lib/environment');\n\nvar env = _interopRequireWildcard(_environment);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*** Code **********************************************************/\n\nvar Fixer = function () {\n\n  /**\n   * @param {Adapter} adapter\n   * @param {Object} logger\n   * @param {Object} glNTy\n   */\n  function Fixer(adapter, logger, glNTy) {\n    _classCallCheck(this, Fixer);\n\n    this.adapter = adapter;\n    this.logger = logger;\n    this.wiki = $tw.wiki;\n    this.glNTy = glNTy;\n  }\n\n  _createClass(Fixer, [{\n    key: 'moveEdges',\n    value: function moveEdges(path, view) {\n\n      var matches = _utils2.default.getTiddlersByPrefix(path);\n      for (var i = 0; i < matches.length; i++) {\n\n        // create edge type\n        var type = _utils2.default.getBasename(matches[i]);\n\n        if (type === '__noname__') {\n          type = 'tmap:unknown';\n        }\n\n        type = _EdgeType2.default.getInstance(type);\n\n        if (!type.exists()) {\n          type.save();\n        }\n\n        // move edges\n        var edges = this.wiki.getTiddlerData(matches[i]);\n        for (var j = 0; j < edges.length; j++) {\n          // prefix formerly private edges with view name as namespace\n          edges[j].type = (view ? view + ':' : '') + type.id;\n          this.adapter.insertEdge(edges[j]);\n        }\n\n        // finally remove the store\n        this.wiki.deleteTiddler(matches[i]);\n      }\n    }\n  }, {\n    key: 'executeUpgrade',\n    value: function executeUpgrade(toVersion, curVersion, upgrade) {\n\n      if (!_utils2.default.isLeftVersionGreater(toVersion, curVersion)) {\n        // = current data structure version is newer than version we want to upgrade to.\n        return;\n      }\n\n      // issue debug message\n      this.logger('debug', 'Upgrading data structure to ' + toVersion);\n      // execute fix\n      var msg = upgrade();\n      // update meta\n      _utils2.default.setEntry(env.ref.sysMeta, 'dataStructureState', toVersion);\n\n      return msg;\n    }\n  }, {\n    key: 'fixId',\n\n\n    /**\n     * Special fix that is not invoked along with the other fixes but\n     * when creating the index (see caretaker code).\n     *\n     * Changes:\n     * 1. The node id field is moved to tmap.id if **original version**\n     *    is below v0.9.2.\n     */\n    value: function fixId() {\n\n      var meta = this.wiki.getTiddlerData(env.ref.sysMeta, {});\n\n      this.executeUpgrade('0.9.2', meta.dataStructureState, function () {\n\n        if (_utils2.default.isLeftVersionGreater('0.9.2', meta.originalVersion)) {\n          // path of the user conf at least in 0.9.2\n          var userConf = '$:/plugins/felixhayashi/tiddlymap/config/sys/user';\n          var nodeIdField = _utils2.default.getEntry(userConf, 'field.nodeId', 'tmap.id');\n          _utils2.default.moveFieldValues(nodeIdField, 'tmap.id', true, false);\n        }\n      });\n    }\n  }, {\n    key: 'fix',\n    value: function fix() {\n      var _this = this;\n\n      var meta = this.wiki.getTiddlerData(env.ref.sysMeta, {});\n\n      this.logger('debug', 'Fixer is started');\n      this.logger('debug', 'Data-structure currently in use: ', meta.dataStructureState);\n\n      /**\n       * Changes:\n       * 1. Edges are stored in tiddlers instead of type based edge stores\n       * 2. No more private views\n       */\n      this.executeUpgrade('0.7.0', meta.dataStructureState, function () {\n\n        // move edges that were formerly \"global\"\n        _this.moveEdges('$:/plugins/felixhayashi/tiddlymap/graph/edges', null);\n\n        // move edges that were formerly bound to view (\"private\")\n        var filter = env.selector.allViews;\n        var viewRefs = _utils2.default.getMatches(filter);\n        for (var i = 0; i < viewRefs.length; i++) {\n          var view = new _ViewAbstraction2.default(viewRefs[i]);\n          _this.moveEdges(view.getRoot() + '/graph/edges', view);\n        }\n      });\n\n      /**\n       * Changes:\n       * 1. Changes to the live view filter and refresh trigger field\n       */\n      this.executeUpgrade('0.7.32', meta.dataStructureState, function () {\n\n        if (!_ViewAbstraction2.default.exists('Live View')) {\n\n          return;\n        }\n\n        var liveView = new _ViewAbstraction2.default('Live View');\n\n        // Only listen to the current tiddler of the history list\n        liveView.setNodeFilter('[field:title{$:/temp/tmap/currentTiddler}]', true);\n\n        liveView.setConfig({\n          'refresh-trigger': null, // delete the field (renamed)\n          'refresh-triggers': $tw.utils.stringifyList(['$:/temp/tmap/currentTiddler'])\n        });\n      });\n\n      /**\n       * Changes:\n       * 1. Group styles for matches and neighbours are now modulized\n       *    and stored as node-types.\n       * 2. vis user configuration is restored unflattened!\n       *    The user only interacts through the GUI.\n       * 3. If the node id field was \"id\" it is moved to tmap.id\n       */\n      this.executeUpgrade('0.9.0', meta.dataStructureState, function () {\n\n        var confRef = env.ref.visUserConf;\n        var userConf = _utils2.default.unflatten(_this.wiki.getTiddlerData(confRef, {}));\n\n        if (_typeof(userConf.groups) === 'object') {\n\n          var type = _NodeType2.default.getInstance('tmap:neighbour');\n          type.setStyle(userConf.groups['neighbours']);\n          type.save();\n\n          delete userConf.groups;\n          _this.wiki.setTiddlerData(confRef, userConf);\n        }\n      });\n\n      /**\n       * Changes:\n       * 1. The node id field is moved to tmap.id if **original version**\n       *    is below v0.9.2.\n       */\n      this.fixId();\n\n      /**\n       * This will ensure that all node types have a prioritization field\n       * set.\n       */\n      this.executeUpgrade('0.9.16', meta.dataStructureState, function () {\n\n        for (var i = _this.glNTy.length; i--;) {\n          _this.glNTy[i].save(null, true);\n        }\n      });\n\n      /**\n       * Fixes the live tab\n       */\n      this.executeUpgrade('0.10.3', meta.dataStructureState, function () {\n\n        var liveTab = env.ref.liveTab;\n        if (_utils2.default.getTiddler(liveTab).hasTag('$:/tags/SideBar')) {\n          this.wiki.deleteTiddler(liveTab);\n          _utils2.default.setField(liveTab, 'tags', '$:/tags/SideBar');\n        }\n      });\n\n      /**\n       * 1) Fixes the edge type filter. Before, an empty filter was\n       * treated as default filter, i.e. no links and tags shown.\n       * Now an empty filter means that we show all edge types.\n       *\n       * 2) Adds prefix to hide private edges per default\n       *\n       * 3) Corrects view-namespaces (formerly stored with colon).\n       *\n       */\n      this.executeUpgrade('0.11.0', meta.dataStructureState, function () {\n\n        var views = _utils2.default.getMatches(env.selector.allViews);\n\n        for (var i = views.length; i--;) {\n\n          var view = new _ViewAbstraction2.default(views[i]);\n          var eTyFilter = view.getEdgeTypeFilter('raw');\n          var confKey = 'edge_type_namespace';\n          view.setConfig(confKey, view.getConfig(confKey));\n\n          var f = env.filter.defaultEdgeTypeFilter;\n\n          if (eTyFilter) {\n\n            // remove any occurences of the egde type path prefix\n            var edgeTypePath = env.path.edgeTypes;\n            eTyFilter = _utils2.default.replaceAll(eTyFilter, '', [edgeTypePath, edgeTypePath + '/', '[prefix[' + edgeTypePath + ']]', '[prefix[' + edgeTypePath + '/]]', ['[suffix[tw-body:link]]', '[[tw-body:link]]'], ['[suffix[tw-list:tags]]', '[[tw-list:tags]]'], ['[suffix[tw-list:list]]', '[[tw-body:list]]'], ['[suffix[tmap:unknown]]', '[[tmap:unknown]]'], ['[suffix[unknown]]', '[[tmap:unknown]]']]);\n\n            f = '-[prefix[_]] ' + eTyFilter;\n          }\n\n          view.setEdgeTypeFilter(f);\n        }\n      });\n    }\n  }]);\n\n  return Fixer;\n}();\n\n/*** Exports *******************************************************/\n\nexports.default = Fixer;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/services/Fixer.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/startup/listener": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/startup/listener",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.startup = exports.synchronous = exports.before = exports.after = exports.platforms = exports.name = undefined;\n\nvar _NodeType = require('$:/plugins/felixhayashi/tiddlymap/js/NodeType');\n\nvar _NodeType2 = _interopRequireDefault(_NodeType);\n\nvar _EdgeType = require('$:/plugins/felixhayashi/tiddlymap/js/EdgeType');\n\nvar _EdgeType2 = _interopRequireDefault(_EdgeType);\n\nvar _Edge = require('$:/plugins/felixhayashi/tiddlymap/js/Edge');\n\nvar _Edge2 = _interopRequireDefault(_Edge);\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _vis = require('$:/plugins/felixhayashi/tiddlymap/js/config/vis');\n\nvar _vis2 = _interopRequireDefault(_vis);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*** Code **********************************************************/\n\n/**\n * @param {Object} param - event.param\n */\nvar handleCancelDialog = function handleCancelDialog(_ref) {\n  var param = _ref.param;\n\n  _utils2.default.setField(param, 'text', '');\n};\n\n/**\n * @param {Object} paramObject - event.paramObject\n */\n// @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/startup/listener\ntype: application/javascript\nmodule-type: startup\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nvar handleClearTiddler = function handleClearTiddler() {\n  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      paramObject = _ref2.paramObject;\n\n  var title = paramObject.title,\n      keep = paramObject.keep;\n\n\n  if (!title) return;\n\n  var tObj = _utils2.default.getTiddler(title);\n  var originalFields = tObj ? tObj.fields : {};\n  var fieldsToKeep = keep ? keep.split() : [];\n  var cloneFields = {\n    title: title,\n    text: '' // see https://github.com/Jermolene/TiddlyWiki5/issues/2025\n  };\n\n  for (var i = fieldsToKeep.length; i--;) {\n    var fieldName = fieldsToKeep[i];\n    cloneFields[fieldName] = originalFields[fieldName];\n  }\n\n  $tw.wiki.deleteTiddler(title);\n  $tw.wiki.addTiddler(new $tw.Tiddler(cloneFields));\n};\n\n/**\n * @param {Object} paramObject - event.paramObject\n */\nvar handleMixTiddlers = function handleMixTiddlers(_ref3) {\n  var _ref3$paramObject = _ref3.paramObject,\n      paramObject = _ref3$paramObject === undefined ? {} : _ref3$paramObject;\n  var tiddlersStringArray = paramObject.tiddlers,\n      output = paramObject.output;\n\n\n  if (!tiddlersStringArray || !output) return;\n\n  var tiddlers = $tw.utils.parseStringArray(tiddlersStringArray);\n  var tObj = _utils2.default.getMergedTiddlers(tiddlers, output);\n\n  $tw.wiki.addTiddler(tObj);\n};\n\n/**\n * @param {string} param - event.param\n */\nvar handleConfirmDialog = function handleConfirmDialog(_ref4) {\n  var param = _ref4.param;\n\n\n  _utils2.default.setField(param, 'text', '1');\n};\n\n/**\n * @param {Object} paramObject - event.paramObject\n */\nvar handleSuppressDialog = function handleSuppressDialog(_ref5) {\n  var paramObject = _ref5.paramObject;\n  var dialog = paramObject.dialog,\n      suppress = paramObject.suppress;\n\n\n  if (_utils2.default.isTrue(suppress, false)) {\n    _utils2.default.setEntry($tm.ref.sysUserConf, 'suppressedDialogs.' + dialog, true);\n  }\n};\n\n/**\n * @param {Object} paramObject - event.paramObject\n */\nvar handleDownloadGraph = function handleDownloadGraph(_ref6) {\n  var paramObject = _ref6.paramObject;\n  var view = paramObject.view;\n\n  var graph = $tm.adapter.getGraph({ view: view });\n\n  graph.nodes = _utils2.default.convert(graph.nodes, 'array');\n  graph.edges = _utils2.default.convert(graph.edges, 'array');\n\n  var tRef = '$:/temp/tmap/export';\n\n  _utils2.default.setField(tRef, 'text', JSON.stringify(graph, null, 2));\n\n  $tw.rootWidget.dispatchEvent({\n    type: 'tm-download-file',\n    param: tRef,\n    paramObject: {\n      filename: view + '.json'\n    }\n  });\n};\n\n/**\n *\n */\nvar handleConfigureSystem = function handleConfigureSystem() {\n\n  var allTiddlers = _utils2.default.getMatches($tm.selector.allPotentialNodes);\n  var allEdges = $tm.adapter.getEdgesForSet(allTiddlers);\n  var plugin = $tw.wiki.getTiddler($tm.path.pluginRoot).fields;\n  var meta = $tw.wiki.getTiddlerData($tm.ref.sysMeta);\n  var hasLiveTab = _utils2.default.getTiddler($tm.ref.liveTab).hasTag('$:/tags/SideBar');\n\n  var args = {\n    numberOfNodes: '' + allTiddlers.length,\n    numberOfEdges: '' + Object.keys(allEdges).length,\n    pluginVersion: 'v' + plugin.version,\n    dataStructureVersion: 'v' + meta.dataStructureState,\n    dialog: {\n      preselects: {\n        'liveTab': '' + hasLiveTab,\n        'vis-inherited': JSON.stringify(_vis2.default),\n        'config.vis': _utils2.default.getText($tm.ref.visUserConf),\n        'config.sys': $tm.config.sys\n      }\n    }\n  };\n\n  $tm.dialogManager.open('globalConfig', args, function (isConfirmed, outTObj) {\n\n    if (!isConfirmed) return;\n\n    var config = _utils2.default.getPropertiesByPrefix(outTObj.fields, 'config.sys.', true);\n\n    // CAREFUL: this is a data tiddler!\n    $tw.wiki.setTiddlerData($tm.ref.sysUserConf, config);\n\n    // show or hide the live tab; to hide the live tab, we override\n    // the shadow tiddler; to show it, we remove the overlay again.\n    if (_utils2.default.isTrue(outTObj.fields.liveTab, false)) {\n      _utils2.default.setField($tm.ref.liveTab, 'tags', '$:/tags/SideBar');\n    } else {\n      $tw.wiki.deleteTiddler($tm.ref.liveTab);\n    }\n\n    // tw doesn't translate the json to an object so this is already a string\n    _utils2.default.setField($tm.ref.visUserConf, 'text', outTObj.fields['config.vis']);\n  });\n};\n\n/**\n * @param {Object} paramObject - event.paramObject\n */\nvar handleGenerateWidget = function handleGenerateWidget(_ref7) {\n  var _ref7$paramObject = _ref7.paramObject,\n      paramObject = _ref7$paramObject === undefined ? {} : _ref7$paramObject;\n\n\n  var options = {\n    dialog: {\n      preselects: {\n        'var.view': paramObject.view || $tm.misc.defaultViewLabel\n      }\n    }\n  };\n\n  $tm.dialogManager.open('widgetCodeGenerator', options);\n};\n\n/**\n * @param {Object} paramObject - event.paramObject\n */\nvar handleRemoveEdge = function handleRemoveEdge(_ref8) {\n  var paramObject = _ref8.paramObject;\n\n\n  $tm.adapter.deleteEdge(paramObject);\n};\n\n/**\n * @param {Object} paramObject - event.paramObject\n */\nvar handleCreateEdge = function handleCreateEdge(_ref9) {\n  var paramObject = _ref9.paramObject;\n  var from = paramObject.from,\n      to = paramObject.to,\n      isForce = paramObject.force;\n\n\n  if (!from || !to) return;\n\n  if (_utils2.default.tiddlerExists(from) && _utils2.default.tiddlerExists(to) || isForce) {\n\n    // will not override any existing tiddlers…\n    _utils2.default.addTiddler(to);\n    _utils2.default.addTiddler(from);\n\n    var edge = new _Edge2.default($tm.adapter.makeNode(from).id, $tm.adapter.makeNode(to).id, paramObject.label, paramObject.id);\n\n    $tm.adapter.insertEdge(edge);\n    $tm.notify('Edge inserted');\n  }\n};\n\n/**\n * @param {string} type - event.type\n * @param {Object} [paramObject] - event.paramObject\n */\nvar handleOpenTypeManager = function handleOpenTypeManager(_ref10) {\n  var type = _ref10.type,\n      _ref10$paramObject = _ref10.paramObject,\n      paramObject = _ref10$paramObject === undefined ? {} : _ref10$paramObject;\n\n\n  // either 'manage-edge-types' or 'manage-node-types'\n  var mode = type.match(/tmap:tm-(.*)/)[1];\n\n  if (mode === 'manage-edge-types') {\n    var topic = 'Edge-Type Manager';\n    var allTypesSelector = $tm.selector.allEdgeTypes;\n    var typeRootPath = $tm.path.edgeTypes;\n  } else {\n    var topic = 'Node-Type Manager';\n    var allTypesSelector = $tm.selector.allNodeTypes;\n    var typeRootPath = $tm.path.nodeTypes;\n  }\n\n  var args = {\n    mode: mode,\n    topic: topic,\n    searchSelector: allTypesSelector,\n    typeRootPath: typeRootPath\n  };\n\n  var dialogTObj = $tm.dialogManager.open('MapElementTypeManager', args);\n\n  if (paramObject.type) {\n    handleLoadTypeForm({\n      paramObject: {\n        mode: mode,\n        id: paramObject.type,\n        output: dialogTObj.fields['output']\n      }\n    });\n  }\n};\n\n/**\n * @param {string} id - The id of a {@link MapElementType}\n * @param {('manage-edge-types'|'manage-node-types')} mode\n * @param {TiddlerReference} output\n */\nvar handleLoadTypeForm = function handleLoadTypeForm(_ref11) {\n  var _ref11$paramObject = _ref11.paramObject,\n      mode = _ref11$paramObject.mode,\n      id = _ref11$paramObject.id,\n      output = _ref11$paramObject.output;\n\n\n  var outTRef = output;\n  var type = mode === 'manage-edge-types' ? _EdgeType2.default.getInstance(id) : _NodeType2.default.getInstance(id);\n\n  // inject all the type data as fields into the dialog output\n  type.save(outTRef, true);\n\n  // fields that need preprocessing\n\n  if (mode === 'manage-edge-types') {\n    var usage = $tm.adapter.selectEdgesByType(type);\n    var count = Object.keys(usage).length;\n    _utils2.default.setField(outTRef, 'temp.usageCount', count);\n  }\n\n  $tw.wiki.addTiddler(new $tw.Tiddler(_utils2.default.getTiddler(outTRef), {\n    'typeTRef': type.fullPath,\n    'temp.idImmutable': type.isShipped ? 'true' : '',\n    'temp.newId': type.id,\n    'vis-inherited': JSON.stringify($tm.config.vis)\n  }));\n\n  // reset the tabs to default\n  _utils2.default.deleteByPrefix('$:/state/tabs/MapElementTypeManager');\n};\n\n/**\n * @param {Object} paramObject - event.paramObject\n */\nvar handleSaveTypeForm = function handleSaveTypeForm(_ref12) {\n  var paramObject = _ref12.paramObject;\n\n\n  var tObj = _utils2.default.getTiddler(paramObject.output);\n  if (!tObj) return;\n\n  var id = tObj.fields.id;\n  var mode = paramObject.mode;\n\n  if (_utils2.default.isTrue(tObj.fields['temp.deleteType'], false)) {\n    deleteType(mode, id, tObj);\n  } else {\n    saveType(mode, id, tObj);\n  }\n};\n\nvar deleteType = function deleteType(mode, id, dialogOutput) {\n\n  var type = mode === 'manage-edge-types' ? _EdgeType2.default.getInstance(id) : _NodeType2.default.getInstance(id);\n\n  $tm.logger('debug', 'Deleting type', type);\n\n  if (mode === 'manage-edge-types') {\n    $tm.adapter._processEdgesWithType(type, { action: 'delete' });\n  } else {\n    $tm.adapter.removeNodeType(type);\n  }\n\n  $tw.wiki.addTiddler(new $tw.Tiddler({\n    title: _utils2.default.getTiddlerRef(dialogOutput)\n  }));\n\n  $tm.notify('Deleted type');\n};\n\n/**\n * @param {string} id - The id of a {@link MapElementType}\n * @param {('manage-edge-types'|'manage-node-types')} mode\n * @param {TiddlerReference} output\n */\nvar saveType = function saveType(mode, id, output) {\n\n  var tObj = _utils2.default.getTiddler(output);\n\n  // update the type with the form data\n  var Type = mode === 'manage-edge-types' ? _EdgeType2.default : _NodeType2.default;\n  var type = new Type(id, tObj);\n  type.save();\n\n  var newId = tObj.fields['temp.newId'];\n\n  if (newId && newId !== tObj.fields['id']) {\n    //renamed\n\n    if (mode === 'manage-edge-types') {\n\n      $tm.adapter._processEdgesWithType(type, {\n        action: 'rename',\n        newName: newId\n      });\n    } else {\n\n      new _NodeType2.default(newId, type).save();\n      $tw.wiki.deleteTiddler(type.fullPath);\n    }\n\n    _utils2.default.setField(tObj, 'id', newId);\n  }\n\n  $tm.notify('Saved type data');\n};\n\n/**\n * @param {string} id - The id of a {@link MapElementType}\n * @param {('manage-edge-types'|'manage-node-types')} mode\n * @param {TiddlerReference} output\n */\nvar handleCreateType = function handleCreateType(_ref13) {\n  var _ref13$paramObject = _ref13.paramObject,\n      mode = _ref13$paramObject.mode,\n      _ref13$paramObject$id = _ref13$paramObject.id,\n      id = _ref13$paramObject$id === undefined ? 'New type' : _ref13$paramObject$id,\n      output = _ref13$paramObject.output;\n\n\n  var type = mode === 'manage-edge-types' ? new _EdgeType2.default(id) : new _NodeType2.default(id);\n\n  type.save();\n\n  handleLoadTypeForm({ paramObject: { id: type.id, mode: mode, output: output } });\n};\n\n/*** Exports *******************************************************/\n\nvar name = exports.name = 'tmap.listener';\nvar platforms = exports.platforms = ['browser'];\nvar after = exports.after = ['rootwidget', 'tmap.caretaker'];\nvar before = exports.before = ['story'];\nvar synchronous = exports.synchronous = true;\nvar startup = exports.startup = function startup() {\n  _utils2.default.addTWlisteners({\n    'tmap:tm-remove-edge': handleRemoveEdge,\n    'tmap:tm-load-type-form': handleLoadTypeForm,\n    'tmap:tm-save-type-form': handleSaveTypeForm,\n    'tmap:tm-create-type': handleCreateType,\n    'tmap:tm-create-edge': handleCreateEdge,\n    'tmap:tm-suppress-dialog': handleSuppressDialog,\n    'tmap:tm-generate-widget': handleGenerateWidget,\n    'tmap:tm-download-graph': handleDownloadGraph,\n    'tmap:tm-configure-system': handleConfigureSystem,\n    'tmap:tm-manage-edge-types': handleOpenTypeManager,\n    'tmap:tm-manage-node-types': handleOpenTypeManager,\n    'tmap:tm-cancel-dialog': handleCancelDialog,\n    'tmap:tm-clear-tiddler': handleClearTiddler,\n    'tmap:tm-merge-tiddlers': handleMixTiddlers,\n    'tmap:tm-confirm-dialog': handleConfirmDialog\n  }, $tw.rootWidget, undefined);\n};\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/services/Listener.js.map\n",
            "type": "application/javascript",
            "module-type": "startup"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/services/tracker": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/services/tracker",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/services/tracker\ntype: application/javascript\nmodule-type: library\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/***************************** CODE ********************************/\n\n/**\n *\n */\nvar Tracker = function () {\n  function Tracker(fixer) {\n    _classCallCheck(this, Tracker);\n\n    this.wiki = $tw.wiki;\n    this.logger = $tm.logger;\n\n    this._createIndex();\n  }\n\n  /**\n   * TiddlyMap uses ids to reference tiddlers. This function creates\n   * a table that maps ids to tRefs and vice versa.\n   *\n   * Two indeces are added to the indeces chain:\n   * 1. tById – tiddler references by id\n   * 2. idByT – ids by tiddler references\n   *\n   * @param {Array<TiddlerReference>} [allTiddlers] - The tiddlers to\n   *     use as basis for this index. If not stated, all tiddlers in\n   *     the wiki are used.\n   */\n\n\n  _createClass(Tracker, [{\n    key: '_createIndex',\n    value: function _createIndex() {\n\n      var tById = this.tById = {}; // tiddlerById\n      var idByT = this.idByT = {}; // idByTiddler\n\n      this.wiki.each(function (tObj, tRef) {\n\n        if (_utils2.default.isSystemOrDraft(tObj)) {\n          return;\n        }\n\n        // will create id if not present\n        var id = tObj.fields['tmap.id'];\n        if (!id) {\n          id = _utils2.default.genUUID();\n          _utils2.default.setField(tObj, 'tmap.id', id);\n        }\n\n        tById[id] = tRef; // tiddlerById\n        idByT[tRef] = id; // idByTiddler\n      });\n    }\n\n    /**\n     * This method will assign an id to an *existing* tiddler that does\n     * not already possess and id. Any assigned id will be registered\n     * at the id->tiddler index.\n     *\n     * @param {Tiddler} tiddler - The tiddler to assign the id to.\n     * @param {boolean} isForce - True if the id should be overridden,\n     *     false otherwise. Only works if the id field is not set to title.\n     *\n     * @return {Id} The assigned or retrieved id.\n     */\n\n  }, {\n    key: 'assignId',\n    value: function assignId(tiddler, isForce) {\n\n      // Note: always reload from store to avoid setting wrong ids on tiddler\n      // being in the role of from and to at the same time.\n      var tObj = _utils2.default.getTiddler(tiddler);\n\n      if (!tObj) {\n        throw new ResourceNotFoundException(tiddler);\n      }\n\n      var id = tObj.fields['tmap.id'];\n\n      if (!id || isForce) {\n        id = _utils2.default.genUUID();\n        _utils2.default.setField(tObj, 'tmap.id', id);\n        this.logger('info', 'Assigning new id to', tObj.fields.title);\n      }\n\n      // blindly update the index IN ANY CASE because tiddler may have\n      // an id but it is not indexed yet (e.g. because of renaming operation)\n      this.tById[id] = tObj.fields.title;\n      this.idByT[tObj.fields.title] = id;\n\n      return id;\n    }\n\n    /**\n     * @param {Tiddler} tiddler\n     * @return string\n     */\n\n  }, {\n    key: 'getIdByTiddler',\n    value: function getIdByTiddler(tiddler) {\n\n      return this.idByT[_utils2.default.getTiddlerRef(tiddler)];\n    }\n  }, {\n    key: 'getIdsByTiddlers',\n    value: function getIdsByTiddlers() {\n      return this.idByT;\n    }\n  }, {\n    key: 'getTiddlersByIds',\n    value: function getTiddlersByIds() {\n      return this.tById;\n    }\n\n    /**\n     * @param id\n     * @return {TiddlerReference} tiddler\n     */\n\n  }, {\n    key: 'getTiddlerById',\n    value: function getTiddlerById(id) {\n\n      return this.tById[id];\n    }\n  }]);\n\n  return Tracker;\n}();\n\n/*** Exports *******************************************************/\n\nexports.default = Tracker;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/services/Tracker.js.map\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/widget/MapConfigWidget": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/widget/MapConfigWidget",
            "text": "'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/widget/MapConfigWidget\ntype: application/javascript\nmodule-type: widget\n\n@preserve\n\n\\*/\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _vis = require('$:/plugins/felixhayashi/vis/vis.js');\n\nvar _vis2 = _interopRequireDefault(_vis);\n\nvar _widget = require('$:/core/modules/widgets/widget.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Wrapper for the Visjs configurator.\n *\n * ```\n * <$tmap-config\n *     inherited=\"FIELDNAME FIELDNAME …\"\n *     extension=\"FIELDNAME\"\n *     changes=\"FIELDNAME\" (default: same field as extension)\n *     override=\"true|false\" (default: false)\n *     mode=\"manage-*\"\n *     refresh-trigger=\"tRef\" />\n * ```\n *\n * @constructor\n */\nfunction MapConfigWidget(parseTreeNode, options) {\n\n  // call the parent constructor\n  _widget.widget.call(this);\n\n  // call initialise on prototype\n  this.initialise(parseTreeNode, options);\n\n  // make the html attributes available to this widget\n  this.computeAttributes();\n}\n\n// !! EXTENSION !!\nMapConfigWidget.prototype = Object.create(_widget.widget.prototype);\n// !! EXTENSION !!\n\n/**\n * Method to render this widget into the DOM.\n *\n * @override\n */\nMapConfigWidget.prototype.render = function (parent, nextSibling) {\n\n  // remember our place in the dom\n  this.parentDomNode = parent;\n\n  if (!this.domNode) {\n    this.domNode = this.document.createElement('div');\n    $tw.utils.addClass(this.domNode, 'tmap-config-widget');\n    parent.insertBefore(this.domNode, nextSibling);\n  }\n\n  if (this.network) {\n\n    // destroy any previous instance\n    this.network.destroy();\n  }\n\n  // create container for vis configurator; destroyed when vis is destroyed\n  this.networkContainer = document.createElement('div');\n  this.domNode.appendChild(this.networkContainer);\n\n  // get environment\n  this.refreshTrigger = this.getAttribute('refresh-trigger');\n  this.pipeTRef = this.getVariable('currentTiddler');\n  this.inheritedFields = $tw.utils.parseStringArray(this.getAttribute('inherited'));\n  this.extensionTField = this.getAttribute('extension');\n  this.mode = this.getAttribute('mode');\n\n  // load inherited options\n  for (var i = 0; i < this.inheritedFields.length; i++) {\n    var fieldName = this.inheritedFields[i];\n    var style = _utils2.default.parseFieldData(this.pipeTRef, fieldName, {});\n\n    // maybe the inherited options also come without a top level property\n    // so we do the same here to…\n    // TODO looks clumsy; do it in a more generic way…\n    if (this.mode === 'manage-edge-types') {\n      if (!style.edges) {\n        style = { edges: style };\n      }\n    } else if (this.mode === 'manage-node-types') {\n      if (!style.nodes) {\n        style = { nodes: style };\n      }\n    }\n\n    this.inherited = _utils2.default.merge(this.inherited, style);\n  }\n\n  // load extension to the inherited options; since we store vis config\n  // for nodes and edges without the top level property, we may need to\n  // append it again, if not done so already.\n  this.extension = _utils2.default.parseFieldData(this.pipeTRef, this.extensionTField, {});\n  // TODO looks clumsy; do it in a more generic way…\n  if (this.mode === 'manage-edge-types') {\n    if (!this.extension.edges) {\n      this.extension = { edges: this.extension };\n    }\n  } else if (this.mode === 'manage-node-types') {\n    if (!this.extension.nodes) {\n      this.extension = { nodes: this.extension };\n    }\n  }\n\n  // we record all changes in a separate variable\n  var isSaveOnlyChanges = _utils2.default.isTrue(this.getAttribute('save-only-changes'));\n  this.changes = isSaveOnlyChanges ? {} : this.extension;\n\n  var data = { nodes: [], edges: [] };\n  var options = _utils2.default.merge({}, this.inherited, this.extension);\n  $tw.utils.extend(options, {\n    configure: {\n      enabled: true,\n      showButton: false,\n      filter: this.getOptionFilter(this.mode)\n    }\n  });\n\n  this.network = new _vis2.default.Network(this.networkContainer, data, options);\n  this.network.on('configChange', this.handleConfigChange.bind(this));\n\n  // giving the parent a css height will prevent it from jumping\n  // back when the network is destroyed and the network\n  // container is removed.\n  // fixes https://github.com/almende/vis/issues/1568\n  var height = this.parentDomNode.getBoundingClientRect().height;\n  this.parentDomNode.style['height'] = height + 'px';\n\n  var reset = this.handleResetEvent.bind(this);\n  this.networkContainer.addEventListener('reset', reset, false);\n\n  // register this graph at the caretaker's graph registry\n  $tm.registry.push(this);\n\n  this.enhanceConfigurator();\n};\n\n/**\n * I only receive the option that has actually changed\n */\nMapConfigWidget.prototype.handleResetEvent = function (ev) {\n  var change = {};\n  change[ev.detail.trigger.path] = null;\n  this.handleConfigChange(change);\n};\n\n/**\n * I only receive the option that has actually changed\n */\nMapConfigWidget.prototype.handleConfigChange = function (change) {\n\n  var flatChanges = _utils2.default.flatten(this.changes);\n  var flatChange = _utils2.default.flatten(change);\n  var confPath = Object.keys(_utils2.default.flatten(change))[0];\n  var isReset = flatChange[confPath] === null;\n\n  if (isReset) {\n    // we interpret this as delete\n\n    flatChanges[confPath] = undefined;\n    this.changes = _utils2.default.unflatten(flatChanges);\n  } else {\n\n    this.changes = _utils2.default.merge(this.changes, change);\n  }\n\n  // when storing edge- or node-styles we strip the root property\n  var options = _utils2.default.merge({}, this.changes);\n  if (this.mode === 'manage-node-types') {\n    options = options['nodes'];\n  }\n  if (this.mode === 'manage-edge-types') {\n    options = options['edges'];\n  }\n\n  // save changes\n  _utils2.default.writeFieldData(this.pipeTRef, this.extensionTField, options, $tm.config.sys.jsonIndentation);\n\n  // hack to ensure vis doesn't scroll\n  var cls = 'vis-configuration-wrapper';\n  var div = this.networkContainer.getElementsByClassName(cls)[0];\n  div.style.height = div.getBoundingClientRect().height + 'px';\n\n  if (isReset) {\n\n    // we need to use a timeout here, otherwise we cause a vis bug\n    // since it is in the middle of storing the value!\n    window.setTimeout(this.refresh.bind(this), 0);\n  } else {\n\n    // add active-config indicators\n    window.setTimeout(this.enhanceConfigurator.bind(this), 50);\n  }\n};\n\n/**\n * enhanceConfigurator over all config items and add an indicator.\n */\nMapConfigWidget.prototype.enhanceConfigurator = function () {\n\n  var cls = 'vis-configuration-wrapper';\n  var elements = this.networkContainer.getElementsByClassName(cls)[0].children;\n  var list = [];\n  var changes = _utils2.default.flatten(this.changes);\n  for (var i = 0; i < elements.length; i++) {\n    if (!elements[i].classList.contains('vis-config-item')) continue;\n\n    var conf = new VisConfElement(elements[i], list, i);\n    list.push(conf);\n\n    if (conf.level === 0) continue;\n\n    conf.setActive(!!changes[conf.path]);\n  }\n};\n\n/**\n *\n * @param {DOMElement} The config item element.\n * @param {Array<VisConfElement>} a list of VisConfElements of which\n *     this element is also part of.\n * @param {number} the position in the list\n */\nfunction VisConfElement(el, list, pos) {\n\n  var getByCls = 'getElementsByClassName';\n\n  this.el = el;\n  this.labelEl = el[getByCls]('vis-config-label')[0] || el[getByCls]('vis-config-header')[0] || el;\n  var labelText = this.labelEl.innerText || this.labelEl.textContent;\n  this.label = labelText && labelText.match(/([a-zA-Z0-9]+)/)[1];\n  this.level = parseInt(el.className.match(/.*vis-config-s(.).*/)[1]) || 0;\n\n  this.path = this.label;\n\n  if (this.level > 0) {\n    for (var i = pos; i--;) {\n      var prev = list[i];\n      if (prev.level < this.level) {\n        this.path = prev.path + '.' + this.path;\n        break;\n      }\n    }\n  }\n}\n\nVisConfElement.prototype.setActive = function (isEnable) {\n\n  if (!isEnable) return;\n\n  // cannot use utils.hasKeyWithPrefix because some keys start with\n  // same value as others\n  var cls = 'tmap-vis-config-item-' + (isEnable ? 'active' : 'inactive');\n  $tw.utils.addClass(this.el, cls);\n\n  if (isEnable) {\n\n    var button = document.createElement('button');\n    button.innerHTML = 'reset';\n    button.className = 'tmap-config-item-reset';\n\n    var self = this;\n\n    button.addEventListener('click', function (ev) {\n      ev.currentTarget.dispatchEvent(new CustomEvent('reset', {\n        detail: { trigger: self },\n        bubbles: true,\n        cancelable: true\n      }));\n    }, false);\n\n    this.el.appendChild(button);\n  }\n};\n\n/**\n *\n *\n */\nMapConfigWidget.prototype.getOptionFilter = function (mode) {\n\n  var whitelist = {\n    nodes: {\n      borderWidth: true,\n      borderWidthSelected: true,\n      color: {\n        background: true,\n        border: true\n      },\n      font: {\n        color: true,\n        size: true\n      },\n      icon: true,\n      labelHighlightBold: false,\n      shadow: true,\n      shape: true,\n      shapeProperties: {\n        borderDashes: true\n\n      },\n      size: true\n    },\n    edges: {\n      arrows: true,\n      color: true,\n      dashes: true,\n      font: true,\n      labelHighlightBold: false,\n      length: true,\n      selfReferenceSize: false,\n      shadow: true,\n      smooth: true,\n      width: true\n    },\n    interaction: {\n      hideEdgesOnDrag: true,\n      hideNodesOnDrag: true,\n      tooltipDelay: true\n    },\n    layout: {\n      hierarchical: false\n    },\n    manipulation: {\n      initiallyActive: true\n    },\n    physics: {\n      forceAtlas2Based: {\n        gravitationalConstant: true,\n        springLength: true,\n        springConstant: true,\n        damping: true,\n        centralGravity: true\n      }\n    }\n  };\n\n  if (mode === 'manage-edge-types') {\n    whitelist = { edges: whitelist.edges };\n  } else if (mode === 'manage-node-types') {\n    whitelist = { nodes: whitelist.nodes };\n  } else {\n    whitelist.edges.arrows = false;\n  }\n\n  return function (option, path) {\n\n    // operate on a clone; add option as element\n    path = path.concat([option]);\n\n    var wlObj = whitelist;\n    for (var i = 0, l = path.length; i < l; i++) {\n      if (wlObj[path[i]] === true) {\n        return true;\n      } else if (wlObj[path[i]] == null) {\n        return false;\n      } // else assume object\n      wlObj = wlObj[path[i]];\n    }\n\n    return false;\n  };\n};\n\n/**\n * A zombie widget is a widget that is removed from the dom tree\n * but still referenced or still partly executed -- I mean\n * otherwise you couldn't call this function, right?\n *\n * @TODO Outsource this as interface or common super class\n */\nMapConfigWidget.prototype.isZombieWidget = function () {\n\n  return !document.body.contains(this.parentDomNode);\n};\n\n/**\n * called from outside.\n *\n * @TODO Outsource this as interface or common super class\n */\nMapConfigWidget.prototype.destruct = function () {\n\n  if (this.network) {\n    this.network.destroy();\n  }\n};\n\n/**\n * This function is called by the system to notify the widget about\n * tiddler changes.\n *\n * @override\n */\nMapConfigWidget.prototype.refresh = function (changedTiddlers) {\n\n  if (this.isZombieWidget() || !this.network) return;\n\n  if (!changedTiddlers || changedTiddlers[this.refreshTrigger]) {\n    this.refreshSelf();\n    return true;\n  }\n};\n\nMapConfigWidget.prototype.setNull = function (obj) {\n\n  for (var p in obj) {\n\n    if (_typeof(obj[p]) == 'object') {\n\n      this.setNull(obj[p]);\n    } else {\n\n      obj[p] = undefined;\n    }\n  }\n};\n\n/*** Exports *******************************************************/\n\nexports['tmap-config'] = MapConfigWidget;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/widget/ConfigurationWidget.js.map\n",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/widget/EdgeListWidgetItem": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/widget/EdgeListWidgetItem",
            "text": "'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _widget = require('$:/core/modules/widgets/widget.js');\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/widget/EdgeListWidgetItem\ntype: application/javascript\nmodule-type: widget\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\n/*** Code **********************************************************/\n\nvar EdgeListItemWidget = function (_Widget) {\n  _inherits(EdgeListItemWidget, _Widget);\n\n  function EdgeListItemWidget(parseTreeNode, options) {\n    _classCallCheck(this, EdgeListItemWidget);\n\n    var _this = _possibleConstructorReturn(this, (EdgeListItemWidget.__proto__ || Object.getPrototypeOf(EdgeListItemWidget)).call(this, parseTreeNode, options));\n\n    _this.arrows = $tm.misc.arrows;\n\n    return _this;\n  }\n\n  _createClass(EdgeListItemWidget, [{\n    key: 'execute',\n    value: function execute() {\n\n      var item = this.parseTreeNode;\n      var tRef = $tm.tracker.getTiddlerById(item.neighbour.id);\n\n      // make edge properties available as variables\n      var edge = _utils2.default.flatten(item.edge);\n\n      for (var p in edge) {\n        if (typeof edge[p] === 'string') {\n          this.setVariable('edge.' + p, edge[p]);\n        }\n      }\n\n      // Perspective: Neighbour\n      this.setVariable('currentTiddler', tRef);\n      this.setVariable('neighbour', tRef);\n\n      var type = $tm.indeces.allETy[edge.type];\n      var indexedAs = edge.to === item.neighbour.id ? 'to' : 'from';\n      var arrow = indexedAs;\n\n      if (type.biArrow) {\n        arrow = 'bi';\n      } else {\n        if (indexedAs === 'to' && type.invertedArrow) {\n          arrow = 'from';\n        } else if (indexedAs === 'from' && type.invertedArrow) {\n          arrow = 'to';\n        }\n      }\n\n      this.setVariable('direction', arrow);\n      this.setVariable('directionSymbol', arrow === 'bi' ? this.arrows.bi : arrow === 'from' ? this.arrows.in : this.arrows.out);\n\n      // Construct the child widgets\n      this.makeChildWidgets();\n    }\n  }, {\n    key: 'refresh',\n    value: function refresh(changedTiddlers) {\n\n      return this.refreshChildren(changedTiddlers);\n    }\n  }]);\n\n  return EdgeListItemWidget;\n}(_widget.widget);\n\n/*** Exports *******************************************************/\n\nexports['tmap-edgelistitem'] = EdgeListItemWidget;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/widget/EdgeListItemWidget.js.map\n",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/widget/EdgeListWidget": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/widget/EdgeListWidget",
            "text": "'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _widget = require('$:/core/modules/widgets/widget.js');\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/widget/EdgeListWidget\ntype: application/javascript\nmodule-type: widget\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\n/*** Code **********************************************************/\n\nvar EdgeListWidget = function (_Widget) {\n  _inherits(EdgeListWidget, _Widget);\n\n  function EdgeListWidget(parseTreeNode, options) {\n    _classCallCheck(this, EdgeListWidget);\n\n    return _possibleConstructorReturn(this, (EdgeListWidget.__proto__ || Object.getPrototypeOf(EdgeListWidget)).call(this, parseTreeNode, options));\n  }\n\n  _createClass(EdgeListWidget, [{\n    key: 'render',\n    value: function render(parent, nextSibling) {\n\n      this.parentDomNode = parent;\n      this.computeAttributes();\n      this.execute();\n      this.renderChildren(parent, nextSibling);\n    }\n  }, {\n    key: 'execute',\n    value: function execute() {\n\n      var nodes = [this.getVariable('currentTiddler')];\n      var filter = this.getAttribute('filter', '');\n      var direction = this.getAttribute('direction', 'both');\n      var allETy = $tm.indeces.allETy;\n      var matches = _utils2.default.getEdgeTypeMatches(filter, allETy);\n\n      var options = {\n        typeWL: _utils2.default.getLookupTable(matches),\n        direction: direction\n      };\n\n      // retrieve nodes and edges\n\n      var _$tm$adapter$getNeigh = $tm.adapter.getNeighbours(nodes, options),\n          neighbours = _$tm$adapter$getNeigh.nodes,\n          edges = _$tm$adapter$getNeigh.edges;\n\n      var entries = [];\n      for (var id in edges) {\n\n        var edge = edges[id];\n        var neighbour = neighbours[edge.to] || neighbours[edge.from];\n\n        if (!neighbour) {\n          // obsolete edge from old times;\n          continue;\n        }\n\n        // make item template\n        entries.push({\n          type: 'tmap-edgelistitem',\n          edge: edge,\n          typeWL: options.typeWL,\n          neighbour: neighbour,\n          // the children of this widget (=what is wrapped inside the\n          // widget-element's body) is used as template for the list items\n          children: this.parseTreeNode.children\n        });\n      }\n\n      if (!entries.length) {\n\n        this.wasEmpty = true;\n        entries = this.getEmptyMessage();\n      } else if (this.wasEmpty) {\n\n        // we need to remove the empty message\n        this.removeChildDomNodes();\n      }\n\n      this.makeChildWidgets(entries);\n    }\n  }, {\n    key: 'getEmptyMessage',\n    value: function getEmptyMessage() {\n\n      var parser = this.wiki.parseText('text/vnd.tiddlywiki', this.getAttribute('emptyMessage', ''), { parseAsInline: true });\n\n      return parser ? parser.tree : [];\n    }\n  }, {\n    key: 'refresh',\n    value: function refresh(changedTiddlers) {\n\n      var changedAttributes = this.computeAttributes();\n\n      if (_utils2.default.hasElements(changedAttributes)) {\n\n        this.refreshSelf();\n\n        return true;\n      }\n\n      for (var tRef in changedTiddlers) {\n        if (!_utils2.default.isSystemOrDraft(tRef)) {\n\n          this.refreshSelf();\n\n          return true;\n        }\n      }\n\n      // let children decide for themselves\n      return this.refreshChildren(changedTiddlers);\n    }\n  }]);\n\n  return EdgeListWidget;\n}(_widget.widget);\n\n/*** Exports *******************************************************/\n\nexports['tmap-connections'] = EdgeListWidget;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/widget/EdgeListWidget.js.map\n",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/plugins/felixhayashi/tiddlymap/js/widget/MapWidget": {
            "title": "$:/plugins/felixhayashi/tiddlymap/js/widget/MapWidget",
            "text": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tiddlymap = exports.tmap = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _CallbackManager = require('$:/plugins/felixhayashi/tiddlymap/js/CallbackManager');\n\nvar _CallbackManager2 = _interopRequireDefault(_CallbackManager);\n\nvar _ViewAbstraction = require('$:/plugins/felixhayashi/tiddlymap/js/ViewAbstraction');\n\nvar _ViewAbstraction2 = _interopRequireDefault(_ViewAbstraction);\n\nvar _EdgeType = require('$:/plugins/felixhayashi/tiddlymap/js/EdgeType');\n\nvar _EdgeType2 = _interopRequireDefault(_EdgeType);\n\nvar _Popup = require('$:/plugins/felixhayashi/tiddlymap/js/Popup');\n\nvar _Popup2 = _interopRequireDefault(_Popup);\n\nvar _vis = require('$:/plugins/felixhayashi/vis/vis.js');\n\nvar _vis2 = _interopRequireDefault(_vis);\n\nvar _widget = require('$:/core/modules/widgets/widget.js');\n\nvar _utils = require('$:/plugins/felixhayashi/tiddlymap/js/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _SelectionRectangle = require('$:/plugins/felixhayashi/tiddlymap/js/lib/SelectionRectangle');\n\nvar _SelectionRectangle2 = _interopRequireDefault(_SelectionRectangle);\n\nvar _environment = require('$:/plugins/felixhayashi/tiddlymap/js/lib/environment');\n\nvar env = _interopRequireWildcard(_environment);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // @preserve\n/*\\\n\ntitle: $:/plugins/felixhayashi/tiddlymap/js/widget/MapWidget\ntype: application/javascript\nmodule-type: widget\n\n@preserve\n\n\\*/\n\n/*** Imports *******************************************************/\n\n/*** Code **********************************************************/\n\n/**\n * The map widget is responsible for drawing the actual network\n * diagrams.\n *\n * @constructor\n */\nvar MapWidget = function (_Widget) {\n  _inherits(MapWidget, _Widget);\n\n  function MapWidget(parseTreeNode, options) {\n    _classCallCheck(this, MapWidget);\n\n    // create shortcuts for services and frequently used vars\n    var _this = _possibleConstructorReturn(this, (MapWidget.__proto__ || Object.getPrototypeOf(MapWidget)).call(this, parseTreeNode, options));\n\n    _this.getAttr = _this.getAttribute;\n    _this.isDebug = _utils2.default.isTrue($tm.config.sys.debug, false);\n\n    // force early binding of functions to this context\n    _utils2.default.bindTo(_this, ['constructTooltip', 'handleResizeEvent', 'handleClickEvent', 'handleCanvasKeyup', 'handleCanvasKeydown', 'handleCanvasScroll', 'handleCanvasMouseMove', 'handleWidgetKeyup', 'handleWidgetKeydown', 'handleTriggeredRefresh', 'handleContextMenu']);\n\n    // instanciate managers\n    _this.callbackManager = new _CallbackManager2.default();\n\n    // make the html attributes available to this widget\n    _this.computeAttributes();\n    _this.editorMode = _this.getAttr('editor');\n    _this.clickToUse = _utils2.default.isTrue(_this.getAttr('click-to-use'), false);\n\n    // who am I? the id is used for debugging and special cases\n    _this.id = _this.getAttr('object-id') || _this.getStateQualifier();\n\n    _this.widgetPopupsPath = $tm.path.tempPopups + '/' + _this.id;\n\n    // register listeners that are available in editor mode\n    if (_this.editorMode) {\n      _utils2.default.addTWlisteners({\n        'tmap:tm-create-view': _this.handleCreateView,\n        'tmap:tm-rename-view': _this.handleRenameView,\n        'tmap:tm-delete-view': _this.handleDeleteView,\n        'tmap:tm-delete-element': _this.handleDeleteElement,\n        'tmap:tm-edit-view': _this.handleEditView,\n        'tmap:tm-generate-widget': _this.handleGenerateWidget,\n        'tmap:tm-toggle-central-topic': _this.handleSetCentralTopic,\n        'tmap:tm-save-canvas': _this.handleSaveCanvas\n      }, _this, _this);\n    }\n\n    // register listeners that are available in any case\n    _utils2.default.addTWlisteners({\n      'tmap:tm-focus-node': _this.handleFocusNode,\n      'tmap:tm-reset-focus': _this.repaintGraph\n    }, _this, _this);\n\n    // Visjs handlers\n    _this.visListeners = {\n      'click': _this.handleVisSingleClickEvent,\n      'doubleClick': _this.handleVisDoubleClickEvent,\n      'stabilized': _this.handleVisStabilizedEvent,\n      'selectNode': _this.handleVisSelectNode,\n      'deselectNode': _this.handleVisDeselectNode,\n      'dragStart': _this.handleVisDragStart,\n      'dragEnd': _this.handleVisDragEnd,\n      'hoverNode': _this.handleVisHoverElement,\n      'hoverEdge': _this.handleVisHoverElement,\n      'blurNode': _this.handleVisBlurElement,\n      'blurEdge': _this.handleVisBlurElement,\n      'beforeDrawing': _this.handleVisBeforeDrawing,\n      'afterDrawing': _this.handleVisAfterDrawing,\n      'stabilizationProgress': _this.handleVisLoading,\n      'stabilizationIterationsDone': _this.handleVisLoadingDone\n    };\n\n    _this.windowDomListeners = {\n      'resize': [_this.handleResizeEvent, false],\n      'click': [_this.handleClickEvent, false],\n      'mousemove': [_this.handleCanvasMouseMove, true]\n    };\n\n    _this.canvasDomListeners = {\n      'keyup': [_this.handleCanvasKeyup, true],\n      'keydown': [_this.handleCanvasKeydown, true],\n      'mousewheel': [_this.handleCanvasScroll, true],\n      'DOMMouseScroll': [_this.handleCanvasScroll, true],\n      'contextmenu': [_this.handleContextMenu, true]\n    };\n\n    _this.widgetDomListeners = {\n      'keyup': [_this.handleWidgetKeyup, true],\n      'keydown': [_this.handleWidgetKeydown, true]\n    };\n\n    _this.conVector = { from: null, to: null };\n    return _this;\n  }\n\n  /**\n   * This handler will open a dialog that allows the user to create a\n   * new relation between two edges. This includes, that the user\n   * gets a chance to specify the edgetype of the connection.\n   *\n   * If an edge-type namespace has been declared for the entire view,\n   * then add it to the `id` of the specified type…\n   *   - …if the type doesn't exist yet.\n   *   - …if the type doesn't contain a namespace already, regardless\n   *     whether it exists or not.\n   *\n   * Once the user confirmed the dialog, the edge is persisted.\n   *\n   * Note: this should not trigger a zoom.\n   *\n   * @param {Edge} edge - A javascript object that contains at least\n   *    the properties 'from' and 'to'\n   * @param {function} [callback] - A function with the signature\n   *    function(isConfirmed);\n   */\n\n\n  _createClass(MapWidget, [{\n    key: 'handleConnectionEvent',\n    value: function handleConnectionEvent(edge, callback) {\n      var _this2 = this;\n\n      var eTyFilter = this.view.getEdgeTypeFilter();\n\n      var param = {\n        fromLabel: $tm.adapter.selectNodeById(edge.from).label,\n        toLabel: $tm.adapter.selectNodeById(edge.to).label,\n        view: this.view.getLabel(),\n        eTyFilter: eTyFilter.raw\n      };\n\n      $tm.dialogManager.open('getEdgeType', param, function (isConfirmed, outTObj) {\n\n        if (isConfirmed) {\n\n          var str = _utils2.default.getText(outTObj);\n          var type = _EdgeType2.default.getInstance(str);\n\n          if (!type.namespace) {\n            var _EdgeType$getIdParts = _EdgeType2.default.getIdParts(type.id),\n                marker = _EdgeType$getIdParts.marker,\n                name = _EdgeType$getIdParts.name;\n\n            var namespace = _this2.view.getConfig('edge_type_namespace');\n            type = _EdgeType2.default.getInstance(_EdgeType2.default.getId(marker, namespace, name));\n          }\n\n          // persist the type if it doesn't exist\n          if (!type.exists()) {\n            type.save();\n          }\n\n          // add type to edge\n          edge.type = type.id;\n          $tm.adapter.insertEdge(edge);\n\n          // prevent zoom\n          _this2.isPreventZoomOnNextUpdate = true;\n\n          if (!_this2.view.isEdgeTypeVisible(type)) {\n\n            $tm.dialogManager.open('edgeNotVisible', {\n              type: type.id,\n              view: _this2.view.getLabel(),\n              eTyFilter: eTyFilter.pretty\n            });\n          }\n        }\n\n        if (typeof callback === 'function') {\n          callback(isConfirmed);\n        }\n      });\n    }\n\n    /**\n     * The first time a map is opened, we want to display a welcome message.\n     * Once shown, a flag is set and the message is not displayed again.\n     */\n\n  }, {\n    key: 'checkForFreshInstall',\n    value: function checkForFreshInstall() {\n\n      if (!_utils2.default.getEntry($tm.ref.sysMeta, 'showWelcomeMessage', true)) {\n        return;\n      }\n\n      _utils2.default.setEntry($tm.ref.sysMeta, 'showWelcomeMessage', false);\n\n      var args = {\n        dialog: {\n          preselects: {\n            \"config.storyview\": \"true\",\n            \"config.navigation\": \"true\",\n            \"config.sidebar\": \"true\",\n            \"config.demo\": \"true\"\n          }\n        }\n      };\n\n      $tm.dialogManager.open('welcome', args, function (isConfirmed, outTObj) {\n\n        var config = _utils2.default.getPropertiesByPrefix(outTObj.fields, 'config.', true);\n\n        if (config['storyview'] && _utils2.default.tiddlerExists('$:/plugins/felixhayashi/topstoryview')) {\n          _utils2.default.setText('$:/view', 'top');\n        }\n\n        if (config['navigation']) {\n          _utils2.default.setText('$:/config/Navigation/openLinkFromInsideRiver', 'above');\n          _utils2.default.setText('$:/config/Navigation/openLinkFromOutsideRiver', 'top');\n        }\n\n        if (config['sidebar']) {\n          _utils2.default.setText('$:/themes/tiddlywiki/vanilla/options/sidebarlayout', 'fixed-fluid');\n        }\n\n        if (config['demo']) {\n          var view = $tm.misc.defaultViewLabel;\n\n          var n1 = $tm.adapter.insertNode({ label: 'Have fun with', x: 0, y: 0 }, view);\n          var n2 = $tm.adapter.insertNode({ label: 'TiddlyMap!!', x: 100, y: 100 }, view);\n\n          $tm.adapter.insertEdge({ from: n1.id, to: n2.id });\n        }\n\n        if (Object.keys(config).length) {\n          // trigger a save and reload message\n          _utils2.default.touch('$:/plugins/felixhayashi/tiddlymap');\n        }\n      });\n    }\n\n    /**\n     * A very basic dialog that will tell the user he/she has to make\n     * a choice.\n     *\n     * @param {function} [callback] - A function with the signature\n     *     function(isConfirmed).\n     * @param {string} [message] - An small optional message to display.\n     */\n\n  }, {\n    key: 'openStandardConfirmDialog',\n    value: function openStandardConfirmDialog(callback, message) {\n\n      var param = { message: message };\n      $tm.dialogManager.open('getConfirmation', param, callback);\n    }\n\n    /**\n     * An extention of the default logger mechanism. It works like\n     * `this.logger` but will include the object id of the widget\n     * instance.\n     *\n     * @param {string} type - The type of the message (debug, info, warning…)\n     *     which is exactly the same as in `console[type]`.\n     * @param {...*} message - An infinite number of arguments to be printed\n     *     (just like console).\n     */\n\n  }, {\n    key: 'logger',\n    value: function logger(type, message /*, more stuff*/) {\n\n      if (this.isDebug) {\n\n        var args = Array.prototype.slice.call(arguments, 1);\n        args.unshift('@' + this.id);\n        args.unshift(type);\n        $tm.logger.apply(this, args);\n      }\n    }\n\n    /**\n     * Method to render this widget into the DOM.\n     *\n     * Note that we do not add this.domNode to the list of domNodes\n     * since this widget does never remove itself during a refresh.\n     *\n     * @override\n     */\n\n  }, {\n    key: 'render',\n    value: function render(parent, nextSibling) {\n\n      this.parentDomNode = parent;\n\n      this.domNode = this.document.createElement('div');\n      parent.insertBefore(this.domNode, nextSibling);\n\n      // add widget classes\n      this.registerClassNames(this.domNode);\n\n      // get view and view holder\n      this.viewHolderRef = this.getViewHolderRef();\n      this.view = this.getView();\n\n      // create the header div\n      this.graphBarDomNode = this.document.createElement('div');\n      $tw.utils.addClass(this.graphBarDomNode, 'tmap-topbar');\n      this.domNode.appendChild(this.graphBarDomNode);\n\n      // create body div\n      this.graphDomNode = this.document.createElement('div');\n      this.domNode.appendChild(this.graphDomNode);\n\n      $tw.utils.addClass(this.graphDomNode, 'tmap-vis-graph');\n\n      if (_utils2.default.isPreviewed(this)) {\n\n        $tw.utils.addClass(this.domNode, 'tmap-static-mode');\n        this.renderPreview(this.graphBarDomNode, this.graphDomNode);\n      } else {\n\n        // render the full widget\n        this.renderFullWidget(this.domNode, this.graphBarDomNode, this.graphDomNode);\n      }\n    }\n\n    /**\n     * When the widget is only previewed we do some alternative rendering.\n     */\n\n  }, {\n    key: 'renderPreview',\n    value: function renderPreview(header, body) {\n\n      var snapshotTRef = this.view.getRoot() + '/snapshot';\n      var snapshotTObj = _utils2.default.getTiddler(snapshotTRef);\n\n      var label = this.document.createElement('span');\n      label.innerHTML = this.view.getLabel();\n      label.className = 'tmap-view-label';\n      header.appendChild(label);\n\n      if (snapshotTObj) {\n\n        // Construct child widget tree\n        var placeholder = this.makeChildWidget(_utils2.default.getTranscludeNode(snapshotTRef), true);\n        placeholder.renderChildren(body, null);\n      } else {\n\n        $tw.utils.addClass(body, 'tmap-graph-placeholder');\n      }\n    }\n\n    /**\n     * The standard way of rendering.\n     * Attention: BE CAREFUL WITH THE ORDER OF FUNCTION CALLS IN THIS FUNCTION.\n     */\n\n  }, {\n    key: 'renderFullWidget',\n    value: function renderFullWidget(widget, header, body) {\n\n      // add window and widget dom node listeners\n      _utils2.default.setDomListeners('add', window, this.windowDomListeners);\n      _utils2.default.setDomListeners('add', widget, this.widgetDomListeners);\n\n      // add a loading bar\n      this.addLoadingBar(this.domNode);\n\n      // prepare the tooltip for graph elements\n      this.tooltip = new _Popup2.default(this.domNode, {\n        className: 'tmap-tooltip',\n        showDelay: $tm.config.sys.popups.delay\n      });\n\n      // prepare the context menu\n      this.contextMenu = new _Popup2.default(this.domNode, {\n        className: 'tmap-context-menu',\n        showDelay: 0,\n        hideOnClick: true,\n        leavingDelay: 999999\n      });\n\n      // register\n      this.sidebar = _utils2.default.getFirstElementByClassName('tc-sidebar-scrollable');\n      this.isInSidebar = this.sidebar && !this.domNode.isTiddlyWikiFakeDom && this.sidebar.contains(this.domNode);\n\n      // *first* inject the bar\n      this.rebuildEditorBar(header);\n\n      // *second* initialise graph variables and render the graph\n      this.initAndRenderGraph(body);\n\n      // register this graph at the caretaker's graph registry\n      $tm.registry.push(this);\n\n      // if any refresh-triggers exist, register them\n      this.reloadRefreshTriggers();\n\n      // maybe display a welcome message\n      this.checkForFreshInstall();\n\n      if (this.id === $tm.misc.mainEditorId) {\n\n        var url = $tm.url;\n        if (url && url.query['tmap-enlarged']) {\n\n          this.toggleEnlargedMode(url.query['tmap-enlarged']);\n          //~ this.setView(url.query['tmap-view']);\n        }\n      }\n    }\n\n    /**\n     * Add some classes to give the user a chance to apply some css\n     * to different graph modes.\n     */\n\n  }, {\n    key: 'registerClassNames',\n    value: function registerClassNames(parent) {\n\n      var addClass = $tw.utils.addClass;\n\n      // add main class\n      addClass(parent, 'tmap-widget');\n\n      if (this.clickToUse) {\n        addClass(parent, 'tmap-click-to-use');\n      }\n\n      if (this.getAttr('editor') === 'advanced') {\n        addClass(parent, 'tmap-advanced-editor');\n      }\n\n      if (this.getAttr('design') === 'plain') {\n        addClass(parent, 'tmap-plain-design');\n      }\n\n      if (!_utils2.default.isTrue(this.getAttr('show-buttons'), true)) {\n        addClass(parent, 'tmap-no-buttons');\n      }\n\n      if (this.getAttr('class')) {\n        addClass(parent, this.getAttr('class'));\n      }\n    }\n\n    /**\n     * Adds a loading bar div below the parent.\n     */\n\n  }, {\n    key: 'addLoadingBar',\n    value: function addLoadingBar(parent) {\n\n      this.graphLoadingBarDomNode = this.document.createElement('progress');\n      $tw.utils.addClass(this.graphLoadingBarDomNode, 'tmap-loading-bar');\n      parent.appendChild(this.graphLoadingBarDomNode);\n    }\n\n    /**\n     * The editor bar contains a bunch of widgets that allow the user\n     * to manipulate the current view.\n     *\n     * Attention: The Editor bar needs to render *after* the graph\n     * because some elements depend on the graph's nodes which are\n     * calculated when the network is created.\n     *\n     * @see https://groups.google.com/forum/#!topic/tiddlywikidev/sJrblP4A0o4\n     * @see blob/master/editions/test/tiddlers/tests/test-wikitext-parser.js\n     */\n\n  }, {\n    key: 'rebuildEditorBar',\n    value: function rebuildEditorBar() {\n\n      this.removeChildDomNodes();\n\n      // register dialog variables\n\n      var view = this.view;\n\n      var unicodeBtnClass = 'tmap-unicode-button';\n      var activeUnicodeBtnClass = unicodeBtnClass + ' tmap-active-button';\n      var variables = {\n        widgetQualifier: this.getStateQualifier(),\n        widgetTempPath: this.widgetTempPath,\n        widgetPopupsPath: this.widgetPopupsPath,\n        isViewBound: String(this.isViewBound()),\n        viewRoot: view.getRoot(),\n        viewLabel: view.getLabel(),\n        viewHolder: this.getViewHolderRef(),\n        edgeTypeFilter: view.edgeTypeFilterTRef,\n        allEdgesFilter: $tm.selector.allEdgeTypes,\n        neighScopeBtnClass: view.isEnabled('neighbourhood_scope') ? activeUnicodeBtnClass : unicodeBtnClass,\n        rasterMenuBtnClass: view.isEnabled('raster') ? activeUnicodeBtnClass : unicodeBtnClass\n      };\n\n      for (var name in variables) {\n        this.setVariable(name, variables[name]);\n      }\n\n      // Construct the child widget tree\n      var body = _utils2.default.getTiddlerNode(view.getRoot());\n\n      if (this.editorMode === 'advanced') {\n\n        body.children.push(_utils2.default.getTranscludeNode($tm.ref.graphBar));\n      } else {\n\n        var el = _utils2.default.getElementNode('span', 'tmap-view-label', view.getLabel());\n        body.children.push(el);\n      }\n\n      body.children.push(_utils2.default.getTranscludeNode($tm.ref.focusButton));\n\n      this.makeChildWidgets([body]);\n      this.renderChildren(this.graphBarDomNode, this.graphBarDomNode.firstChild);\n    }\n\n    /**\n     * This function is called by the system to notify the widget about\n     * tiddler changes. It is ignored by TiddlyMap.\n     *\n     * ATTENTION: TiddlyMap doesn't use the refresh mechanism here.\n     * The caretaker module dispatches an `updates` object that provides\n     * more advanced information, tailored to the needs of TiddlyMap.\n     * These updates are picked up by {@link MapWidget#update}.\n     *\n     * @override\n     */\n\n  }, {\n    key: 'refresh',\n    value: function refresh(changedTiddlers) {\n\n      // TiddlyMap never needs a full refresh so we return false\n      return false;\n    }\n\n    /**\n     * This function is called by the caretaker module to notify the\n     * widget about tiddler changes.\n     *\n     * TiddlyMap is interested in the following changes:\n     *\n     * - Callbacks have been triggered (e.g. dialog results)\n     * - A view has been switched\n     * - A view has been modified (= configured)\n     * - Global options have changed\n     * - Node- or edge-types have changed\n     * - Graph elements have changed\n     * - Changes to the graph's topbar\n     *\n     * @override\n     * @see https://groups.google.com/d/msg/tiddlywikidev/hwtX59tKsIk/EWSG9glqCnsJ\n     */\n\n  }, {\n    key: 'update',\n    value: function update(updates) {\n\n      if (!this.network || this.isZombieWidget() || _utils2.default.isPreviewed(this)) {\n        return;\n      }\n\n      var changedTiddlers = updates.changedTiddlers;\n\n      // check for callback changes\n\n      this.callbackManager.refresh(changedTiddlers);\n\n      if (this.isViewSwitched(changedTiddlers) || this.hasChangedAttributes() // widget html code changed\n      || updates[env.path.options] // global options changed\n      || changedTiddlers[this.view.getRoot()] // view's main config changed\n      ) {\n\n          this.logger('warn', 'View switched config changed');\n\n          this.isPreventZoomOnNextUpdate = false;\n          this.view = this.getView(true);\n          this.reloadRefreshTriggers();\n          this.rebuildEditorBar();\n          this.reloadBackgroundImage();\n          this.initAndRenderGraph(this.graphDomNode);\n        } else {\n        // view has not been switched\n\n        // give the view a chance to refresh itself\n        var isViewUpdated = this.view.update(updates);\n\n        if (isViewUpdated) {\n\n          this.logger('warn', 'View components modified');\n          this.rebuildGraph({ resetFocus: { delay: 1000, duration: 1000 } });\n        } else {\n          // neither view switch or view modification\n\n          if (updates[env.path.nodeTypes] || this.hasChangedElements(changedTiddlers)) {\n            this.rebuildGraph();\n          }\n\n          // give children a chance to update themselves\n          this.refreshChildren(changedTiddlers);\n        }\n      }\n    }\n  }, {\n    key: 'hidePopups',\n    value: function hidePopups(delay, isForce) {\n\n      this.tooltip.hide(delay, isForce);\n      this.contextMenu.hide(0, true);\n    }\n\n    /**\n     * Refresh-triggers are tiddlers whose mere occurrence in the\n     * changedTiddlers list forces tiddlymap to reassert\n     * whether a filter expression returns the same set of matches as it\n     * is currently displayed in the graph.\n     *\n     * The raison d'etre for refresh-triggers is that a filter may contain\n     * implicit text-references or variables that may require a filter to be\n     * reasserted even though, the filter expression itself did not change.\n     *\n     * For example a filter `[field:title{$:/HistoryList!!current-tiddler}]`\n     * requires a `$:/HistoryList` refresh trigger to be added to the view so\n     * everytime the `$:/HistoryList` tiddler changes, the filter gets\n     * reasserted.\n     */\n\n  }, {\n    key: 'reloadRefreshTriggers',\n    value: function reloadRefreshTriggers() {\n\n      // remove old triggers (if there are any)\n      this.callbackManager.remove(this.refreshTriggers);\n\n      // load new trigger list either from attribute or view config\n      var str = this.getAttr('refresh-triggers') || this.view.getConfig('refresh-triggers');\n      this.refreshTriggers = $tw.utils.parseStringArray(str) || [];\n\n      this.logger('debug', 'Registering refresh trigger', this.refreshTriggers);\n\n      // TODO: not nice, if more than one trigger changed it\n      // will cause multiple reassertments\n      for (var i = this.refreshTriggers.length; i--;) {\n        this.callbackManager.add(this.refreshTriggers[i], this.handleTriggeredRefresh, false);\n      }\n    }\n\n    /**\n     * Calling this method will cause the graph to be rebuild, which means\n     * the graph data is refreshed. A rebuild of the graph will always\n     * cause the network to stabilize again.\n     *\n     * @param {Hashmap} [resetFocus=null] - If not false or null,\n     *     this object requires two properties to be set: `delay` (the\n     *     time to wait before starting the fit), `duration` (the length\n     *     of the fit animation).\n     */\n\n  }, {\n    key: 'rebuildGraph',\n    value: function rebuildGraph() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          resetFocus = _ref.resetFocus;\n\n      if (_utils2.default.isPreviewed(this)) {\n\n        return;\n      }\n\n      this.logger('debug', 'Rebuilding graph');\n\n      this.hidePopups(0, true);\n\n      // always reset to allow handling of stabilized-event!\n      this.hasNetworkStabilized = false;\n\n      var changes = this.rebuildGraphData();\n\n      if (changes.changedNodes.withoutPosition.length) {\n\n        // force resetFocus\n        resetFocus = resetFocus || { delay: 1000, duration: 1000 };\n\n        if (!this.view.isEnabled('physics_mode')) {\n\n          // in static mode we need to ensure that objects spawn\n          // near center so we need to set physics from\n          // zero to something. Yes, we override the users\n          // central gravity value… who cares about central\n          // gravity in static mode anyways.\n          var physics = this.visOptions.physics;\n          physics[physics.solver].centralGravity = 0.25;\n          this.network.setOptions(this.visOptions);\n        }\n      }\n\n      if (!_utils2.default.hasElements(this.graphData.nodesById)) {\n        return;\n      }\n\n      if (resetFocus) {\n\n        if (!this.isPreventZoomOnNextUpdate) {\n\n          // see https://github.com/almende/vis/issues/987#issuecomment-113226216\n          // see https://github.com/almende/vis/issues/939\n          this.network.stabilize();\n          this.resetFocus = resetFocus;\n        }\n\n        this.isPreventZoomOnNextUpdate = false;\n      }\n    }\n\n    /**\n     * WARNING: Do not change this functionname as it is used by the\n     * caretaker's routinely checkups.\n     */\n\n  }, {\n    key: 'getContainer',\n    value: function getContainer() {\n\n      return this.domNode;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'rebuildGraphData',\n    value: function rebuildGraphData() {\n\n      $tm.start('Reloading Network');\n\n      var graph = $tm.adapter.getGraph({ view: this.view });\n\n      var changedNodes = _utils2.default.refreshDataSet(this.graphData.nodes, // dataset\n      graph.nodes // new nodes\n      );\n\n      var changedEdges = _utils2.default.refreshDataSet(this.graphData.edges, // dataset\n      graph.edges // new edges\n      );\n\n      // create lookup tables\n\n      this.graphData.nodesById = graph.nodes;\n      this.graphData.edgesById = graph.edges;\n\n      // TODO: that's a performance killer. this should be loaded when\n      // the search is actually used!\n      // update: Careful when refactoring, some modules are using this…\n      _utils2.default.setField('$:/temp/tmap/nodes/' + this.view.getLabel(), 'list', $tm.adapter.getTiddlersByIds(graph.nodes));\n\n      $tm.stop('Reloading Network');\n\n      return { changedEdges: changedEdges, changedNodes: changedNodes };\n    }\n  }, {\n    key: 'isViewBound',\n    value: function isViewBound() {\n\n      return _utils2.default.startsWith(this.getViewHolderRef(), $tm.path.localHolders);\n    }\n\n    /**\n     * A view is switched, if the holder was changed.\n     * Also if a view suddenly doesn't exist anymore we consider this\n     * a trigger for a view change.\n     */\n\n  }, {\n    key: 'isViewSwitched',\n    value: function isViewSwitched(changedTiddlers) {\n\n      return !_ViewAbstraction2.default.exists(this.view) || changedTiddlers[this.getViewHolderRef()];\n    }\n\n    /**\n     * A view is switched, if the holder was changed.\n     */\n\n  }, {\n    key: 'hasChangedAttributes',\n    value: function hasChangedAttributes() {\n\n      return Object.keys(this.computeAttributes()).length;\n    }\n\n    /**\n     * Rebuild or update the graph if one of the following is true:\n     *\n     * 1. A tiddler currently contained as node in the graph has been\n     *    deleted or modified. This also includes tiddlers that are\n     *    represented as neighbours in the graph.\n     * 2. The neighbourhood is shown and a non-system tiddler has changed.\n     * 3. A tiddler that matches the node filter has been modified\n     *    (not deleted).\n     *\n     * Since edges are stored in tiddlers themselves, any edge modification\n     * is always accounted for as in this case the tiddler holding the\n     * edge would be included as changed tiddler.\n     *\n     * @param {Hashmap<TiddlerReference, *>} changedTiddlers - A list of\n     *     tiddler changes.\n     *\n     * @return {boolean} true if the graph needs a refresh.\n     */\n\n  }, {\n    key: 'hasChangedElements',\n    value: function hasChangedElements(changedTiddlers) {\n\n      var maybeMatches = [];\n      var inGraph = this.graphData.nodesById;\n      var isShowNeighbourhood = this.view.isEnabled('neighbourhood_scope');\n\n      for (var tRef in changedTiddlers) {\n\n        if (_utils2.default.isSystemOrDraft(tRef)) {\n\n          continue;\n        }\n\n        if (inGraph[$tm.adapter.getId(tRef)] || isShowNeighbourhood) {\n\n          return true;\n        }\n\n        if (changedTiddlers[tRef].modified) {\n          // may be a match so we store this and process it later\n          maybeMatches.push(tRef);\n        }\n      }\n\n      if (maybeMatches.length) {\n\n        var nodeFilter = this.view.getNodeFilter('compiled');\n        var matches = _utils2.default.getMatches(nodeFilter, maybeMatches);\n\n        return !!matches.length;\n      }\n    }\n\n    /**\n     * Rebuild the graph\n     *\n     * @see http://visjs.org/docs/network.html\n     * @see http://visjs.org/docs/dataset.html\n     */\n\n  }, {\n    key: 'initAndRenderGraph',\n    value: function initAndRenderGraph(parent) {\n      var _this3 = this;\n\n      // make sure to destroy any previous instance\n      if (this.network) {\n        this._destructVis();\n      }\n\n      this.logger('info', 'Initializing and rendering the graph');\n\n      if (!this.isInSidebar) {\n        this.callbackManager.add('$:/state/sidebar', this.handleResizeEvent);\n      }\n\n      this.visOptions = this.getVisOptions();\n\n      this.graphData = {\n        nodes: new _vis2.default.DataSet(),\n        edges: new _vis2.default.DataSet(),\n        nodesById: _utils2.default.makeHashMap(),\n        edgesById: _utils2.default.makeHashMap()\n      };\n\n      this.tooltip.setEnabled(_utils2.default.isTrue($tm.config.sys.popups.enabled, true));\n\n      this.network = new _vis2.default.Network(parent, this.graphData, this.visOptions);\n      // after vis.Network has been instantiated, we fetch a reference to\n      // the canvas element\n      this.canvas = parent.getElementsByTagName('canvas')[0];\n      this.networkDomNode = _utils2.default.getFirstElementByClassName('vis-network', parent, true);\n      // just to be sure\n      this.canvas.tabIndex = 0;\n\n      for (var event in this.visListeners) {\n        this.network.on(event, this.visListeners[event].bind(this));\n      }\n\n      this.addGraphButtons({\n        'fullscreen-button': function fullscreenButton() {\n          _this3.toggleEnlargedMode('fullscreen');\n        },\n        'halfscreen-button': function halfscreenButton() {\n          _this3.toggleEnlargedMode('halfscreen');\n        }\n      });\n\n      _utils2.default.setDomListeners('add', this.canvas, this.canvasDomListeners);\n\n      this.reloadBackgroundImage();\n      this.rebuildGraph({\n        resetFocus: { delay: 0, duration: 0 }\n      });\n      this.handleResizeEvent();\n      this.canvas.focus();\n    }\n  }, {\n    key: 'handleCanvasKeyup',\n    value: function handleCanvasKeyup(ev) {\n      var _this4 = this;\n\n      var nodeIds = this.network.getSelectedNodes();\n\n      // this.isCtrlKeyDown = ev.ctrlKey;\n\n      if (ev.ctrlKey) {\n        // ctrl key is hold down\n        ev.preventDefault();\n\n        if (ev.keyCode === 88) {\n          // x\n          if (this.editorMode) {\n            this.handleAddNodesToClipboard('move');\n          } else {\n            $tm.notify('Map is read only!');\n          }\n        } else if (ev.keyCode === 67) {\n          // c\n          this.handleAddNodesToClipboard('copy');\n        } else if (ev.keyCode === 86) {\n          // v\n          this.handlePasteNodesFromClipboard();\n        } else if (ev.keyCode === 65) {\n          // a\n          var allNodes = Object.keys(this.graphData.nodesById);\n          this.network.selectNodes(allNodes);\n        } else if (ev.keyCode === 49 || ev.keyCode === 50) {\n          // 1 || 2\n          if (nodeIds.length !== 1) return;\n\n          var role = ev.keyCode === 49 ? 'from' : 'to';\n          $tm.notify(_utils2.default.ucFirst(role) + '-part selected');\n\n          this.conVector[role] = nodeIds[0];\n          if (this.conVector.from && this.conVector.to) {\n            // create the edge\n            this.handleConnectionEvent(this.conVector, function () {\n              // reset both properties, regardless whether confirmed\n              _this4.conVector = { from: null, to: null };\n            });\n          }\n        }\n      } else {\n        // ctrl is not pressed\n\n        if (ev.keyCode === 13) {\n          // ENTER\n\n          if (nodeIds.length !== 1) return;\n\n          this.openTiddlerWithId(nodeIds[0]);\n        }\n      }\n    }\n  }, {\n    key: 'handleCanvasKeydown',\n    value: function handleCanvasKeydown(ev) {\n\n      if (ev.keyCode === 46) {\n        // delete\n        ev.preventDefault();\n        this.handleRemoveElements(this.network.getSelection());\n      }\n    }\n  }, {\n    key: 'handleDeleteElement',\n    value: function handleDeleteElement(ev) {\n\n      var id = ev.paramObject.id;\n      var elements = id ? [id] : this.network.getSelectedNodes();\n\n      this.handleRemoveElements({ nodes: elements });\n    }\n\n    /**\n     *\n     * @param ev\n     */\n\n  }, {\n    key: 'handleCanvasMouseMove',\n    value: function handleCanvasMouseMove(ev) {\n      var network = this.network;\n\n\n      if (!(ev.ctrlKey && ev.buttons)) {\n\n        if (this.selectRect) {\n          this.selectRect = null;\n          var _selectedNodes = network.getSelectedNodes();\n          $tm.notify(_selectedNodes.length + ' nodes selected');\n          network.redraw();\n        }\n\n        return;\n      }\n\n      // prevent vis' network drag if ctrl key and mouse button is pressed\n      ev.preventDefault();\n      ev.stopPropagation();\n\n      if (!this.domNode.contains(ev.target)) {\n        // since we are using a global mouse listener, we need to check whether\n        // we are actually inside our widget, so we stop updating the selectRect\n        return;\n      }\n\n      var mouse = network.DOMtoCanvas({ x: ev.offsetX, y: ev.offsetY });\n\n      if (!this.selectRect) {\n        this.selectRect = new _SelectionRectangle2.default(mouse.x, mouse.y);\n      }\n\n      // register new coordinates\n      this.selectRect.span(mouse.x, mouse.y);\n      // retrieve current mouse positions\n      var nodePositions = network.getPositions();\n      // we include previously selected nodes in the new set\n      var selectedNodes = network.getSelectedNodes();\n\n      for (var id in nodePositions) {\n\n        if (this.selectRect.isPointWithin(nodePositions[id]) && !_utils2.default.inArray(id, selectedNodes)) {\n          selectedNodes.push(id);\n        }\n      }\n\n      network.selectNodes(selectedNodes);\n      this.assignActiveStyle(selectedNodes);\n\n      network.redraw();\n    }\n\n    //https://github.com/almende/vis/blob/111c9984bc4c1870d42ca96b45d90c13cb92fe0a/lib/network/modules/InteractionHandler.js\n\n  }, {\n    key: 'handleCanvasScroll',\n    value: function handleCanvasScroll(ev) {\n\n      var isZoomAllowed = !!(this.isInSidebar || // e.g. the map editor in the sidebar\n      ev.ctrlKey || this.enlargedMode || this.clickToUse && this.networkDomNode.classList.contains('vis-active'));\n\n      var interaction = this.visOptions.interaction;\n\n      var isVisSettingInSync = isZoomAllowed === interaction.zoomView;\n\n      if (isZoomAllowed || !isVisSettingInSync) {\n        ev.preventDefault();\n      }\n\n      if (!isVisSettingInSync) {\n        // prevent visjs from reacting to this event as we first need to sync states\n        ev.stopPropagation();\n\n        interaction.zoomView = isZoomAllowed;\n        this.network.setOptions({ interaction: { zoomView: isZoomAllowed } });\n\n        return false;\n      }\n    }\n\n    /**\n     * Called when the user click on the canvas with the right\n     * mouse button. A context menu is opened.\n     */\n\n  }, {\n    key: 'handleContextMenu',\n    value: function handleContextMenu(ev) {\n      var _this5 = this;\n\n      ev.preventDefault();\n\n      var network = this.network;\n\n\n      this.hidePopups(0, true);\n\n      var nodeId = network.getNodeAt({ x: ev.offsetX, y: ev.offsetY });\n      if (!nodeId) return;\n\n      // ids of selected nodes\n      var selectedNodes = network.getSelectedNodes();\n\n      if (!_utils2.default.inArray(nodeId, selectedNodes)) {\n        // unselect other nodes and select this one instead…\n        selectedNodes = [nodeId];\n        network.selectNodes(selectedNodes);\n      }\n\n      this.contextMenu.show(selectedNodes, function (selectedNodes, div) {\n\n        var mode = selectedNodes.length > 1 ? 'multi' : 'single';\n        var tRef = '$:/plugins/felixhayashi/tiddlymap/editor/contextMenu/node';\n\n        _utils2.default.registerTransclude(_this5, 'contextMenuWidget', tRef);\n        _this5.contextMenuWidget.setVariable('mode', mode);\n        _this5.contextMenuWidget.render(div);\n      });\n    }\n  }, {\n    key: 'handleWidgetKeyup',\n    value: function handleWidgetKeyup(ev) {}\n  }, {\n    key: 'handleWidgetKeydown',\n    value: function handleWidgetKeydown(ev) {\n\n      if (ev.ctrlKey) {\n        // ctrl key is hold down\n        ev.preventDefault();\n\n        if (ev.keyCode === 70) {\n          // f\n          ev.preventDefault();\n\n          var focusButtonStateTRef = this.widgetPopupsPath + '/focus';\n          _utils2.default.setText(focusButtonStateTRef, _utils2.default.getText(focusButtonStateTRef) ? '' : '1');\n\n          // note: it is ok to focus the graph right after this,\n          // if the focus button is activated it will steal the focus anyway\n        } else {\n\n          return;\n        }\n      } else if (ev.keyCode === 120) {\n        // F9\n        ev.preventDefault();\n        this.toggleEnlargedMode('halfscreen');\n      } else if (ev.keyCode === 121) {\n        // F10\n        ev.preventDefault();\n        this.toggleEnlargedMode('fullscreen');\n      } else if (ev.keyCode === 27) {\n        // ESC\n        ev.preventDefault();\n\n        _utils2.default.deleteByPrefix(this.widgetPopupsPath);\n      } else {\n        return;\n      }\n\n      this.canvas.focus();\n    }\n  }, {\n    key: 'handlePasteNodesFromClipboard',\n    value: function handlePasteNodesFromClipboard() {\n\n      if (!this.editorMode) {\n        $tm.notify('Map is read only!');\n        return;\n      }\n\n      if (!$tm.clipBoard || $tm.clipBoard.type !== 'nodes') {\n        $tm.notify('TiddlyMap clipboad is empty!');\n      }\n\n      var nodes = $tm.clipBoard.nodes;\n      var ids = Object.keys(nodes);\n\n      for (var i = ids.length; i--;) {\n\n        var id = ids[i];\n\n        if (this.graphData.nodesById[id]) {\n          // node already present in this view\n          continue;\n        }\n\n        this.view.addNode(nodes[id]);\n\n        // paste nodes so we can select them!\n        this.graphData.nodes.update({ id: id });\n      }\n\n      this.network.selectNodes(ids);\n\n      this.rebuildGraph({ resetFocus: { delay: 0, duration: 0 } });\n\n      $tm.notify('pasted ' + ids.length + ' nodes into map.');\n    }\n  }, {\n    key: 'handleAddNodesToClipboard',\n    value: function handleAddNodesToClipboard(mode) {\n\n      var nodeIds = this.network.getSelectedNodes();\n\n      if (!nodeIds.length) {\n        return;\n      }\n\n      $tm.clipBoard = {\n        type: 'nodes',\n        nodes: this.graphData.nodes.get(nodeIds, { returnType: 'Object' })\n      };\n\n      $tm.notify('Copied ' + nodeIds.length + ' nodes to clipboard');\n\n      if (mode === 'move') {\n        for (var i = nodeIds.length; i--;) {\n          this.view.removeNode(nodeIds[i]);\n        }\n      }\n\n      // prevent zoom\n      this.isPreventZoomOnNextUpdate = true;\n    }\n\n    /**\n     * @todo Instead of redrawing the whole graph when an edge or node is\n     * added it may be worth considering only getting the element from the\n     * adapter and directly inserting it into the graph and *avoid* a\n     * reload of the graph via `rebuildGraph`!\n     *\n     * @todo: too much recomputation -> outsource\n     */\n\n  }, {\n    key: 'getVisOptions',\n    value: function getVisOptions() {\n      var _this6 = this;\n\n      // merge options\n      var globalOptions = $tm.config.vis;\n      var localOptions = _utils2.default.parseJSON(this.view.getConfig('vis'));\n      var options = _utils2.default.merge({}, globalOptions, localOptions);\n\n      options.clickToUse = this.clickToUse;\n      options.manipulation.enabled = !!this.editorMode;\n\n      options.manipulation.deleteNode = function (data, callback) {\n        _this6.handleRemoveElements(data);\n        _this6.resetVisManipulationBar(callback);\n      };\n\n      options.manipulation.deleteEdge = function (data, callback) {\n        _this6.handleRemoveElements(data);\n        _this6.resetVisManipulationBar(callback);\n      };\n\n      options.manipulation.addEdge = function (data, callback) {\n        _this6.handleConnectionEvent(data);\n        _this6.resetVisManipulationBar(callback);\n      };\n\n      options.manipulation.addNode = function (data, callback) {\n        _this6.handleInsertNode(data);\n        _this6.resetVisManipulationBar(callback);\n      };\n\n      options.manipulation.editNode = function (data, callback) {\n        _this6.handleEditNode(data);\n        _this6.resetVisManipulationBar(callback);\n      };\n\n      options.interaction.zoomView = !!(this.isInSidebar || this.enlargedMode);\n\n      // not allowed\n      options.manipulation.editEdge = false;\n\n      // make sure the actual solver is an object\n      var physics = options.physics;\n      physics[physics.solver] = physics[physics.solver] || {};\n\n      physics.stabilization.iterations = 1000;\n\n      this.logger('debug', 'Loaded graph options', options);\n\n      return options;\n    }\n  }, {\n    key: 'resetVisManipulationBar',\n    value: function resetVisManipulationBar(visCallback) {\n\n      if (visCallback) {\n        visCallback(null);\n      }\n\n      this.network.disableEditMode();\n      this.network.enableEditMode();\n    }\n  }, {\n    key: 'isVisInEditMode',\n    value: function isVisInEditMode() {\n\n      return this.graphDomNode.getElementsByClassName('vis-button vis-back').length > 0;\n    }\n\n    /**\n     * Create an empty view. A dialog is opened that asks the user how to\n     * name the view. The view is then registered as current view.\n     */\n\n  }, {\n    key: 'handleCreateView',\n    value: function handleCreateView() {\n      var _this7 = this;\n\n      var args = {\n        view: this.view.getLabel()\n      };\n\n      $tm.dialogManager.open('createView', args, function (isConfirmed, outTObj) {\n\n        if (!isConfirmed) return;\n\n        var label = _utils2.default.getField(outTObj, 'name');\n        var isClone = _utils2.default.getField(outTObj, 'clone', false);\n\n        if (_ViewAbstraction2.default.exists(label)) {\n\n          $tm.notify('Forbidden! View already exists!');\n\n          return;\n        }\n\n        if (isClone && _this7.view.isLiveView()) {\n          $tm.notify('Forbidden to clone the live view!');\n          return;\n        }\n\n        var newView = new _ViewAbstraction2.default(label, {\n          isCreate: true,\n          protoView: isClone ? _this7.view : null\n        });\n\n        _this7.setView(newView);\n      });\n    }\n  }, {\n    key: 'handleRenameView',\n    value: function handleRenameView() {\n      var _this8 = this;\n\n      if (this.view.isLocked()) {\n\n        $tm.notify('Forbidden!');\n        return;\n      }\n\n      var references = this.view.getOccurrences();\n\n      var args = {\n        count: references.length.toString(),\n        refFilter: _utils2.default.joinAndWrap(references, '[[', ']]')\n      };\n\n      $tm.dialogManager.open('renameView', args, function (isConfirmed, outTObj) {\n\n        if (!isConfirmed) {\n          return;\n        }\n\n        var label = _utils2.default.getText(outTObj);\n\n        if (!label) {\n\n          $tm.notify('Invalid name!');\n        } else if (_ViewAbstraction2.default.exists(label)) {\n\n          $tm.notify('Forbidden! View already exists!');\n        } else {\n\n          _this8.view.rename(label);\n          _this8.setView(_this8.view);\n        }\n      });\n    }\n  }, {\n    key: 'handleEditView',\n    value: function handleEditView() {\n      var _this9 = this;\n\n      var visInherited = JSON.stringify($tm.config.vis);\n      var data = this.graphData;\n\n      var viewConfig = this.view.getConfig();\n\n      var preselects = {\n        'filter.prettyNodeFltr': this.view.getNodeFilter('pretty'),\n        'filter.prettyEdgeFltr': this.view.getEdgeTypeFilter('pretty'),\n        'vis-inherited': visInherited\n      };\n\n      var args = {\n        view: this.view.getLabel(),\n        createdOn: this.view.getCreationDate(true),\n        numberOfNodes: Object.keys(data.nodesById).length.toString(),\n        numberOfEdges: Object.keys(data.edgesById).length.toString(),\n        dialog: {\n          preselects: $tw.utils.extend({}, viewConfig, preselects)\n        }\n      };\n\n      $tm.dialogManager.open('configureView', args, function (isConfirmed, outTObj) {\n\n        if (!isConfirmed) {\n          return;\n        }\n\n        var config = _utils2.default.getPropertiesByPrefix(outTObj.fields, 'config.', true);\n\n        // ATTENTION: needs to be tested before applying new config!\n        var prvBg = _this9.view.getConfig('background_image');\n\n        _this9.view.setConfig(config);\n        if (config['physics_mode'] && !_this9.view.isEnabled('physics_mode')) {\n          // when not in physics mode, store positions\n          // to prevent floating afterwards\n          _this9.view.saveNodePositions(_this9.network.getPositions());\n        }\n\n        var curBg = _this9.view.getConfig('background_image');\n        if (curBg && curBg !== prvBg) {\n          $tm.notify('Background changed! You may need to zoom out a bit.');\n        }\n\n        var nf = _utils2.default.getField(outTObj, 'filter.prettyNodeFltr', '');\n        var eTf = _utils2.default.getField(outTObj, 'filter.prettyEdgeFltr', '');\n\n        _this9.view.setNodeFilter(nf);\n        _this9.view.setEdgeTypeFilter(eTf);\n      });\n    }\n\n    /**\n     * Triggers a download dialog where the user can store the canvas\n     * as png on his/her harddrive.\n     */\n\n  }, {\n    key: 'handleSaveCanvas',\n    value: function handleSaveCanvas() {\n      var _this10 = this;\n\n      var tempImagePath = '$:/temp/tmap/snapshot';\n      this.createAndSaveSnapshot(tempImagePath);\n      var defaultName = _utils2.default.getSnapshotTitle(this.view.getLabel(), 'png');\n\n      var args = {\n        dialog: {\n          snapshot: tempImagePath,\n          width: this.canvas.width.toString(),\n          height: this.canvas.height.toString(),\n          preselects: {\n            name: defaultName,\n            action: 'download'\n          }\n        }\n      };\n\n      $tm.dialogManager.open('saveCanvas', args, function (isConfirmed, outTObj) {\n        if (!isConfirmed) return;\n\n        // allow the user to override the default name or if name is\n        // empty use the original default name\n        defaultName = outTObj.fields.name || defaultName;\n\n        var action = outTObj.fields.action;\n\n        if (action === 'download') {\n          _this10.handleDownloadSnapshot(defaultName);\n        } else if (action === 'wiki') {\n          _utils2.default.cp(tempImagePath, defaultName, true);\n          _this10.dispatchEvent({\n            type: 'tm-navigate', navigateTo: defaultName\n          });\n        } else if (action === 'placeholder') {\n          _this10.view.addPlaceholder(tempImagePath);\n        }\n\n        // in any case\n        $tw.wiki.deleteTiddler('$:/temp/tmap/snapshot');\n      });\n    }\n  }, {\n    key: 'handleDownloadSnapshot',\n    value: function handleDownloadSnapshot(title) {\n\n      var a = this.document.createElement('a');\n      var label = this.view.getLabel();\n      a.download = title || _utils2.default.getSnapshotTitle(label, 'png');\n      a.href = this.getSnapshot();\n\n      // we cannot simply call click() on <a>; chrome is cool with it but\n      // firefox requires us to create a mouse event…\n      var event = new MouseEvent('click');\n      a.dispatchEvent(event);\n    }\n  }, {\n    key: 'createAndSaveSnapshot',\n    value: function createAndSaveSnapshot(title) {\n\n      var tRef = title || this.view.getRoot() + '/snapshot';\n      $tw.wiki.addTiddler(new $tw.Tiddler({\n        title: tRef,\n        type: 'image/png',\n        text: this.getSnapshot(true),\n        modified: new Date()\n      }));\n\n      return tRef;\n    }\n  }, {\n    key: 'getSnapshot',\n    value: function getSnapshot(stripPreamble) {\n\n      var data = this.canvas.toDataURL('image/png');\n\n      return stripPreamble ? _utils2.default.getWithoutPrefix(data, 'data:image/png;base64,') : data;\n    }\n  }, {\n    key: 'handleDeleteView',\n    value: function handleDeleteView() {\n      var _this11 = this;\n\n      var viewname = this.view.getLabel();\n\n      if (this.view.isLocked()) {\n\n        $tm.notify('Forbidden!');\n        return;\n      }\n\n      // regex is non-greedy\n\n      var references = this.view.getOccurrences();\n      if (references.length) {\n\n        var fields = {\n          count: references.length.toString(),\n          refFilter: _utils2.default.joinAndWrap(references, '[[', ']]')\n        };\n\n        $tm.dialogManager.open('cannotDeleteViewDialog', fields);\n\n        return;\n      }\n\n      var message = '\\n        You are about to delete the view \\'\\'' + viewname + '\\'\\'\\n        (no tiddler currently references this view).\\n     ';\n\n      this.openStandardConfirmDialog(function (isConfirmed) {\n        // TODO: this dialog needs an update\n\n        if (!isConfirmed) {\n          return;\n        }\n\n        _this11.view.destroy();\n        _this11.setView($tm.misc.defaultViewLabel);\n        var msg = 'view \"' + viewname + '\\' deleted';\n        _this11.logger('debug', msg);\n        $tm.notify(msg);\n      }, message);\n    }\n\n    /**\n     * This will rebuild the graph after a trigger has been activated.\n     *\n     * Prior to TiddlyMap v0.9, an additional check was performed\n     * to verify, if the graph had actually changed before rebuilding\n     * the graph. This check, however, was an overkill and as such removed.\n     */\n\n  }, {\n    key: 'handleTriggeredRefresh',\n    value: function handleTriggeredRefresh(trigger) {\n\n      this.logger('log', trigger, 'Triggered a refresh');\n\n      // special case for the live tab\n      if (this.id === 'live_tab') {\n        var curTiddler = _utils2.default.getTiddler(_utils2.default.getText(trigger));\n        if (curTiddler) {\n          var view = curTiddler.fields['tmap.open-view'] || $tm.config.sys.liveTab.fallbackView;\n          if (view && view !== this.view.getLabel()) {\n            this.setView(view);\n            return;\n          }\n        }\n      }\n\n      this.rebuildGraph({\n        resetFocus: {\n          delay: 1000,\n          duration: 1000\n        }\n      });\n    }\n\n    /**\n     * Called by vis when the user tries to delete nodes or edges.\n     * The action is delegated to subhandlers.\n     *\n     * @param {Array<Id>} nodes - Removed edges.\n     * @param {Array<Id>} edges - Removed nodes.\n     */\n\n  }, {\n    key: 'handleRemoveElements',\n    value: function handleRemoveElements(_ref2) {\n      var nodes = _ref2.nodes,\n          edges = _ref2.edges;\n\n\n      if (nodes.length) {\n        // the adapter also removes edges when nodes are removed.\n        this.handleRemoveNodes(nodes);\n      } else if (edges.length) {\n        this.handleRemoveEdges(edges);\n      }\n\n      this.resetVisManipulationBar();\n    }\n  }, {\n    key: 'handleRemoveEdges',\n    value: function handleRemoveEdges(edgeIds) {\n\n      $tm.adapter.deleteEdges(this.graphData.edges.get(edgeIds));\n      $tm.notify('edge' + (edgeIds.length > 1 ? 's' : '') + ' removed');\n    }\n\n    /**\n     * Handler that guides the user through the process of deleting a node\n     * from the graph. The nodes may be removed from the filter (if possible)\n     * or from the system.\n     *\n     * Note: this should not trigger a zoom.\n     */\n\n  }, {\n    key: 'handleRemoveNodes',\n    value: function handleRemoveNodes(nodeIds) {\n      var _this12 = this;\n\n      var tiddlers = $tm.adapter.getTiddlersByIds(nodeIds);\n      var params = {\n        'count': nodeIds.length.toString(),\n        'tiddlers': $tw.utils.stringifyList(tiddlers),\n        dialog: {\n          preselects: {\n            'delete-from': 'filter'\n          }\n        }\n      };\n\n      $tm.dialogManager.open('deleteNodeDialog', params, function (isConfirmed, outTObj) {\n\n        if (!isConfirmed) return;\n\n        var deletionCount = 0;\n\n        for (var i = nodeIds.length; i--;) {\n          var success = _this12.view.removeNode(nodeIds[i]);\n          if (success) {\n            deletionCount++;\n          }\n        }\n\n        if (outTObj.fields['delete-from'] === 'system') {\n\n          // will also delete edges\n          $tm.adapter.deleteNodes(nodeIds);\n          deletionCount = nodeIds.length; // we just say so ;)\n        }\n\n        // prevent zoom\n        _this12.isPreventZoomOnNextUpdate = true;\n\n        $tm.notify('\\n        Removed ' + deletionCount + '\\n        of ' + nodeIds.length + '\\n        from ' + outTObj.fields['delete-from'] + '\\n      ');\n      });\n    }\n\n    /**\n     * Calling this function will toggle the enlargement of the map\n     * instance. Markers need to be added at various places to ensure the\n     * map stretches properly. This includes marking ancestor dom nodes\n     * to be able to shift the stacking context.\n     *\n     * @param {string} type - either 'halfscreen' or 'fullscreen'.\n     */\n\n  }, {\n    key: 'toggleEnlargedMode',\n    value: function toggleEnlargedMode(type) {\n\n      if (!this.isInSidebar && type === 'halfscreen') {\n        return;\n      }\n\n      this.logger('log', 'Toggled graph enlargement');\n\n      var enlargedMode = this.enlargedMode;\n\n      // in any case, exit enlarged mode if active\n      if (enlargedMode) {\n\n        // reset click to use\n        this.network.setOptions({ clickToUse: this.clickToUse });\n\n        // remove markers\n        _utils2.default.findAndRemoveClassNames(['tmap-has-' + enlargedMode + '-widget', 'tmap-' + enlargedMode]);\n\n        // reset flag\n        this.enlargedMode = null;\n        document.body.scrollTop = this.scrollTop;\n      }\n\n      if (!enlargedMode || enlargedMode !== type && (type === 'fullscreen' || type === 'halfscreen' && !this.isInSidebar)) {\n\n        this.scrollTop = document.body.scrollTop;\n\n        this.enlargedMode = type;\n\n        var pContainer = this.isInSidebar ? this.sidebar : _utils2.default.getFirstElementByClassName('tc-story-river');\n\n        $tw.utils.addClass(this.document.body, 'tmap-has-' + type + '-widget');\n        $tw.utils.addClass(pContainer, 'tmap-has-' + type + '-widget');\n        $tw.utils.addClass(this.domNode, 'tmap-' + type);\n\n        // disable click to use by force\n        this.network.setOptions({ clickToUse: false });\n\n        $tm.notify('Toggled ' + type + ' mode');\n      }\n\n      // always do resize\n      this.handleResizeEvent();\n    }\n  }, {\n    key: 'handleGenerateWidget',\n    value: function handleGenerateWidget(event) {\n\n      $tw.rootWidget.dispatchEvent({\n        type: 'tmap:tm-generate-widget',\n        paramObject: { view: this.view.getLabel() }\n      });\n    }\n  }, {\n    key: 'handleSetCentralTopic',\n    value: function handleSetCentralTopic(_ref3) {\n      var paramObject = _ref3.paramObject;\n\n\n      var nodeId = paramObject.id || this.network.getSelectedNodes()[0];\n\n      if (nodeId === this.view.getConfig('central-topic')) {\n        nodeId = '';\n      }\n\n      this.view.setCentralTopic(nodeId);\n    }\n\n    /**\n     * Called by vis when the graph has stabilized itself.\n     *\n     * ATTENTION: never store positions in a view's map during stabilize\n     * as this will affect other graphs positions and will cause recursion!\n     * Storing positions inside vis' nodes is fine though\n     */\n\n  }, {\n    key: 'handleVisStabilizedEvent',\n    value: function handleVisStabilizedEvent(properties) {\n\n      if (this.hasNetworkStabilized) {\n        return;\n      }\n\n      this.hasNetworkStabilized = true;\n      this.logger('log', 'Network stabilized after', properties.iterations, 'iterations');\n\n      if (!this.view.isEnabled('physics_mode')) {\n        // static mode\n\n        // store positions if new nodes without position were added\n        var nodes = this.graphData.nodesById;\n        var idsOfNodesWithoutPosition = [];\n\n        for (var id in nodes) {\n          if (nodes[id].x === undefined) {\n            idsOfNodesWithoutPosition.push(id);\n          }\n        }\n\n        if (idsOfNodesWithoutPosition.length) {\n          this.setNodesMoveable(idsOfNodesWithoutPosition, false);\n          $tm.notify(idsOfNodesWithoutPosition.length + ' nodes were added to the graph');\n        }\n\n        // after storing positions, set gravity to zero again\n        var physics = this.visOptions.physics;\n        physics[physics.solver].centralGravity = 0;\n        this.network.setOptions(this.visOptions);\n      }\n\n      if (this.resetFocus) {\n        this.fitGraph(this.resetFocus.delay, this.resetFocus.duration);\n        this.resetFocus = null;\n      }\n    }\n\n    /**\n     * Zooms on a specific node in the graph\n     */\n\n  }, {\n    key: 'handleFocusNode',\n    value: function handleFocusNode(_ref4) {\n      var tRef = _ref4.param;\n\n\n      this.network.focus($tm.adapter.getId(tRef), {\n        scale: 1.5,\n        animation: true\n      });\n    }\n\n    /**\n     * A zombie widget is a widget that is removed from the dom tree\n     * but still referenced or still partly executed -- I mean\n     * otherwise you couldn't call this function, right?\n     *\n     * If TiddlyMap is executed in a fake environment, the function\n     * always returns true.\n     */\n\n  }, {\n    key: 'isZombieWidget',\n    value: function isZombieWidget() {\n\n      return this.domNode.isTiddlyWikiFakeDom === true || !this.document.body.contains(this.getContainer());\n    }\n\n    /**\n     * This method allows us to specify after what time and for how long\n     * the zoom-to-fit process should be executed for a graph.\n     *\n     * @param {number} [delay=0] - How long to wait before starting to zoom.\n     * @param {number} [duration=0] - After the delay, how long should it\n     *     take for the graph to be zoomed.\n     */\n\n  }, {\n    key: 'fitGraph',\n    value: function fitGraph() {\n      var _this13 = this;\n\n      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n\n      // clear any existing fitting attempt\n      clearTimeout(this.activeFitTimeout);\n\n      var fit = function fit() {\n\n        // happens when widget is removed after stabilize but before fit\n        if (_this13.isZombieWidget()) {\n          return;\n        }\n\n        // fixes #97\n        _this13.network.redraw();\n\n        _this13.network.fit({ // v4: formerly zoomExtent\n          animation: {\n            duration: duration,\n            easingFunction: 'easeOutQuart'\n          }\n        });\n      };\n\n      this.activeFitTimeout = setTimeout(fit, delay);\n    }\n\n    /**\n     * Spawns a dialog in which the user can specify node attributes.\n     * Once the dialog is closed, the node is inserted into the current\n     * view, unless the operation was cancelled.\n     */\n\n  }, {\n    key: 'handleInsertNode',\n    value: function handleInsertNode(node) {\n      var _this14 = this;\n\n      $tm.dialogManager.open('addNodeToMap', {}, function (isConfirmed, outTObj) {\n\n        if (!isConfirmed) {\n          return;\n        }\n\n        var tRef = _utils2.default.getField(outTObj, 'draft.title');\n\n        if (_utils2.default.tiddlerExists(tRef)) {\n\n          // Todo: use graphData and test if node is match (!=neighbour)\n          if (_utils2.default.isMatch(tRef, _this14.view.getNodeFilter('compiled'))) {\n\n            $tm.notify('Node already exists');\n\n            return;\n          } else {\n\n            node = $tm.adapter.makeNode(tRef, node);\n            _this14.view.addNode(node);\n          }\n        } else {\n\n          var tObj = new $tw.Tiddler(outTObj, { 'draft.title': null });\n\n          node.label = tRef;\n          $tm.adapter.insertNode(node, _this14.view, tObj);\n        }\n\n        // prevent zoom\n        _this14.isPreventZoomOnNextUpdate = true;\n      });\n    }\n\n    /**\n     * Open the node editor to style the node.\n     */\n\n  }, {\n    key: 'handleEditNode',\n    value: function handleEditNode(node) {\n      var _this15 = this;\n\n      var tRef = $tm.tracker.getTiddlerById(node.id);\n      var tObj = _utils2.default.getTiddler(tRef);\n      var globalDefaults = JSON.stringify($tm.config.vis);\n      var localDefaults = this.view.getConfig('vis');\n      var nodes = {};\n      nodes[node.id] = node;\n      var nodeStylesByTRef = $tm.adapter.getInheritedNodeStyles(nodes);\n      var groupStyles = JSON.stringify(nodeStylesByTRef[tRef]);\n      var globalNodeStyle = JSON.stringify(_utils2.default.merge({}, { color: tObj.fields['color'] }, _utils2.default.parseJSON(tObj.fields['tmap.style'])));\n\n      var viewLabel = this.view.getLabel();\n\n      // we copy the object since we intend to modify it.\n      // NOTE: A deep copy would be needed if a nested property were modified\n      //       In that case, use $tw.utils.deepCopy.\n      var nodeData = _extends({}, this.view.getNodeData(node.id));\n      // we need to delete the positions so they are not reset when a user\n      // resets the style…\n      delete nodeData.x;\n      delete nodeData.y;\n\n      var args = {\n        'view': viewLabel,\n        'tiddler': tObj.fields.title,\n        'tidColor': tObj.fields['color'],\n        'tidIcon': tObj.fields[$tm.field.nodeIcon] || tObj.fields['tmap.fa-icon'],\n        'tidLabelField': 'global.' + $tm.field.nodeLabel,\n        'tidIconField': 'global.' + $tm.field.nodeIcon,\n        dialog: {\n          preselects: {\n            'inherited-global-default-style': globalDefaults,\n            'inherited-local-default-style': localDefaults,\n            'inherited-group-styles': groupStyles,\n            'global.tmap.style': globalNodeStyle,\n            'local-node-style': JSON.stringify(nodeData)\n          }\n        }\n      };\n\n      // function to iterate over attributes that shall be available\n      // in the dialog.\n      var addToPreselects = function addToPreselects(scope, store, keys) {\n        for (var i = keys.length; i--;) {\n          args.dialog.preselects[scope + '.' + keys[i]] = store[keys[i]] || '';\n        }\n      };\n\n      // local values are retrieved from the view's node data store\n      addToPreselects('local', nodeData, ['label', 'tw-icon', 'fa-icon', 'open-view']);\n\n      // global values are taken from the tiddler's field object\n      addToPreselects('global', tObj.fields, [$tm.field.nodeLabel, $tm.field.nodeIcon, 'tmap.fa-icon', 'tmap.open-view']);\n\n      $tm.dialogManager.open('editNode', args, function (isConfirmed, outTObj) {\n\n        if (!isConfirmed) return;\n\n        var fields = outTObj.fields;\n\n        // save or remove global individual style\n        var global = _utils2.default.getPropertiesByPrefix(fields, 'global.', true);\n        for (var p in global) {\n\n          _utils2.default.setField(tRef, p, global[p] || undefined);\n        }\n\n        // save local individual data (style + config)\n        var local = _utils2.default.getPropertiesByPrefix(fields, 'local.', true);\n\n        // CAREFUL: Never change 'local-node-style' to 'local.node-style'\n        // (with a dot) because it will get included in the loop!\n        var data = _utils2.default.parseJSON(fields['local-node-style'], {});\n\n        for (var _p in local) {\n          data[_p] = local[_p] || undefined;\n        }\n\n        _this15.view.saveNodeStyle(node.id, data);\n\n        _this15.isPreventZoomOnNextUpdate = true;\n      });\n    }\n\n    /**\n     * This handler is registered at and called by the vis network event\n     * system.\n     */\n\n  }, {\n    key: 'handleVisSingleClickEvent',\n    value: function handleVisSingleClickEvent(properties) {\n\n      var isActivated = _utils2.default.isTrue($tm.config.sys.singleClickMode);\n      if (isActivated && !this.editorMode) {\n        this.handleOpenMapElementEvent(properties);\n      }\n    }\n\n    /**\n     * This handler is registered at and called by the vis network event\n     * system.\n     *\n     * @see Coordinates not passed on click/tap events within the properties object\n     * @see https://github.com/almende/vis/issues/440\n     *\n     * @properties a list of nodes and/or edges that correspond to the\n     * click event.\n     */\n\n  }, {\n    key: 'handleVisDoubleClickEvent',\n    value: function handleVisDoubleClickEvent(properties) {\n\n      if (properties.nodes.length || properties.edges.length) {\n\n        if (this.editorMode || !_utils2.default.isTrue($tm.config.sys.singleClickMode)) {\n\n          this.handleOpenMapElementEvent(properties);\n        }\n      } else {\n        // = clicked on an empty spot\n\n        if (this.editorMode) {\n          this.handleInsertNode(properties.pointer.canvas);\n        }\n      }\n    }\n  }, {\n    key: 'handleOpenMapElementEvent',\n    value: function handleOpenMapElementEvent(_ref5) {\n      var nodes = _ref5.nodes,\n          edges = _ref5.edges;\n\n\n      if (nodes.length) {\n        // clicked on a node\n\n        var node = this.graphData.nodesById[nodes[0]];\n        if (node['open-view']) {\n          $tm.notify('Switching view');\n          this.setView(node['open-view']);\n        } else {\n          this.openTiddlerWithId(nodes[0]);\n        }\n      } else if (edges.length) {\n        // clicked on an edge\n\n        this.logger('debug', 'Clicked on an Edge');\n        var typeId = this.graphData.edgesById[edges[0]].type;\n        this.handleEditEdgeType(typeId);\n      } else {\n\n        return;\n      }\n\n      this.hidePopups(0, true);\n    }\n  }, {\n    key: 'handleEditEdgeType',\n    value: function handleEditEdgeType(type) {\n\n      if (!this.editorMode) return;\n\n      var behaviour = $tm.config.sys.edgeClickBehaviour;\n      if (behaviour !== 'manager') return;\n\n      $tw.rootWidget.dispatchEvent({\n        type: 'tmap:tm-manage-edge-types',\n        paramObject: {\n          type: type\n        }\n      });\n    }\n  }, {\n    key: 'handleResizeEvent',\n\n\n    /**\n     * Listener will be removed if the parent is not part of the dom anymore\n     *\n     * @see https://groups.google.com/d/topic/tiddlywikidev/yuQB1KwlKx8/discussion [TW5] Is there a destructor for widgets?\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Node.contains\n     */\n    value: function handleResizeEvent(event) {\n\n      if (this.isZombieWidget()) return;\n\n      var height = this.getAttr('height');\n      var width = this.getAttr('width');\n\n      if (this.isInSidebar) {\n\n        var rect = this.domNode.getBoundingClientRect();\n        var distRight = 15;\n        width = document.body.clientWidth - rect.left - distRight + 'px';\n\n        var distBottom = parseInt(this.getAttr('bottom-spacing')) || 15;\n        var calculatedHeight = window.innerHeight - rect.top;\n        height = calculatedHeight - distBottom + 'px';\n      }\n\n      this.domNode.style.height = height || '300px';\n      this.domNode.style.width = width;\n\n      this.repaintGraph(); // redraw graph\n    }\n\n    /**\n     * used to prevent nasty deletion as edges are not unselected when leaving vis\n     */\n\n  }, {\n    key: 'handleClickEvent',\n    value: function handleClickEvent(evt) {\n\n      if (this.isZombieWidget() || !this.network) return;\n\n      if (!this.graphDomNode.contains(evt.target)) {\n        // clicked outside\n\n        var selected = this.network.getSelection();\n        if (selected.nodes.length || selected.edges.length) {\n          this.logger('debug', 'Clicked outside; deselecting nodes/edges');\n          // upstream bug: this.network.unselectAll() doesn't work\n          this.network.selectNodes([]); // deselect nodes and edges\n          this.resetVisManipulationBar();\n        }\n      } else {\n\n        this.canvas.focus();\n      }\n\n      if (evt.button !== 2) {\n        // not the right button\n        this.contextMenu.hide(0, true);\n      }\n    }\n  }, {\n    key: 'handleVisSelectNode',\n    value: function handleVisSelectNode(_ref6) {\n      var nodes = _ref6.nodes;\n\n\n      if (!this.isDraggingAllowed(nodes)) {\n        return;\n      }\n\n      // assign selected style\n      this.assignActiveStyle(nodes);\n    }\n  }, {\n    key: 'isDraggingAllowed',\n    value: function isDraggingAllowed(_ref7) {\n      var nodes = _ref7.nodes;\n\n      return this.editorMode || this.view.isEnabled('physics_mode');\n    }\n\n    /**\n     * Assign some styles when the graph element becomes active, i.e.\n     * it is selected or hovered over.\n     *\n     * @param {Id|Array<Id>} nodeIds - A single id or an Array of ids.\n     */\n\n  }, {\n    key: 'assignActiveStyle',\n    value: function assignActiveStyle(nodeIds) {\n\n      if (!Array.isArray(nodeIds)) nodeIds = [nodeIds];\n\n      var defaultColor = this.visOptions.nodes.color;\n\n      // iterate over selected nodes\n      for (var i = nodeIds.length; i--;) {\n        var id = nodeIds[i];\n        var node = this.graphData.nodesById[id];\n        var colorObj = _utils2.default.merge({}, defaultColor, node.color);\n        this.graphData.nodes.update({\n          id: id,\n          color: {\n            highlight: colorObj,\n            hover: colorObj\n          }\n        });\n      }\n    }\n  }, {\n    key: 'handleVisDeselectNode',\n    value: function handleVisDeselectNode(properties) {}\n\n    //~ var prevSelectedNodes = properties.previousSelection.nodes;\n    //~ for (var i = prevSelectedNodes.length; i--;) {\n    //~ };\n\n    /**\n     * Called by vis when the dragging of a node(s) has ended.\n     * Vis passes an object containing event-related information.\n     *\n     * @param {Array<Id>} nodes - Array of ids of the nodes\n     *     that were being dragged.\n     */\n\n  }, {\n    key: 'handleVisDragEnd',\n    value: function handleVisDragEnd(_ref8) {\n      var nodes = _ref8.nodes;\n\n\n      if (!nodes.length) {\n        return;\n      }\n\n      if (nodes.length === 1 && this.view.isEnabled('raster')) {\n        var pos = this.network.getPositions()[nodes[0]];\n        this.graphData.nodes.update(_extends({\n          id: nodes[0]\n        }, _utils2.default.getNearestRasterPosition(pos, parseInt(this.view.getConfig('raster')))));\n      }\n\n      // reset store\n      this.draggedNode = null;\n\n      // fix node again and store positions\n      // if in static mode, fixing will be ignored\n      this.setNodesMoveable(nodes, false);\n    }\n\n    /**\n     *\n     * @param context2d\n     */\n\n  }, {\n    key: 'handleVisBeforeDrawing',\n    value: function handleVisBeforeDrawing(context2d) {\n      var view = this.view,\n          network = this.network,\n          backgroundImage = this.backgroundImage;\n\n\n      if (backgroundImage) {\n        context2d.drawImage(backgroundImage, 0, 0);\n      }\n\n      if (view.isEnabled('raster')) {\n        _utils2.default.drawRaster(context2d, network.getScale(), network.getViewPosition(), parseInt(view.getConfig('raster')));\n      }\n    }\n\n    /**\n     *\n     * @param context2d\n     */\n\n  }, {\n    key: 'handleVisAfterDrawing',\n    value: function handleVisAfterDrawing(context2d) {\n\n      if (this.selectRect) {\n\n        var rect = this.selectRect.getRect();\n\n        context2d.beginPath();\n        context2d.globalAlpha = 0.5;\n        context2d.fillStyle = '#EAFFEF';\n        context2d.fillRect.apply(context2d, _toConsumableArray(rect));\n\n        context2d.beginPath();\n        context2d.globalAlpha = 1;\n        context2d.strokeStyle = '#B4D9BD';\n        context2d.strokeRect.apply(context2d, _toConsumableArray(rect));\n      }\n\n      if (this.draggedNode && this.view.isEnabled('raster')) {\n\n        var pos = this.network.getPositions()[this.draggedNode];\n        var rPos = _utils2.default.getNearestRasterPosition(pos, parseInt(this.view.getConfig('raster')));\n\n        context2d.strokeStyle = 'green';\n        context2d.fillStyle = 'green';\n\n        context2d.beginPath();\n        context2d.moveTo(pos.x, pos.y);\n        context2d.lineTo(rPos.x, rPos.y);\n        context2d.stroke();\n        context2d.beginPath();\n        context2d.arc(rPos.x, rPos.y, 5, 0, Math.PI * 2);\n        context2d.fill();\n      }\n    }\n\n    /**\n     * called by tooltip class when tooltip is displayed;\n     */\n\n  }, {\n    key: 'constructTooltip',\n    value: function constructTooltip(signature, div) {\n\n      var ev = _utils2.default.parseJSON(signature);\n      var id = ev.node || ev.edge;\n\n      var text = null;\n      var outType = 'text/html';\n      var inType = 'text/vnd-tiddlywiki';\n\n      if (ev.node) {\n        // node\n\n        var tRef = $tm.tracker.getTiddlerById(id);\n        var tObj = _utils2.default.getTiddler(tRef);\n\n        var descr = tObj.fields[$tm.field.nodeInfo];\n\n        if (descr) {\n\n          div.innerHTML = $tw.wiki.renderText(outType, inType, descr);\n        } else if (tObj.fields.text) {\n\n          // simply rendering the text is not sufficient as this prevents\n          // us from updating the tooltip content on refresh. So we need\n          // to create a temporary widget that is registered to the dom\n          // node passed by the tooltip.\n\n          _utils2.default.registerTransclude(this, 'tooltipWidget', tRef);\n          this.tooltipWidget.setVariable('tv-tiddler-preview', 'yes');\n          this.tooltipWidget.render(div);\n        } else {\n\n          div.innerHTML = tRef;\n        }\n      } else {\n        // edge\n\n        var edge = this.graphData.edgesById[id];\n        var type = $tm.indeces.allETy[edge.type];\n\n        if (type.description) {\n          text = $tw.wiki.renderText(outType, inType, type.description);\n        }\n\n        div.innerHTML = text || type.label || type.id;\n      }\n    }\n  }, {\n    key: 'handleVisHoverElement',\n    value: function handleVisHoverElement(ev) {\n\n      if ($tm.mouse.buttons) return;\n\n      //~ this.graphDomNode.style.cursor = 'pointer';\n\n      var id = ev.node || ev.edge;\n      var signature = JSON.stringify(ev);\n\n      if (ev.node) {\n\n        // override the hover color\n        this.assignActiveStyle(id);\n      }\n\n      // show tooltip if not in edit mode\n      if (!this.isVisInEditMode() && !this.contextMenu.isShown()) {\n        var populator = this.constructTooltip;\n        this.tooltip.show(signature, populator);\n      }\n    }\n  }, {\n    key: 'handleVisBlurElement',\n    value: function handleVisBlurElement(ev) {\n\n      this.tooltip.hide();\n    }\n  }, {\n    key: 'handleVisLoading',\n    value: function handleVisLoading(_ref9) {\n      var total = _ref9.total,\n          iterations = _ref9.iterations;\n\n\n      // we only start to show the progress bar after a while\n      //~ if (params.iterations / params.total < 0.05) return;\n\n      this.graphLoadingBarDomNode.style.display = 'block';\n      this.graphLoadingBarDomNode.setAttribute('max', total);\n      this.graphLoadingBarDomNode.setAttribute('value', iterations);\n\n      //~ var text = 'Loading ' + Math.round((iterations / total) * 100) + '%';\n      //~ this.graphLoadingBarDomNode.innerHTML = text;\n    }\n  }, {\n    key: 'handleVisLoadingDone',\n    value: function handleVisLoadingDone(params) {\n\n      this.graphLoadingBarDomNode.style.display = 'none';\n    }\n\n    /**\n    * Called by vis when a node is being dragged.\n    * Vis passes an object containing event-related information.\n    * @param {Array<Id>} nodes - Array of ids of the nodes\n    *     that were being dragged.\n    */\n\n  }, {\n    key: 'handleVisDragStart',\n    value: function handleVisDragStart(_ref10) {\n      var nodes = _ref10.nodes;\n\n\n      if (!nodes.length ||\n      // we do not allow nodes to be dragged if not in editor mode\n      // except cases physics is enabled\n      !this.isDraggingAllowed(nodes)) {\n        return;\n      }\n\n      this.hidePopups(0, true);\n      this.assignActiveStyle(nodes);\n      this.setNodesMoveable(nodes, true);\n\n      if (nodes.length === 1) {\n        this.draggedNode = nodes[0];\n      }\n    }\n\n    /**\n     * called from outside.\n     */\n\n  }, {\n    key: 'destruct',\n    value: function destruct() {\n\n      // while the container should be destroyed and the listeners\n      // garbage collected, we remove them manually just to be save\n\n      _utils2.default.setDomListeners('remove', window, this.windowDomListeners);\n      _utils2.default.setDomListeners('remove', this.domNode, this.widgetDomListeners);\n\n      this._destructVis();\n    }\n\n    /**\n     * Only destructs stuff related to vis.\n     */\n\n  }, {\n    key: '_destructVis',\n    value: function _destructVis() {\n\n      if (!this.network) return;\n\n      _utils2.default.setDomListeners('remove', this.canvas, this.canvasDomListeners);\n\n      this.network.destroy();\n      this.network = null;\n    }\n\n    /**\n     * Opens the tiddler that corresponds to the given id either as\n     * modal (when in fullscreen mode) or in the story river.\n     */\n\n  }, {\n    key: 'openTiddlerWithId',\n    value: function openTiddlerWithId(id) {\n      var _this16 = this;\n\n      var tRef = $tm.tracker.getTiddlerById(id);\n\n      this.logger('debug', 'Opening tiddler', tRef, 'with id', id);\n\n      if (this.enlargedMode === 'fullscreen') {\n\n        var draftTRef = $tw.wiki.findDraft(tRef);\n        var wasInDraftAlready = !!draftTRef;\n\n        if (!wasInDraftAlready) {\n\n          var type = 'tm-edit-tiddler';\n          this.dispatchEvent({ type: type, tiddlerTitle: tRef });\n          draftTRef = $tw.wiki.findDraft(tRef);\n        }\n\n        var args = { draftTRef: draftTRef, originalTRef: tRef };\n\n        $tm.dialogManager.open('fullscreenTiddlerEditor', args, function (isConfirmed, outTObj) {\n\n          if (isConfirmed) {\n\n            var _type = 'tm-save-tiddler';\n            _this16.dispatchEvent({ type: _type, tiddlerTitle: draftTRef });\n          } else if (!wasInDraftAlready) {\n\n            // also removes the draft from the river before deletion!\n            _utils2.default.deleteTiddlers([draftTRef]);\n          }\n\n          // in any case, remove the original tiddler from the river\n          var type = 'tm-close-tiddler';\n          _this16.dispatchEvent({ type: type, tiddlerTitle: tRef });\n        });\n      } else {\n\n        var bounds = this.domNode.getBoundingClientRect();\n\n        this.dispatchEvent({\n          type: 'tm-navigate',\n          navigateTo: tRef,\n          navigateFromTitle: this.getVariable('storyTiddler'),\n          navigateFromNode: this,\n          navigateFromClientRect: {\n            top: bounds.top,\n            left: bounds.left,\n            width: bounds.width,\n            right: bounds.right,\n            bottom: bounds.bottom,\n            height: bounds.height\n          }\n        });\n      }\n    }\n\n    /**\n     * The view holder is a tiddler that stores a references to the current\n     * view. If the graph is not bound to a view by the user via an\n     * attribute, the default view holder is used. Otherwise, a temporary\n     * holder is created whose value is set to the view specified by the user.\n     * This way, the graph is independent from view changes made in a\n     * tiddlymap editor.\n     *\n     * This function will only calculate a new reference to the holder\n     * on first call (that is when no view holder is registered to 'this'.\n     *\n     */\n\n  }, {\n    key: 'getViewHolderRef',\n    value: function getViewHolderRef() {\n\n      // the viewholder is never recalculated once it exists\n      if (this.viewHolderRef) {\n        return this.viewHolderRef;\n      }\n\n      this.logger('info', 'Retrieving or generating the view holder reference');\n\n      // if given, try to retrieve the viewHolderRef by specified attribute\n      var viewName = this.getAttr('view');\n      var holderRef = null;\n\n      if (viewName) {\n\n        this.logger('log', 'User wants to bind view \"' + viewName + '\\' to graph');\n\n        var viewRef = $tm.path.views + '/' + viewName;\n\n        if ($tw.wiki.getTiddler(viewRef)) {\n\n          // create a view holder that is exclusive for this graph\n\n          holderRef = $tm.path.localHolders + '/' + _utils2.default.genUUID();\n          this.logger('log', 'Created an independent temporary view holder \"' + holderRef + '\"');\n\n          // we do not use setView here because it would store and reload the view unnecessarily...\n          _utils2.default.setText(holderRef, viewRef);\n\n          this.logger('log', 'View \"' + viewRef + '\\' inserted into independend holder');\n        } else {\n          this.logger('log', 'View \"' + viewName + '\" does not exist');\n        }\n      }\n\n      if (!holderRef) {\n        this.logger('log', 'Using default (global) view holder');\n        holderRef = $tm.ref.defaultViewHolder;\n      }\n\n      return holderRef;\n    }\n\n    /**\n     * This function will switch the current view reference of the\n     * view holder.\n     *\n     * NOTE:\n     * The changes will be picked up in the next refresh cycle.\n     * This function will never update the view object currently\n     * held by this widget (this.view)! This would create a race\n     * condition where the view has changed, but the graph data hasn't\n     * and maybe a stabilization event fires in this moment. At this point\n     * it would work with graph data that doesn't relate to the view\n     * and do bad things, trust me, big time bad things.\n     *\n     * @param {ViewAbstraction|string} view – A reference to the view.\n     * @param {string} [viewHolderRef] – A reference to the view holder.\n     */\n\n  }, {\n    key: 'setView',\n    value: function setView(view, viewHolderRef) {\n\n      if (!_ViewAbstraction2.default.exists(view)) {\n\n        return;\n      }\n\n      view = new _ViewAbstraction2.default(view);\n\n      var viewLabel = view.getLabel();\n      viewHolderRef = viewHolderRef || this.viewHolderRef;\n      this.logger('info', 'Inserting view \"' + viewLabel + '\" into holder \"' + viewHolderRef + '\"');\n      $tw.wiki.addTiddler(new $tw.Tiddler({\n        title: viewHolderRef,\n        text: viewLabel\n      }));\n\n      // we don't wait til next render-cycle (which would leave tiddlymap in\n      // a rather undefined state) but update immediately.\n      this.update({\n        changedTiddlers: _defineProperty({}, viewHolderRef, true)\n      });\n    }\n\n    /**\n     * This function will return a view abstraction that is based on the\n     * view specified in the view holder of this graph.\n     *\n     * @param {boolean} noCache - Retrieve the view reference again\n     *     from the holder and recreate the view abstraction object.\n     * @return {ViewAbstraction} the view\n     */\n\n  }, {\n    key: 'getView',\n    value: function getView(noCache) {\n\n      if (!noCache && this.view) {\n        return this.view;\n      }\n\n      var viewHolderRef = this.getViewHolderRef();\n\n      // transform into view object\n      var ref = _utils2.default.getText(viewHolderRef);\n\n      this.logger('debug', 'Retrieved view from holder');\n\n      var view = void 0;\n\n      if (_ViewAbstraction2.default.exists(ref)) {\n\n        view = new _ViewAbstraction2.default(ref);\n      } else {\n\n        this.logger('debug', 'Warning: View \"' + ref + '\" doesn\\'t exist. Default is used instead.');\n        view = new _ViewAbstraction2.default('Default');\n      }\n\n      return view;\n    }\n  }, {\n    key: 'reloadBackgroundImage',\n    value: function reloadBackgroundImage(msg) {\n      var _this17 = this;\n\n      this.backgroundImage = null;\n\n      var bgFieldValue = this.view.getConfig('background_image');\n      var imgTObj = _utils2.default.getTiddler(bgFieldValue);\n      if (!imgTObj && !bgFieldValue) return;\n\n      var img = new Image();\n      var ajaxCallback = function ajaxCallback(b64) {\n        img.src = b64;\n      };\n      img.onload = function () {\n        // only now set the backgroundImage to the img object!\n        _this17.backgroundImage = img;\n        _this17.repaintGraph();\n      };\n\n      if (imgTObj) {\n        // try loading from tiddler\n        var urlField = imgTObj.fields['_canonical_uri'];\n        if (urlField) {\n          // try loading by uri field\n          _utils2.default.getImgFromWeb(urlField, ajaxCallback);\n        } else if (imgTObj.fields.text) {\n          // try loading from base64\n          img.src = $tw.utils.makeDataUri(imgTObj.fields.text, imgTObj.fields.type);\n        }\n      } else if (bgFieldValue) {\n        // try loading directly from reference\n        _utils2.default.getImgFromWeb(bgFieldValue, ajaxCallback);\n      }\n    }\n\n    /**\n     * The graph of this widget is only repainted if the following counts:\n     *\n     * The network object exists (prerequisit).\n     *\n     * 1. We are not in fullscreen at all\n     * 2. This particular graph instance is currently running fullscreen.\n     */\n\n  }, {\n    key: 'repaintGraph',\n    value: function repaintGraph() {\n\n      var isInFS = $tw.utils.hasClass(this.document.body, 'tmap-has-fullscreen-widget');\n      if (this.network && (!isInFS || isInFS && this.enlargedMode)) {\n\n        this.logger('info', 'Repainting the whole graph');\n\n        this.network.redraw();\n        this.fitGraph(0, 1000);\n      }\n    }\n\n    /**\n     * If a button is enabled it means it is displayed on the graph canvas.\n     *\n     * @param {string} name - The name of the button to enabled. Has to\n     *     correspond with the css button name.\n     * @param {boolean} enable - True if the button should be visible,\n     *     false otherwise.\n     */\n\n  }, {\n    key: 'setGraphButtonEnabled',\n    value: function setGraphButtonEnabled(name, enable) {\n\n      var className = 'vis-button tmap-' + name;\n      var b = _utils2.default.getFirstElementByClassName(className, this.domNode);\n      $tw.utils.toggleClass(b, 'tmap-button-enabled', enable);\n    }\n\n    /**\n     * Allow the given nodes to be moveable.\n     *\n     * @param {Array<number>} nodeIds - The ids of the nodes for which\n     *     we allow or disallow the movement.\n     * @param {boolean} isMoveable - True, if the nodes are allowed to\n     *     move or be moved.\n     */\n\n  }, {\n    key: 'setNodesMoveable',\n    value: function setNodesMoveable(nodeIds, isMoveable) {\n\n      if (!nodeIds || !nodeIds.length || this.view.isEnabled('physics_mode')) {\n        // = no ids passed or in floating mode\n        return;\n      }\n\n      var updates = [];\n      var isFixed = !isMoveable;\n      for (var i = nodeIds.length; i--;) {\n\n        updates.push({\n          id: nodeIds[i],\n          fixed: { x: isFixed, y: isFixed }\n        });\n      }\n\n      this.graphData.nodes.update(updates);\n\n      if (isFixed) {\n\n        this.logger('debug', 'Fixing', updates.length, 'nodes');\n\n        // if we fix nodes in static mode then we also store the positions\n        this.view.saveNodePositions(this.network.getPositions());\n        // prevent zoom\n        this.isPreventZoomOnNextUpdate = true;\n      }\n    }\n\n    /**\n     * This function will create the dom elements for all tiddlymap-vis\n     * buttons and register the event listeners.\n     *\n     * @param {Object<string, function>} buttonEvents - The label of the\n     *     button that is used as css class and the click handler.\n     */\n\n  }, {\n    key: 'addGraphButtons',\n    value: function addGraphButtons(buttonEvents) {\n\n      var parent = _utils2.default.getFirstElementByClassName('vis-navigation', this.domNode);\n\n      for (var name in buttonEvents) {\n        var div = this.document.createElement('div');\n        div.className = 'vis-button tmap-' + name;\n\n        div.addEventListener('click', buttonEvents[name].bind(this), false);\n        parent.appendChild(div);\n\n        this.setGraphButtonEnabled(name, true);\n      }\n    }\n  }]);\n\n  return MapWidget;\n}(_widget.widget);\n\n/*** Exports *******************************************************/\n\nexports.tmap = MapWidget;\nexports.tiddlymap = MapWidget;\n//# sourceMappingURL=./maps/felixhayashi/tiddlymap/js/widget/MapWidget.js.map\n",
            "type": "application/javascript",
            "module-type": "widget"
        },
        "$:/plugins/felixhayashi/tiddlymap/license": {
            "title": "$:/plugins/felixhayashi/tiddlymap/license",
            "subtitle": "License",
            "caption": "License",
            "text": "\\rules except wikilink\n\n!! TiddlyMap\n\nCopyright (c) 2014, Felix Küppers\nAll rights reserved.\n\nTiddlyMap is licensed under the [[BSD 2-Clause License|http://opensource.org/licenses/BSD-2-Clause]]. For the exact license terms, please visit [[https://github.com/felixhayashi/TW5-TiddlyMap/blob/master/LICENSE]]. \n\n!! TiddlyWiki\n\nCreated by Jeremy Ruston, (jeremy [at] jermolene [dot] com)\n\nCopyright © Jeremy Ruston 2004-2007 Copyright © UnaMesa Association 2007-2014\n\nPublished under the following [licenses](https://github.com/Jermolene/TiddlyWiki5/tree/master/licenses):\n\n# BSD 3-clause \"New\" or \"Revised\" License (including any right to adopt any future version of a license if permitted)\n# Creative Commons Attribution 3.0 (including any right to adopt any future version of a license if permitted)\n\n!! Vis.js\n\nCopyright (c) 2014 [Almende B.V.](https://github.com/almende/vis)\n\nPublished under the following licenses:\n\n# Apache License Version 2.0, January 2004 http://www.apache.org/licenses/\n# MIT License (MIT)\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/readme": {
            "title": "$:/plugins/felixhayashi/tiddlymap/readme",
            "text": "* Please refer to the project-readme hosted at [[https://github.com/felixhayashi/TW5-TiddlyMap]].\n* A demo with several examples and explanations can be found at [[http://tiddlymap.org]]."
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tmap:unknown": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tmap:unknown",
            "description": "Automatically assigned to an edge that does not have a type assigned",
            "style": "{\"color\":\"gray\"}",
            "show-label": "false"
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tw-body:link": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tw-body:link",
            "description": "A link that is contained in the tiddler's body pointing to another resource.",
            "style": "{\"color\":\"orange\", \"dashes\":true}",
            "label": "links to",
            "text": ""
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tw-list:list": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tw-list:list",
            "description": "Contained in a list of this tiddler",
            "style": "{ \"color\": \"red\", \"dashes\":true}",
            "label": "listed in",
            "text": ""
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tw-list:tags": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes/tw-list:tags",
            "description": "A tag that refers to a tiddler of the same name.",
            "style": "{ \"color\": \"darkslategray\", \"dashes\":true}",
            "label": "tagged with"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/default": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/default",
            "caption": "Overview",
            "text": "\\rules except wikilink\n\n<div class=\"tmap-flash-message tmap-plain\">\n  Please visit the [[online docs|http://tiddlymap.org/Documentation]]\n  for more information about the available global options.\n</div>\n<table class=\"tmap-key-value-table\">\n  <tr>\n    <th align=\"left\">Plugin version</th>\n    <td><<pluginVersion>></td>\n  </tr>\n<!--\n  <tr>\n    <th align=\"left\">Datastructure version</th>\n    <td><<dataStructureVersion>></td>\n  </tr>\n-->\n  <tr>\n    <th align=\"left\">Nodes in system</th>\n    <td><<numberOfNodes>></td>\n  </tr>\n  <tr>\n    <th align=\"left\">Edges in system</th>\n    <td><<numberOfEdges>></td>\n  </tr>\n</table>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/editor": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/editor",
            "caption": "Editor",
            "text": "\\rules except wikilink\n\n<table class=\"tmap-config-table\">\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Show Neighbour&shy;hood menu\"\n      field:\"config.sys.editorMenuBar.showNeighScopeButton\"\n      descr:\"Show or hide the neighbourhood menu button.\">>\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Show Screen&shy;shot menu\"\n      field:\"config.sys.editorMenuBar.showScreenshotButton\"\n      descr:\"Show or hide the screenshot menu button.\">>\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Show Raster&shy; menu\"\n      field:\"config.sys.editorMenuBar.showRasterMenuButton\"\n      descr:\"Show or hide the raster menu button.\">>\n</table>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/fields": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/fields",
            "caption": "Field settings",
            "text": "\\rules except wikilink\n\n<table class=\"tmap-config-table\">\n  <<tmap-row type:\"input-text\"\n      title:\"Node-icon field\"\n      field:\"config.sys.field.nodeIcon\" \n      descr:\"Local image used as node image in the graphs.\">>\n  <<tmap-row type:\"input-text\"\n      title:\"Node-label field\"\n      field:\"config.sys.field.nodeLabel\" \n      descr:\"Alternative node label to use instead of the title.\">>\n  <<tmap-row type:\"input-text\"\n      title:\"Node-info field\"\n      field:\"config.sys.field.nodeInfo\" \n      descr:\"Field used as tooltip when hovering over a node in a graph.\"\n      note:\"It is prohibited to use the text field here.\">>\n</table>   \n\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/interaction": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/interaction",
            "caption": "Interaction & behaviour",
            "text": "\\rules except wikilink\n\n<table class=\"tmap-config-table\">\n  <$macrocall type=\"input-select\"\n        $name=\"tmap-row\"\n        title=\"Default startup view\"\n        field=\"config.sys.defaultView\"\n        nochoice=\"Last view used at startup\"\n        selectFilter=<<tmap \"option\" \"selector.allViewsByLabel\">>\n        descr=\"The view to display at startup\" />\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Show popups\"\n      field:\"config.sys.popups.enabled\"\n      descr:\"Set this to true if you want to see automatic\n             popups in the map.\">>\n  <$list filter=\"[config.sys.popups.enabled[true]]\">\n  <<tmap-row type:\"input-text\"\n      title:\"Popup delay\"\n      field:\"config.sys.popups.delay\"\n      descr:\"The time in miliseconds that needs to pass after\n             a tooltip is triggered.\">>\n  <<tmap-row type:\"input-text\"\n      title:\"Popup width\"\n      field:\"config.sys.popups.width\"\n      descr:\"The default max-width of the popup.\"\n      note:\"Make sure you added the desired unit (e.g. `px`).\n            Requires a wiki refresh.\">>\n  <<tmap-row type:\"input-text\"\n      title:\"Popup height\"\n      field:\"config.sys.popups.height\"\n      descr:\"The default max-height of the popup.\"\n      note:\"Make sure you added desired the unit (e.g.  `px`).\n            Requires a wiki refresh.\">>\n  </$list>\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Allow single click mode\"\n      field:\"config.sys.singleClickMode\"\n      descr:\"A single click on a node is sufficient to open the\n             corresponding tiddler.\"\n      note:\"Drag and drop will still work and does not cause a\n            tiddler to be opened. Single click is never active in\n            the map editor.\">>\n  <<tmap-row type:\"input-select\"\n      title:\"Edge click behaviour\"\n      field:\"config.sys.edgeClickBehaviour\"\n      selectFilter:\"[[nothing|Nothing]]\n                    [[manager|Open edge-type manager]]\"\n      descr:\"What should happen when you click on an edge?\">>\n  <<tmap-row type:\"input-select\" title:\"Raster size\" field:\"config.sys.raster\"\n      selectFilter:\"[[|disabled]] [[5|5px]] [[10|10px]] [[15|15px]] [[20|20px]] [[30|30px]] [[40|40px]]\"\n      descr:\"Snap nodes to an invisible raster of the given size after drag'n'drop.\"\n      note:\"Only works when the view is not in floating mode\">>\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Apply node-filter to neighbours\"\n      field:\"config.sys.nodeFilterNeighbours\"\n      descr:\"If checked, neighbours displayed in the map will be filtered\n      by the view's node-filter. Otherwise the node-filter will only be used\n      to filter the original set of nodes in the map\">>\n</table>\n\n!! Suppressed dialogs\n\n<div class=\"tmap-flash-message tmap-plain\">\n  Dialogs that you decided to suppress in the past are listed here.\n  Remove the checkmark to enable dialogs again.\n</div>\n\n<table class=\"tmap-config-table\">\n  <$list\n      filter=\"[<output>fields[]prefix[config.sys.suppressedDialogs]]\"\n      emptyMessage=\"–\">\n      <$set name=\"dialogName\" value=<<tmap basename \".\">>>\n      <$macrocall $name=\"tmap-row\"\n            type=\"input-checkbox\"\n            title=\"Suppress '$(dialogName)$' dialog\"\n            field=<<currentTiddler>> />\n      </$set>\n    <br />\n  </$list>\n</table>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/liveTab": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/liveTab",
            "caption": "Live tab",
            "text": "\\rules except wikilink\n\n<table class=\"tmap-config-table\">\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Show Live tab\"\n      field:\"liveTab\" \n      descr:\"Show or hide the live tab in the sidebar.\">>\n  <$macrocall type=\"input-select\"\n      $name=\"tmap-row\"\n      title=\"Fallback view\"\n      field=\"config.sys.liveTab.fallbackView\" \n      selectFilter=<<tmap \"option\" \"selector.allViewsByLabel\">>\n      descr=\"The view to display in the sidebar's live tab in\n             case the current tiddler did not specify a view\n             to open.\" />\n</table>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig",
            "subtitle": "{{$:/core/images/options-button}} Global configuration of TiddlyMap",
            "classes": "tmap-remove-top-space",
            "text": "\\rules except wikilink\n\n<$macrocall $name=\"tabs\"\n  default=<<concat \"$(template)$/default\">>\n  tabsList=\"[all[shadows]prefix<template>] -[<template>]\"\n/>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/verbosity": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/verbosity",
            "caption": "Verbosity",
            "text": "\\rules except wikilink\n\n<div class=\"tmap-flash-message tmap-plain\">\n  Here you can restrict the system's talkativeness.\n</div>\n\n<table class=\"tmap-config-table\">\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Debug output\"\n      field:\"config.sys.debug\" \n      descr:\"Set this to true if you want debug information to be\n             displayed in the browser console.\">>\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Show notifications\"\n      field:\"config.sys.notifications\" \n      descr:\"Set this to true if you want to receive fade-out\n             notifications for important events.\">>\n</table> "
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/vis": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/globalConfig/vis",
            "classes": "tmap-remove-top-space",
            "caption": "Graph",
            "text": "\\rules except wikilink\n\n<div class=\"tmap-flash-message tmap-info\">\n  The global vis configurations will affect all views and their\n  elements (nodes and edges) unless they are overridden on a lower\n  level. All options below are documented at\n  [[vis.js.org|http://visjs.org/docs/network]].\n</div>\n<div class=\"tmap-flash-message tmap-info\">\n  Only config items that you actually changed have an effect on\n  the graph. Other options are visible, yet, inactive.\n</div>\n<$tmap-config\n    mode=\"manage-config\"\n    inherited=\"vis-inherited\"\n    extension=\"config.vis\" />"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/configureView/default": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/configureView/default",
            "caption": "Overview",
            "text": "\\rules except wikilink\n\n<div class=\"tmap-flash-message tmap-info\">\n   All configurations __only__ affect this view.\n</div>\n\n<table class=\"tmap-key-value-table\">\n  <tr>\n    <th align=\"left\">Created on</th>\n    <td><<createdOn>></td>\n  </tr>\n  <tr>\n    <th align=\"left\">Nodes contained in graph</th>\n    <td><<numberOfNodes>></td>\n  </tr>\n  <tr>\n    <th align=\"left\">Edges contained in graph</th>\n    <td><<numberOfEdges>></td>\n  </tr>\n</table>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/configureView/editFilters": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/configureView/editFilters",
            "caption": "Edit filters",
            "text": "\\rules except wikilink\n\n<div class=\"tmap-flash-message tmap-info\">\n  Completely new to filters? Please read\n  [[Introduction to filter notation|http://tiddlywiki.com/#Introduction%20to%20filter%20notation]]\n  first.\n</div>\n\n<fieldset>\n  <legend>Filters <sup>[1]</sup></legend>\n  <table class=\"tmap-config-table tmap-large-input\">\n    <<tmap-row type:\"input-textarea\"\n        title:\"Node filter\"\n        field:\"filter.prettyNodeFltr\"\n        descr:\"In the map, only those tiddlers that match this filter\n               are shown. Drafts and system tiddlers are automatically\n               excluded.\">>\n    <<tmap-row type:\"input-textarea\"\n        title:\"Edge-type filter\"\n        field:\"filter.prettyEdgeFltr\" \n        descr:\"Only edges with a type that matches the filter are shown.\">>\n  </table>   \n</fieldset>\n\n---\n\n<sup>[1]</sup> In the editors above, a new line is equivalent to a space symbol.<br />\n<sup>[2]</sup> It is suggested to read\n[[Node and edge-type filters|http://tiddlymap.org#Node%20and%20edge-type%20filters]]\nand [[Edge-type namespaces|http://tiddlymap.org#Node%20and%20edge-type%20filters]]\nbefore using Tiddlymap's filter editor."
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/configureView/layout": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/configureView/layout",
            "caption": "Layout",
            "text": "\\rules except wikilink\n\n<table class=\"tmap-config-table\">\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Floating nodes\"\n      field:\"config.physics_mode\" \n      descr:\"Set this to true if you want your nodes to freely\n             swirl around.\">>\n  <<tmap-row type:\"input-text\"\n      title:\"Background image\"\n      field:\"config.background_image\" \n      descr:\"The title of an image tiddler to be used as background\n             in the view.\"\n      note:\"You can also use an image url directly, however, the\n            image needs be stored under the same domain as your wiki.\n            Otherwise, it won't be displayed!\">>\n</table>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/configureView/namespace": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/configureView/namespace",
            "caption": "Namespace",
            "text": "\\rules except wikilink\n\n<table class=\"tmap-config-table tmap-small-input\">\n  <<tmap-row type:\"input-text\"\n      title:\"Edge-type namespace\"\n      field:\"config.edge_type_namespace\" \n      descr:\"A namespace (like `foaf` in `foaf:knows`) that will be\n             automatically added to all edge types you create in\n             this view. The namespace is only added if the types\n             do not exist yet and do not have a namespace assigned yet.\n             Namespaces are always hidden in the graph.\"\n      note:\"Most likely, you don't want the edges created with this\n            namespace to leak into other views, moreover, you don't\n            want edges that do not possess the namespace ever to be\n            shown here. In this case, use a private marker (`_`)\n            in front of your namespace, e.g. `_mynamespace` and use\n            an appropriate edge type filter, i.e. `+[prefix[_mynamespace]]`\n            For further information see:\n            \n            * [[Edge-type namespaces|http://tiddlymap.org/#Edge-type%20namespaces]]\n            * [[Private edge types|http://tiddlymap.org/#Private%20edge%20types]]\n            \">>\n</table>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/configureView": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/configureView",
            "subtitle": "{{$:/core/images/options-button}} View configuration -- <<view>>",
            "text": "\\rules except wikilink\n\n\\define privateEdgeTypes() [[private edge-types|http://tiddlymap.org/#Private%20edge%20types]]\n\n<$macrocall $name=\"tabs\"\n  default=<<concat \"$(template)$/default\">>\n  tabsList=\"[all[shadows]prefix<template>] -[<template>]\"\n/>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/configureView/vis": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/configureView/vis",
            "caption": "Graph",
            "text": "\\rules except wikilink\n\n<div class=\"tmap-flash-message tmap-info\">\n   The local vis configurations will affect all\n   elements (nodes and edges) of this view, unless they are\n   overridden on a lower level. All options below are documented at\n   [[vis.js.org|http://visjs.org/docs/network]].\n</div>\n<div class=\"tmap-flash-message tmap-info\">\n  Only config items that you actually changed have an effect on the\n  graph. Other options are visible, yet, inactive.\n</div>\n<$tmap-config\n    mode=\"manage-config\"\n    inherited=\"vis-inherited\"\n    extension=\"config.vis\" />"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/getEdgeType": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/getEdgeType",
            "subtitle": "{{$:/plugins/felixhayashi/tiddlymap/icon}} Edge type specification",
            "text": "\\rules except wikilink\n\\rules except underscore\n\n\\define filter() $(allEdgeTypes)$ +[search:title[$(term)$]]\n\n\\define badge(color, label, tooltip)\n<span style=\"background: $color$\" title=\"$tooltip$\">$label$</span>\n\\end\n\n\\define badges()\n<$tiddler tiddler={{!!text}}>\n<$set name=\"id\" value=<<tmap \"getETyId\" \"$(view)$\">>>\n<$set name=\"isVisible\" value=<<tmap \"isETyVisible\" \"$(view)$\">>>\n<div class=\"tmap-badges\">\n  <span\n      style=\"background: darkslategray\"\n      title=\"Your input translates into this id.\">\n  <<id>>\n  </span>\n  <$list filter=\"[<isVisible>regexp[true]]\">\n    <<badge \"green\" \"visible\" \"Matches your view's filter\">>\n  </$list>\n  <$list filter=\"[<isVisible>regexp[false]]\">\n    <<badge \"red\" \"not visible\" \"Doesn't match your view's filter\">>\n  </$list>\n  <$list filter=\"[<id>!regexp[^tmap:unknown$]]\" variable=\"item\">\n    <$list filter=\"[<id>regexp[^_]]\">\n      <<badge \"purple\" \"private\" \"Not shown in other views per default\">>\n    </$list>\n    <$list filter=\"[<id>regexp[.+:.+]]\">\n      <<badge \"orange\" \"namespace\" \"This type is prefixed with a proper namespace\">>\n    </$list>\n  </$list>\n</div>\n</$set>\n</$set>\n</$tiddler>\n\\end\n\n\\define search()\n<p>\n  You are about to connect \"<$text text=\"$(fromLabel)$\" />\"\n  with \"<$text text=\"$(toLabel)$\" />\". Please specify a type.\n</p>\n<table id=\"tmap-search-table\">\n  <tr>\n    <td><b>Type:</b></td>\n    <td>\n      <$edit-text\n          focus=\"true\"\n          field=\"text\"\n          type=\"text\"\n          tag=\"input\"\n          default=\"\"\n          class=\"tmap-trigger-field\n                 tmap-triggers-ok-button-on-enter\n                 tmap-triggers-cancel-button-on-esc\" />\n      <<badges>>\n    </td>\n  </tr>\n  <tr>\n    <td></td>\n    <td>\n      <$set name=\"term\" value={{!!text}}>\n      <$set name=\"allEdgeTypes\" value=<<tmap \"option\" \"selector.allEdgeTypesById\">>>\n      <ul class=\"tmap-small-list\">\n        <$list filter=<<filter>>>\n        <li>\n          <$button class=\"tc-btn-invisible tmap-link\">\n            <$view field=\"title\" />\n            <$action-setfield $tiddler=<<output>> text={{!!title}} />\n          </$button>\n        </li>\n        </$list>\n      </ul>\n      </$set>\n      </$set>\n    </td>\n  </tr>\n</table>\n\\end\n\n<$list filter=\"[<temp>!has[more]]\" variable=\"item\"><<search>></$list>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/addNodeToMap": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/addNodeToMap",
            "subtitle": "{{$:/core/images/tag-button}} Add node",
            "classes": "tmap-modal-add-node",
            "text": "\\rules except wikilink\n\n\\define backButtonText() back to list\n\\define outputAndTemplate() [[$(output)$]] [[$(template)$]]\n\n\\define editor()\n  <$button class=\"tmap-go-back tc-btn-invisible\">\n    {{$:/core/images/chevron-left}} <<backButtonText>>\n    <$action-deletefield $tiddler=<<temp>> more template />\n    <$action-sendmessage\n        $message=\"tmap:tm-clear-tiddler\"\n        keep=\"draft.title\"\n        title=<<output>> />\n  </$button>\n\n  <$list filter=\"[<output>get[draft.title]is[tiddler]]\">\n  <div class=\"tmap-flash-message tmap-warning\">\n   Tiddler already exists! Use another title or click\n   \"<<backButtonText>>\" to cancel your edit.\n  </div>\n  </$list>\n\n  <div class=\"tmap-modal-editor\">\n    <table class=\"tmap-config-table\">\n      <tr class=\"tmap-template-select\">\n        <td>Template</td>\n        <td>\n          <$select\n              tiddler=<<temp>>\n              field=\"template\">\n            <option value=\"\"></option>\n            <$list filter=<<tmap \"option\" \"selector.allPotentialNodes\">>>\n            <option><$view field=\"title\" /></option>\n            </$list>\n          </$select>\n          <$button>Load\n            <$action-sendmessage\n                $message=\"tmap:tm-clear-tiddler\"\n                keep=\"draft.title\"\n                title=<<output>> />\n            <$list filter=\"[<temp>get[template]]\" variable=\"template\">\n            <$action-sendmessage\n                $message=\"tmap:tm-merge-tiddlers\"\n                tiddlers=<<outputAndTemplate>>\n                output=<<output>> />\n            <$action-deletefield $tiddler=<<output>> tmap.id tmap.edges />\n            </$list>\n          </$button>\n       </td>\n       <td>Press the \"load\" button to activate the template.</td>\n      </tr>\n    </table>\n    <$importvariables filter=\"[all[tiddlers+shadows]prefix[$:/core/macros/]]\">\n      <$set name=\"currentTiddler\" value=<<output>>>\n        <$transclude tiddler=\"$:/core/ui/EditTemplate\" mode=\"block\" />\n      </$set>\n    </$importvariables>\n  </div>\n\\end\n\n\\define search()\n<p>Add an existing tiddler to the map or create a new one.</p>\n<table id=\"tmap-search-table\">\n  <tr>\n    <td><b>Title:</b></td>\n    <td>\n      <$edit-text\n          tiddler=<<output>>\n          field=\"draft.title\"\n          focus=\"true\"\n          type=\"text\"\n          tag=\"input\"\n          default=\"\"\n          class=\"tmap-trigger-field\n                 tmap-triggers-ok-button-on-enter\n                 tmap-triggers-cancel-button-on-esc\" />\n      <$list filter=\"[<output>get[draft.title]!is[tiddler]]\">\n      <$button\n          tooltip=\"The tiddler does not exist yet and you may edit it\n                   before it is added to the map\">\n        {{$:/core/images/edit-button}}\n        <$action-setfield $tiddler=<<temp>> more=\"true\" />\n      </$button> <sup>[1]</sup>\n      </$list>\n    </td>\n  </tr>\n  <tr>\n    <td></td>\n    <td>\n      <$set name=\"term\" value={{!!draft.title}}>\n      <ul class=\"tmap-small-list\">\n        <$list filter=\"[search:title<term>!is[system]!has[draft.of]]\">\n        <li>\n          <$button class=\"tc-btn-invisible tmap-link\">\n            <$view field=\"title\" />\n            <$action-setfield $tiddler=<<output>> draft.title={{!!title}} />\n          </$button>\n        </li>\n        </$list>\n      </ul>\n      </$set>\n    </td>\n  </tr>\n</table>\n\n<$list filter=\"[<output>get[draft.title]!is[tiddler]]\">\n<hr />\n<sup>[1]</sup>\n<small>\n  The tiddler does not exist yet and you may edit it\n  before it is added to the map\n</small>\n</$list>\n\\end\n\n<$list filter=\"[<temp>!has[more]]\" variable=\"item\"><<search>></$list>\n<$list filter=\"[<temp>has[more]]\" variable=\"item\"><<editor>></$list>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/cannotDeleteViewDialog": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/cannotDeleteViewDialog",
            "subtitle": "{{$:/core/images/locked-padlock}} You cannot delete this view!",
            "buttons": "ok",
            "text": "\\rules except wikilink\n\nIt is not possible to delete the current view as ''<<count>>'' tiddlers\nare referencing it. To delete the view you must first remove the tiddlymap\nwidgets in the tiddlers listed below or change their view attributes.\n\n''References''\n\n<ul>\n<$list filter=<<refFilter>> variable=\"item\">\n  <li><$link><<item>></$link></li>\n</$list>\n</ul>\n\nAfter the references are removed, you may delete the view.\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/getConfirmation": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/getConfirmation",
            "subtitle": "{{$:/core/images/import-button}} You must confirm in order to proceed!",
            "text": "\\rules except wikilink\n\n<<message>>\n\n''Are you really sure you want to do this?''"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/createView": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/createView",
            "subtitle": "{{$:/core/images/new-button}} Creating a new view",
            "text": "\\rules except wikilink\n\n<table class=\"tmap-config-table\">\n  <<tmap-row type:\"input-text\"\n      title:\"View name\"\n      field:\"name\"\n      focus:\"true\"\n      class:\"tmap-trigger-field\n             tmap-triggers-ok-button-on-enter\n             tmap-triggers-cancel-button-on-esc\"\n      descr:\"The name for the new view. If no name is entered,\n             the program will invent one for you.\"\n      note:\"You cannot override an existing view. In this case,\n            you need to delete the old view first! You must no use\n            slashes (`/`) in the name.\">>\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Clone view\"\n      field:\"clone\"\n      descr:\"Use the view that is currently displayed in the\n             editor as blueprint. The view will be an __exact__\n             clone of the current one, only with a different\n             name.\">>\n</table>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/deleteNodeDialog": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/deleteNodeDialog",
            "subtitle": "{{$:/core/images/delete-button}} You are about to delete <<count>> nodes",
            "text": "\\rules except wikilink\n\n''Please choose an option or abort:''\n\n<$radio tiddler=<<output>> field=\"delete-from\" value=\"system\">\n  Delete nodes from system <sup>[1]</sup>\n</$radio><br />\n<$radio tiddler=<<output>> field=\"delete-from\" value=\"filter\">\n  Delete nodes from graph's filter <sup>[2]</sup>\n</$radio>\n\nThe following nodes will be deleted:\n\n<ul>\n<$list filter=<<tiddlers>>>\n  <li><$view tiddler={{!!title}} field=\"title\" /></li>\n</$list>\n</ul>\n\n---\n\n<sup>[1]</sup>\n<small>This will delete all nodes, their corresponding tiddlers and all connected edges.</small><br/>\n<sup>[2]</sup>\n<small>''Important:'' Removing a node from the graph's filter only works, if the node has been added in the map editor per double click or via \"Add Node\". If the node hasn't been added as mentioned above, you need to change the underlying tiddler in a way that it doesn't match your filter anymore, if you don't want it to be displayed in the graph.</small>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/dublicateIdInfo": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/dublicateIdInfo",
            "subtitle": "{{$:/core/images/info-button}} Dublicate id detected",
            "buttons": "ok_suppress",
            "text": "\\rules except wikilink\n\nTiddlyMap requires the value of the id field (\"tmap.id\") to be\nunique in order to correctly identify nodes and tiddlers.\n\nThe id of the \"<<param.changedTiddler>>\" already exists for these tiddlers:\n\n<ul>\n<$list filter=<<param.filter>> variable=\"item\">\n  <li><$link><<item>></$link></li>\n</$list>\n</ul>\n\nTherefore TiddlyMap\n\n* assigned a new id to tiddler \"<<param.changedTiddler>>\"\n* removed all edges from \"<<param.changedTiddler>>\"\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/edgeNotVisible": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/edgeNotVisible",
            "subtitle": "{{$:/core/images/info-button}} Edge will not be visible in view \"<<view>>\"",
            "buttons": "ok_suppress",
            "text": "\\rules except wikilink\n\nYou just created an edge of type\n<code><$text text=<<type>> /></code> that will not be\nvisible in this view because it doesn't match your\nedge-type filter settings.\n\nThe current edge-type filter of view \"<<view>>\" looks like this:\n\n<pre><code><$text text=<<eTyFilter>> /></code></pre>\n\nTo have the newly added type displayed in your view, adjust your\nedge-type filter accordingly. \n\nSome suggestions:\n\n<ul>\n  <li>\n    Explicitly add the type to the filter:\n    <code><$text text=\"[[\" /><$text text=<<type>> /><$text text=\"]]\" /></code>\n  </li>\n  <li>\n  <$set\n      filter=\"[<type>regexp[:]splitbefore[:]]\"\n      name=\"prefix\"\n      emptyValue=<<tmap halfOfString \"$(type)$\">>>\n  Add a filter rule (e.g. a prefix filter) that will match\n  your type: <code>[prefix[<<prefix>>]]</code>\n  </$set>\n  </li>\n  <li>Make your current view-filter less restrictive.</li>\n</ul>\n\nFor further information, please see:\n[[Node and edge-type filters|http://tiddlymap.org#Node%20and%20edge-type%20filters]]."
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/editNode/default": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/editNode/default",
            "caption": "Global node style",
            "classes": "tmap-remove-top-space",
            "text": "\\rules except wikilink\n\n<div class=\"tmap-flash-message tmap-info\">\n  A node's ''global configuration''\n  (also referred to as //global individual config//) defines its\n  individual appearance and behaviour in all views.\n</div>\n<<maybeShowTidColorWarning>>\n    \n<$macrocall $name=\"sharedSettings\"\n    twIconField=<<tidIconField>>\n    faIconField=\"global.tmap.fa-icon\"\n    labelField=<<tidLabelField>> />\n\n<$macrocall $name=\"visConfiguration\"\n    mode=\"manage-node-types\"\n    extensionField=\"global.tmap.style\"\n    styleName=\"node's global style\"\n    inheritedList=\"[[inherited-global-default-style]]\n                   [[inherited-local-default-style]]\n                   [[inherited-group-styles]]\" />"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/editNode/local": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/editNode/local",
            "caption": "Local node style",
            "classes": "tmap-remove-top-space",
            "text": "\\rules except wikilink\n    \n<div class=\"tmap-flash-message tmap-info\">\n  The ''local node configuration'' \n  (also referred to as //view-specific node configuration//)\n  overrides the //global individual configuration// and only affects\n  the node's appearance and behaviour in the current view.\n</div>\n<<maybeShowTidColorWarning>>\n\n<fieldset>\n  <legend>Behaviour</legend>\n  <table class=\"tmap-config-table\">\n    <$macrocall type=\"input-select\"\n        $name=\"tmap-row\"\n        title=\"Open view\"\n        field=\"local.open-view\"\n        nochoice=\"Disabled\"\n        selectFilter=<<tmap \"option\" \"selector.allViewsByLabel\">>\n        descr=\"Clicking on this node will open the specified\n               view instead of the tiddler represented by this node.\" />\n  </table>\n</fieldset>\n\n<$macrocall $name=\"sharedSettings\"\n    twIconField=\"local.tw-icon\"\n    faIconField=\"local.fa-icon\"\n    labelField=\"local.label\" />\n                         \n<$macrocall $name=\"visConfiguration\"\n    mode=\"manage-node-types\"\n    extensionField=\"local-node-style\"\n    styleName=\"node's local style\"\n    inheritedList=\"[[inherited-global-default-style]]\n                   [[inherited-local-default-style]]\n                   [[inherited-group-styles]]\n                   [[global.tmap.style]]\" />"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/editNode": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/editNode",
            "subtitle": "{{$:/core/images/edit-button}} Editing style of node \"<<tiddler>>\"",
            "classes": "tmap-remove-top-space",
            "text": "\\rules except wikilink\n\n\\define maybeShowTidColorWarning()\n  <$list filter=\"[<tidColor>regexp[.+]]\">\n  <div class=\"tmap-flash-message tmap-warning\">\n    You have set the tiddler's color\n    field to \"<<tidColor>>\". This value will be completely ignored\n    when you change node's color properties in the vis editor below.\n  </div>\n  </$list>\n\\end\n\n\\define iconSettings(twIconField, faIconField)\n  <fieldset>\n    <legend>Icon Settings</legend>\n    <table class=\"tmap-config-table\">\n      <<tmap-row type:\"input-text\"\n          title:\"TW-icon\"\n          field:\"$twIconField$\"\n          descr:\"A tiddlywiki image reference.\n                 For example '$:/core/icon' for Movotun Jack.\">>\n      <<tmap-row type:\"input-text\"\n          title:\"FA-icon\"\n          field:\"$faIconField$\"\n          descr:\"A Font Awesome icon code.\n                 For example 'f206' for the bicycle symbol.\">>\n    </table>\n  </fieldset>\n\\end\n\n\\define sharedSettings(twIconField, faIconField, labelField)\n  <fieldset>\n    <legend>General Settings</legend>\n    <table class=\"tmap-config-table\">\n      <<tmap-row type:\"input-text\"\n          title:\"Label\"\n          field:\"$labelField$\"\n          descr:\"Use this value as node label.\">>\n    </table>\n  </fieldset>\n  <!-- display icon fieldset -->\n  <<iconSettings \"$twIconField$\" \"$faIconField$\">>  \n\\end\n\n<$macrocall\n  $name=\"tabs\"\n  default=<<concat \"$(template)$/default\">>\n  tabsList=\"[all[shadows]prefix<template>] -[<template>]\"\n/>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor/draft": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor/draft",
            "caption": "Draft",
            "text": "\\rules except wikilink\n\n<div class=\"tmap-modal-editor\">\n  <$importvariables filter=\"[all[tiddlers+shadows]prefix[$:/core/macros/]]\">\n    <$set name=\"currentTiddler\" value=<<draftTRef>> >\n      <$transclude tiddler=\"$:/core/ui/EditTemplate\" field=\"text\" mode=\"block\" />\n    </$set>\n  </$importvariables>\n</div>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor/original": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor/original",
            "caption": "Current Version",
            "text": "\\rules except wikilink\n\n<div class=\"tmap-modal-editor\">\n  <$importvariables filter=\"[all[tiddlers+shadows]prefix[$:/core/macros/]]\">\n    <$set name=\"currentTiddler\" value=<<originalTRef>> >\n      <$transclude tiddler=\"$:/core/ui/ViewTemplate\" field=\"text\" mode=\"block\" />\n    </$set>\n  </$importvariables>\n</div>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor",
            "subtitle": "{{$:/core/images/edit-button}} <<originalTRef>>",
            "classes": "tmap-modal-fullscreen-editor tmap-remove-top-space",
            "text": "\\rules except wikilink\n\n\\define defaultTab() $:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor/original\n\n<$macrocall $name=\"tabs\"\n    default=<<defaultTab>>\n    tabsList=\"[all[shadows]prefix[$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenTiddlerEditor/]]\" />"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/fieldChanged": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/fieldChanged",
            "subtitle": "{{$:/core/images/info-button}} The field \"<<name>>\" changed",
            "text": "\\rules except wikilink\n\nYou changed the field \"<<name>>\" from \"<<oldValue>>\" to \"<<newValue>>\".\n\nIt is recommended to let TiddlyMap copy all values from the former field \"<<oldValue>>\" to the new field \"<<newValue>>\" so the data stored in \"<<oldValue>>\" is not lost. This operation has to be done now or never.\n\nDo you want to move each tiddler's existing \"<<oldValue>>\" value to \"<<newValue>>\"? Please note that any value currently stored in \"<<newValue>>\" would consequently be overridden and the old field \"<<oldValue>>\" would be eventually removed!"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenNotSupported": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/fullscreenNotSupported",
            "subtitle": "{{$:/core/images/info-button}} Your machine does not support fullscreen",
            "buttons": "ok_suppress",
            "text": "\\rules except wikilink\n\nPlease have a look [[here|http://caniuse.com/#feat=fullscreen]] to see a list of supported devices/browsers.\n\nSorry for this :("
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/renameView": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/renameView",
            "subtitle": "{{$:/core/images/tag-button}} Please specify a view name",
            "text": "\\rules except wikilink\n\n''Name:''\n<$edit-text focus=\"true\" tiddler=<<output>> field=\"text\" type=\"text\" tag=\"input\" default=\"\"\n            class=\"tmap-trigger-field tmap-triggers-ok-button-on-enter\" />\n\nNote that ''<<count>>'' tiddlers are referencing this view.\n\n<$reveal type=\"nomatch\" text=\"0\" default=<<count>>>\n\nRenaming the view will cause the reference to be invalid.\nIt is recommended to first remove the tiddlymap widgets in\nthe tiddlers listed below or change their view attributes\naccordingly.\n\n''References''\n\n<ul>\n<$list filter=<<refFilter>> variable=\"item\">\n  <li><$text text=<<item>> /></li>\n</$list>\n</ul>\n\n</$reveal>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/saveCanvas": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/saveCanvas",
            "subtitle": "{{$:/core/images/options-button}} Save a snapshot image of view \"<<view>>\"",
            "text": "\\rules except wikilink\n\n\\define preview()\n<div class=\"tmap-save-canvas-preview\">\n  <$transclude tiddler=<<snapshot>> /><br />\n  Measures: <<width>> × <<height>>\n</div>\n\\end\n\n<table class=\"tmap-config-table\">\n<!--\n  <<tmap-row type:\"input-text\"\n      title:\"Name\"\n      field:\"name\">\n-->\n<$macrocall $name=\"tmap-row\"\n    type=\"input-text\"\n    title=\"Name\"\n    field=\"name\"\n    descr=<<preview>> />\n</table>\n\n<fieldset><legend>Options</legend>\n  <table class=\"tmap-config-table\">\n    <<tmap-row type:\"input-radio\"\n        title:\"Action\"\n        field:\"action\" \n        selectFilter:\"[[download|Download]]\n                      [[wiki|Save in wiki]]\n                      [[placeholder|Use as placeholder for this view]]\"\n        descr:\"Save the image by downloading it to your computer or\n               save it as a tiddler in your wiki.<br /><br />\n               A third option is to make TiddlyMap use this image as\n               placeholder for the current view. Placeholders are used\n               when tiddlers are exported in form of static html\n               or when editing a tiddler while having the preview\n               shown. In this case the title input is ignored.\">>\n  </table>\n</fieldset>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog",
            "text": "\\rules except wikilink\n\n<div class=<<classes>>>\n<$importvariables\n    filter=\"[[$:/plugins/felixhayashi/tiddlymap/misc/macros]]\n            [[$:/core/macros/tabs]]\">\n<$transclude tiddler=<<template>> mode=\"block\" />\n</$importvariables>\n</div>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/welcome": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/welcome",
            "subtitle": "{{$:/core/images/info-button }} Welcome",
            "buttons": "ok",
            "text": "\\rules except wikilink\n\nIt seems that you freshly installed TiddlyMap.\n\n* In case you need any help, please consult the [[online docs|http://tiddlymap.org#Documentation]] first.\n* You are welcome to create an [[issue|https://github.com/felixhayashi/TW5-TiddlyMap/issues]] at GitHub for any bug you discover.\n* Make sure to revisit the [[demo site|http://tiddlymap.org]] to see whether your version is up-to-date.\n* If you like TiddlyMap, please give it a star at [[GitHub|https://github.com/felixhayashi/TW5-TiddlyMap]] or tell your friends about it :)\n* ''Please note:'' TiddlyMap is distributed under the [[BSD 2-Clause License|http://opensource.org/licenses/BSD-2-Clause]], which belongs to the same license family, as the license used by TiddlyWiki. By using this plugin you agree to the product's [[License Terms|https://github.com/felixhayashi/TW5-TiddlyMap/blob/master/LICENSE]].\n\nEnjoy!\n\n---\n\nTiddlyMap will configure your wiki for optimal use. Everything can be changed back later by you, via the TiddlyWiki configurations panel, so no worries. If you checked some of the options below, please save &amp; restart after closing this dialog.\n\n<table class=\"tmap-config-table\">\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Optimize storyview\"\n      field:\"config.storyview\"\n      descr:\"Sets the storyview to 'top' for optimal scrolling.\">>\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Optimize sidebar\"\n      field:\"config.sidebar\"\n      descr:\"Sets sidebar layout to 'fixed-fluid' for larger editor.\">>\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Optimize navigation\"\n      field:\"config.navigation\"\n      descr:\"Sets navigation style to open tiddlers at top for better map navigation.\">>\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Create demo welcome map\"\n      field:\"config.demo\"\n      descr:\"Creates a little hello world welcome map for you.\">>\n</table>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/widgetCodeGenerator": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/widgetCodeGenerator",
            "subtitle": "{{$:/core/images/permalink-button}} Widget Code Generator",
            "buttons": "close",
            "text": "\\rules except wikilink\n\n<div class=\"tmap-flash-message tmap-info\">\n  Use the code below to embed a view in a tiddler.\n</div>\n\n<pre style=\"white-space: normal;\">\n&lt;$tmap\n\n<$list filter=\"[<output>has[var.view]]\">\n  view=\"<$view field='var.view' />\"</$list>\n<$list filter=\"[<output>field:var.click-to-use[true]]\">\n  click-to-use=\"true\"</$list>\n<$list filter=\"[<output>has[var.editor]]\">\n  editor=\"<$view field='var.editor' />\"</$list>\n<$list filter=\"[<output>has[var.width]]\">\n  width=\"<$view field='var.width' />\"</$list>\n<$list filter=\"[<output>has[var.height]]\">\n  height=\"<$view field='var.height' />\"</$list>\n<$list filter=\"[<output>has[var.class]]\">\n  class=\"<$view field='var.class' />\"</$list>\n<$list filter=\"[<output>field:var.show-buttons[false]]\">\n  show-buttons=\"false\"</$list>\n<$list filter=\"[<output>has[var.design]]\">\n  design=\"<$view field='var.design' />\"</$list>&gt;&lt;/$tmap&gt;\n</pre>\n\n<fieldset>\n  <legend>Parameters</legend> \n  <table class=\"tmap-config-table\">\n      <$macrocall type=\"input-select\"\n          $name=\"tmap-row\"\n          title=\"View\"\n          field=\"var.view\"\n          nochoice=\" \"\n          selectFilter=<<tmap \"option\" \"selector.allViewsByLabel\">>\n          descr=\"The view to bind the wiedget to\" />\n      <<tmap-row type:\"input-select\"\n          title:\"Editor bar\"\n          field:\"var.editor\"\n          selectFilter:\"[[|Hidden]]\n                        [[vis|Simple]]\n                        [[advanced|Advanced]]\"\n          descr:\"Whether the widget should act as an editor or not.\">>\n      <<tmap-row type:\"input-select\"\n          title:\"Design\"\n          field:\"var.design\"\n          selectFilter:\"[[|Normal]]\n                        [[plain|Plain]]\"\n          descr:\"Usually a header is displayed and borders. Plain\n                 design will only show the mere graph.\">>\n      <<tmap-row type:\"input-text\"\n          title:\"Height\"\n          field:\"var.height\"\n          descr:\"Graph's height in css units. Defaults to '300px'.\">>\n      <<tmap-row type:\"input-text\"\n          title:\"Width\"\n          field:\"var.width\"\n          descr:\"Graph's width in css units. Defaults to '100%'.\">>\n      <<tmap-row type:\"input-text\"\n          title:\"Class\"\n          field:\"var.class\"\n          descr:\"A custom class to apply your own css.\">>\n      <<tmap-row type:\"input-checkbox\"\n          title:\"Click to use\"\n          field:\"var.click-to-use\"\n          default:\"false\"\n          descr:\"A click is needed to enable the graph.\">>\n      <<tmap-row type:\"input-checkbox\"\n          title:\"Show buttons\"\n          field:\"var.show-buttons\"\n          default:\"true\"\n          descr:\"Show or hide the graph's navigation buttons.\">>\n  </table>\n</fieldset>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialogFooter/close": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialogFooter/close",
            "text": "\\rules except wikilink\n\n<$button class=\"tmap-dialog-button tmap-close-button\" tooltip=\"Close this dialog\">Close\n\n  <!-- trigger dialog callback -->\n  <$action-setfield $tiddler=<<result>> text=\"1\" />\n                       \n</$button>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok",
            "text": "\\rules except wikilink\n\n<$button class=\"tmap-dialog-button tmap-ok-button\" tooltip=\"Confirm dialog\">OK\n\n  <!-- trigger dialog callback -->\n  <$action-setfield $tiddler=<<result>> text=\"1\" />\n                       \n</$button>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok_cancel": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok_cancel",
            "text": "\\rules except wikilink\n\n<$transclude tiddler=\"$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok\" mode=\"inline\" />\n<$button class=\"tmap-dialog-button tmap-cancel-button\" tooltip=\"Close dialog without saving\">Cancel\n  <!-- trigger dialog callback -->\n  <$action-setfield $tiddler=<<result>> text=\"\" />\n</$button>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok_suppress": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialogFooter/ok_suppress",
            "text": "\\rules except wikilink\n\n<$set name=\"currentTiddler\" value=<<title>> >\n\n<$checkbox field=\"suppress\" checked=\"1\" unchecked=\"0\" default=\"0\"> Do not show this dialog again</$checkbox>\n<$button class=\"tmap-dialog-button tmap-ok-button\" tooltip=\"Confirm this dialog\">OK\n\n  <!-- trigger dialog callback -->\n  <$action-setfield $tiddler=<<result>> text=\"1\" />\n  \n  <!-- suppress dialog in the future -->\n  <$action-sendmessage $message=\"tmap:tm-suppress-dialog\"\n                       dialog=<<templateId>>\n                       suppress={{!!suppress}} />\n                       \n</$button>\n\n</$set>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialogFooter": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialogFooter",
            "text": "\\rules except wikilink\n\n\\define footer() $:/plugins/felixhayashi/tiddlymap/dialogFooter/$(buttons)$\n\n<$transclude tiddler=<<footer>> />\n\n<!-- we need this button to be able to close a tiddler from outside programmatically -->\n<$button class=\"tmap-hidden-close-button\" message=\"tm-close-tiddler\" />"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialogFooter/element_type_manager": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialogFooter/element_type_manager",
            "text": "\\rules except wikilink\n\n<$button\n    class=\"tmap-dialog-button tmap-save-button\"\n    tooltip=\"Save the current changes\">Save\n  <$action-sendmessage\n      $message=\"tmap:tm-save-type-form\"\n      mode=<<mode>>\n      output=<<output>> />\n</$button>\n<$button\n    class=\"tmap-dialog-button tmap-cancel-button\"\n    tooltip=\"Cancel the most resent changes and exit\">Quit\n  <$action-setfield $tiddler=<<result>> text=\"1\" />\n</$button>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/deleteType": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/deleteType",
            "caption": "Removal",
            "text": "\\rules except wikilink\n\n\\define manage-edge-types()\n  <$macrocall $name=\"tmap-row\"\n      type=\"input-checkbox\"\n      title=\"Delete type\"\n      field=\"temp.deleteType\"\n      default={{!id}}\n      readonly={{!!temp.idImmutable}}\n      descr=\"If you want to delete this type, set this to true\n             and click the save button afterwards. Predefined system\n             types cannot be deleted.\" note=\"Consequently, all edges\n             of this type will be deleted.\" />\n\\end\n\n\\define manage-node-types()\n  <$macrocall $name=\"tmap-row\"\n      type=\"input-checkbox\"\n      title=\"Delete type\"\n      field=\"temp.deleteType\"\n      default={{!id}}\n      readonly={{!!temp.idImmutable}}\n      descr=\"If you want to delete this type, set this to true and\n             click the save button afterwards. Predefined system\n             types cannot be deleted.\" />\n\\end\n\n<table class=\"tmap-config-table\"><$macrocall $name=<<mode>> /></table>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/description": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/description",
            "caption": "Description",
            "text": "\\rules except wikilink\n\n\\define manage-edge-types()\n  <<tmap-row type:\"input-textarea\"\n      title:\"Description\"\n      field:\"description\"\n      descr:\"An optional description for this type. The\n             description will be displayed as tooltip when\n             moving the mouse over an edge of this type.\">>\n\\end\n\n\\define manage-node-types()\n  <<tmap-row type:\"input-textarea\"\n      title:\"Description\"\n      field:\"description\" \n      descr:\"An optional description for this type.\">>\n\\end\n\n<table class=\"tmap-config-table\">\n  <$macrocall $name=<<mode>> />\n</table>\n\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/generalSettings": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/generalSettings",
            "caption": "General",
            "text": "\\rules except wikilink\n\n\\define manage-edge-types()\n  <<tmap-row type:\"input-text\"\n      title:\"Label\"\n      field:\"label\" \n      descr:\"An optional alias used as edge-label.\">>\n  <<tmap-row type:\"input-checkbox\"\n      title:\"Show label\"\n      field:\"show-label\"\n      default:\"true\"\n      descr:\"If unchecked, no edge label will be displayed.\">>\n\\end\n\\define manage-node-types()\n  <$list filter=\"[<currentTiddler>!regexp:id[tmap:]]\">\n  <<tmap-row type:\"input-textarea\"\n      title:\"Scope\"\n      field:\"scope\" \n      descr:\"A filter expression that defines, which nodes inherit\n             this node-type and its style.\">>\n  </$list>\n  <$macrocall type=\"input-select\"\n      $name=\"tmap-row\" \n      title=\"Priority\"\n      field=\"priority\"\n      selectFilter=<<tmap \"scale\" \"100\">>\n      descr=\"When a type has a a higher priority than another type,\n             its style will override the other style\" />\n\\end\n\n<table class=\"tmap-config-table\">\n  <$macrocall\n    $name=\"tmap-row\"\n    title=\"Identifier\"\n    field=\"temp.newId\"\n    type=\"input-text\"\n    default={{!!id}}\n    readonly={{!!temp.idImmutable}}\n    descr=\"A unique identifier\"\n  />\n  <$macrocall $name=<<mode>> />\n</table>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/overview": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/overview",
            "caption": "Overview",
            "text": "\\rules except wikilink\n\n\\define date(f) <$view field=$f$ format=\"date\" template=\"DDth mmm hh:mm:ss\"/>\n\n! <$link to={{!!typeTRef}}><$view field=\"id\" /></$link>\n\n<table class=\"tmap-key-value-table\">\n  <tr>\n    <th align=\"left\">Created on</th>\n    <td>\n      <<date \"created\">>\n    </td>\n  </tr>\n  <tr>\n    <th align=\"left\">Modified on</th>\n    <td><<date \"modified\">></td>\n  </tr>\n  <tr>\n    <th align=\"left\">Usage count</th>\n    <td>\n      <span class=\"tmap-edge-type-specific\">\n        <$view field=\"temp.usageCount\" />\n      </span>\n      <span class=\"tmap-node-type-specific\">\n        <$count filter={{!!scope}}>0</$count>\n      </span>\n    </td>\n  </tr>\n</table>\n\n<$view field=\"description\">//No description available//</$view>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/styling": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/styling",
            "caption": "Styling",
            "text": "\\rules except wikilink\n\n\\define url()\n  <$set\n      filter=\"[<mode>prefix[manage-edge-types]]\"\n      name=\"module\"\n      value=\"edges\"\n      emptyValue=\"nodes\">\n    [[visjs.org|http://visjs.org/docs/network/$(module)$]]\n  </$set>\n\\end\n\n<fieldset class=\"tmap-node-type-specific\">\n  <legend>Icon Settings</legend>\n  <table class=\"tmap-config-table\">\n    <<tmap-row type:\"input-text\"\n        title:\"TW-icon\"\n        field:\"tw-icon\"\n        descr:\"A tiddlywiki image reference.\n               For example '$:/core/icon' for Movotun Jack.\">>\n    <<tmap-row type:\"input-text\"\n        title:\"FA-icon\"\n        field:\"fa-icon\"\n        descr:\"A Font Awesome icon code.\n               For example 'f206' for the bicycle symbol.\">>\n  </table>\n</fieldset>\n\n<fieldset><legend>Visjs styles</legend>\n  <div class=\"tmap-flash-message tmap-info\">\n     All visjs options below are documented at <<url>>.\n  </div>\n  <div class=\"tmap-flash-message tmap-info\">\n     Only config items that you actually changed have an effect on\n     the graph. Other options are visible, yet, inactive.\n  </div>\n  <$tmap-config\n      mode=<<mode>>\n      inherited=\"vis-inherited\"\n      extension=\"style\" />\n</fieldset>"
        },
        "$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager": {
            "title": "$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager",
            "subtitle": "{{$:/core/images/tag-button}} <<topic>>",
            "buttons": "element_type_manager",
            "classes": "tmap-remove-top-space",
            "text": "\\rules except wikilink\n\n\\define defaultTab()\n$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/overview\n\\end\n\n\\define settingsTab()\n$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/generalSettings\n\\end\n\n\\define tabsFilter()\n[all[shadows]prefix[$:/plugins/felixhayashi/tiddlymap/dialog/MapElementTypeManager/]]\n\\end\n\n\\define searchFilter()\n$(searchSelector)$\n+[sort[title]nsort[priority]]\n+[removeprefix<typeRootPath>removeprefix[/]]\n+[search:title{$:/temp/tmap/MapElementTypeSearch}]\n\\end\n\n\\define managerClass() tmap-$(mode)$\n\n\\define typePath() $(typeRootPath)$/$(id)$\n\n<div id=\"tmap-element-type-manager\" class=<<managerClass>>>\n  <div>\n    <div class=\"tmap-searchbar\">\n      <$edit-text\n          focus=\"true\"\n          tiddler=\"$:/temp/tmap/MapElementTypeSearch\"\n          type=\"text\"\n          tag=\"input\"\n          default=\"\" />\n      <$list filter=\"[{$:/temp/tmap/MapElementTypeSearch}regexp[.+]]\n                     +[addprefix[/]]\n                     +[addprefix<typeRootPath>]\n                     +[!is[tiddler]!is[shadow]]\">\n      <$button tooltip=\"Create a new type of this name\">\n      {{$:/core/images/new-button}}\n        <$action-sendmessage\n            $message=\"tmap:tm-create-type\"\n            mode=<<mode>>\n            id={{$:/temp/tmap/MapElementTypeSearch}}\n            output=<<output>> />\n        <$action-setfield $tiddler=\"$:/temp/tmap/MapElementTypeSearch\" text=\"\" />\n      </$button>\n      </$list>\n\n    </div>\n    <ul>\n      <$list\n          filter=<<searchFilter>>\n          emptyMessage=<<noTypeFound>>\n          variable=\"id\">\n      <li>\n        <span class=\"tmap-ranking tmap-node-type-specific\">\n          # <$view tiddler=<<typePath>> field=\"priority\">1</$view>\n        </span>\n        <$button class=\"tc-btn-invisible tmap-link\"><<id>>\n          <$action-setfield\n              $tiddler=<<qualify \"$:/state/tabs/MapElementTypeManager\">>\n              text=<<defaultTab>> />\n          <$action-sendmessage\n              $message=\"tmap:tm-load-type-form\"\n              id=<<id>>\n              mode=<<mode>>\n              output=<<output>> />\n        </$button>\n      </li>\n      </$list>\n    </ul>\n  </div>\n  <div>\n    <$reveal type=\"nomatch\" text=\"\" default={{!!id}} >\n      <$macrocall\n          $name=\"tabs\"\n          default=<<defaultTab>>\n          state=\"$:/state/tabs/MapElementTypeManager\"\n          tabsList=<<tabsFilter>> />\n    </$reveal>\n    <$reveal type=\"match\" text=\"\" default={{!!id}} >\n      <div class=\"tmap-flash-message tmap-info\">\n        Please select a type from the list or create a new one by\n        entering the type name in the search field on the left.\n      </div>\n      <div class=\"tmap-flash-message tmap-info tmap-node-type-specific\">\n        The number next to the node-type label represents it's priority.\n      </div>\n    </$reveal>\n  </div>\n</div>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/editor/contextMenu/node": {
            "title": "$:/plugins/felixhayashi/tiddlymap/editor/contextMenu/node",
            "text": "\\define single()\n  <$list filter=\"\n      [[tmap:tm-toggle-central-topic, $:/core/images/star-filled, Toggle central topic]]\n      [[tmap:tm-delete-element, $:/core/images/delete-button, Delete node]]\">\n    <$button class=\"tc-btn-invisible\">\n      <$action-sendmessage $message=<<tmap \"splitAndSelect\" \", \" \"0\">> />\n      <$transclude tiddler=<<tmap \"splitAndSelect\" \", \" \"1\">> />\n      <<tmap \"splitAndSelect\" \", \" \"2\">>\n    </$button>\n  </$list>\n\\end\n\n\\define multi()\n  <$list filter=\"\n      [[tmap:tm-delete-element, $:/core/images/delete-button, Delete selected nodes]]\">\n    <$button class=\"tc-btn-invisible\">\n      <$action-sendmessage $message=<<tmap \"splitAndSelect\" \", \" \"0\">> />\n      <$transclude tiddler=<<tmap \"splitAndSelect\" \", \" \"1\">> />\n      <<tmap \"splitAndSelect\" \", \" \"2\">>\n    </$button>\n  </$list>\n\\end\n\n<div class=\"tc-drop-down\">\n  <$macrocall $name=<<mode>> />\n</div>"
        },
        "$:/plugins/felixhayashi/tiddlymap/misc/advancedEditorBar": {
            "title": "$:/plugins/felixhayashi/tiddlymap/misc/advancedEditorBar",
            "text": "\\rules except wikilink\n\\define showEdgeField() show-$(curEdgeId)$\n\n<!-- === View Switcher ========================================== -->\n\n<div class=\"tmap-menu-bar\">\n  View:\n  <$reveal type=\"match\" text=\"false\" default=<<isViewBound>> >\n    <$select\n        tiddler=<<viewHolder>>\n        field=\"text\"\n        default=<<viewLabel>> >\n      <$list filter=<<tmap \"option\" \"selector.allViewsByLabel\">> >\n        <option value={{!!title}}>\n          <$view tiddler={{!!title}} field=\"title\" />\n        </option>\n      </$list>\n    </$select>\n  </$reveal>\n  <$reveal type=\"match\" text=\"true\" default=<<isViewBound>> >\n    <b><<viewLabel>></b>\n  </$reveal>\n\n<!-- === Menu =================================================== -->\n\n  <$button\n      popup=<<qualify \"$:/temp/menu\">>\n      tooltip=\"Open the Menu\">{{$:/core/images/menu-button}}\n  </$button>\n\n  <$reveal type=\"popup\" position=\"below\" state=<<qualify \"$:/temp/menu\">> >\n    <div class=\"tc-drop-down\">\n      <a href=\"http://tiddlymap.org#Documentation\" target=\"_blank\">\n        {{$:/core/images/info-button}} Open online help\n      </a>\n      <$button class=\"tc-btn-invisible\" message=\"tmap:tm-create-view\">\n        {{$:/core/images/new-button}} Create new view\n      </$button>\n      <$button class=\"tc-btn-invisible\" message=\"tmap:tm-generate-widget\">\n        {{$:/core/images/permalink-button}} Grab widget code\n      </$button>\n      <div class=\"tmap-list-separator\">Global configurations:</div>\n      <$button class=\"tc-btn-invisible\" message=\"tmap:tm-configure-system\">\n        {{$:/core/images/options-button}} Configure TiddlyMap\n      </$button>\n      <$button class=\"tc-btn-invisible\" message=\"tmap:tm-manage-edge-types\">\n        <span class=\"tmap-unicode-icon\">◭</span> Manage edge-types\n      </$button>\n      <$button class=\"tc-btn-invisible\" message=\"tmap:tm-manage-node-types\">\n        <span class=\"tmap-unicode-icon\">▢</span> Manage node-types\n      </$button>\n      <div class=\"tmap-view-actions\">\n        <div class=\"tmap-list-separator\">Actions for this view:</div>\n        <$button class=\"tc-btn-invisible\" message=\"tmap:tm-edit-view\">\n          {{$:/core/images/options-button}} Configure view\n        </$button>\n        <$button class=\"tc-btn-invisible\" message=\"tmap:tm-rename-view\">\n          {{$:/core/images/tag-button}} Rename view\n        </$button>\n        <$button class=\"tc-btn-invisible\" message=\"tmap:tm-delete-view\">\n          {{$:/core/images/delete-button}} Delete view\n        </$button>\n      </div>\n    </div>\n  </$reveal>\n\n<!-- === Neighbourhood menu ===================================== -->\n\n  <$reveal\n      type=\"match\"\n      text=\"true\"\n      default=<<tmap \"option\"\n                     \"config.sys.editorMenuBar.showNeighScopeButton\">>>\n    <$button\n        class=<<neighScopeBtnClass>>\n        tooltip=\"Change the neighbourhood scope\"\n        popup=<<qualify \"$:/temp/neighScope\">>>\n      ☀\n    </$button>\n  </$reveal>\n\n  <$reveal type=\"popup\" position=\"below\" state=<<qualify \"$:/temp/neighScope\">> >\n    <div class=\"tc-drop-down\">\n      <div class=\"tmap-list-separator\">Neighbourhood scope</div>\n      <$button class=\"tc-btn-invisible\">None\n        <$action-setfield\n            $tiddler=<<viewRoot>>\n            config.neighbourhood_scope=\"\" />\n      </$button>\n      <$list filter=\"[[1|1 step distance]]\n                     [[2|2 step distance]]\n                     [[3|3 step distance]]\n                     [[4|4 step distance]]\n                     [[5|5 step distance]]\">\n        <$button class=\"tc-btn-invisible\">\n          <<tmap \"splitAndSelect\" \"|\" \"1\">>\n          <$action-setfield\n              $tiddler=<<viewRoot>>\n              config.neighbourhood_scope=<<tmap \"splitAndSelect\" \"|\" \"0\">> />\n        </$button>\n      </$list>\n      <$button class=\"tc-btn-invisible\">No limit\n        <$action-setfield\n            $tiddler=<<viewRoot>>\n            config.neighbourhood_scope=\"100\" />\n      </$button>\n      <div class=\"tmap-list-separator\">Neighbourhood traversal</div>\n      <$radio field=\"config.neighbourhood_directions\" value=\"in\"> Incoming</$radio><br />\n      <$radio field=\"config.neighbourhood_directions\" value=\"out\"> Outgoing</$radio><br />\n      <$radio field=\"config.neighbourhood_directions\" value=\"\"> Both</$radio>\n      <div class=\"tmap-list-separator\">Other</div>\n      <$checkbox field=\"config.show_inter_neighbour_edges\"\n          checked=\"true\" unchecked=\"false\"> Inter-neighbour edges</$checkbox>\n\n    </div>\n  </$reveal>\n\n<!-- === Export menu ============================================ -->\n\n  <$reveal\n      type=\"match\"\n      text=\"true\"\n      default=<<tmap \"option\" \"config.sys.editorMenuBar.showScreenshotButton\">>>\n    <$button tooltip=\"Open the map-export menu\" popup=<<qualify \"$:/temp/mapExport\">>>\n      {{$:/core/images/download-button}}\n    </$button>\n  </$reveal>\n\n  <$reveal type=\"popup\" position=\"below\" state=<<qualify \"$:/temp/mapExport\">>>\n    <div class=\"tc-drop-down\">\n    <$button\n        class=\"tc-btn-invisible\"\n        tooltip=\"Export the graph and all its elements\n                 in form of a JSON file\">\n        {{$:/core/images/permalink-button}} Save as JSON file\n      <$action-sendmessage\n          $message=\"tmap:tm-download-graph\"\n          view=<<viewLabel>> />\n    </$button>\n    <$button\n        class=\"tc-btn-invisible\"\n        tooltip=\"Create a png image to download or save it\n                 as image or view-placeholder in your wiki\">\n        {{$:/core/images/palette}} Save as png image\n      <$action-sendmessage $message=\"tmap:tm-save-canvas\" />\n    </$button>\n    </div>\n  </$reveal>\n\n<!-- === Raster menu ============================================ -->\n\n  <$reveal\n      type=\"match\"\n      text=\"true\"\n      default=<<tmap \"option\" \"config.sys.editorMenuBar.showRasterMenuButton\">>>\n    <$button\n      tooltip=\"Change the raster of your map\"\n      class=<<rasterMenuBtnClass>>\n      popup=<<qualify \"$:/temp/rasterMenu\">>>\n      ⩩\n    </$button>\n  </$reveal>\n\n  <$reveal type=\"popup\" position=\"below\" state=<<qualify \"$:/temp/rasterMenu\">>>\n    <div class=\"tc-drop-down\">\n    <$button class=\"tc-btn-invisible\">Disable raster\n      <$action-setfield\n          $tiddler=<<viewRoot>>\n          config.raster=\"\" />\n    </$button>\n    <div class=\"tmap-list-separator\">Raster sizes</div>\n    <$list filter=\"[[50|50px]]\n                   [[75|75px]]\n                   [[100|100px]]\n                   [[150|150px]]\">\n      <$button class=\"tc-btn-invisible\">\n        <<tmap \"splitAndSelect\" \"|\" \"1\">>\n        <$action-setfield\n            $tiddler=<<viewRoot>>\n            config.raster=<<tmap \"splitAndSelect\" \"|\" \"0\">> />\n      </$button>\n    </$list>\n    </div>\n  </$reveal>\n\n</div>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/misc/focusButton": {
            "title": "$:/plugins/felixhayashi/tiddlymap/misc/focusButton",
            "text": "\\define filter() [list[$:/temp/tmap/nodes/$(viewLabel)$]search:title{$:/temp/tmap/bar/search}]\n\\define concat(str) $str$\n\n\\define state() $(widgetPopupsPath)$/focus\n\n<div class=\"tmap-focus-button\">\n  <$reveal type=\"match\" state=<<state>> text=\"\">\n    <$button\n        tooltip=\"Zoom on a specific node\"\n        class=<<tv-config-toolbar-class>>>{{$:/core/images/advanced-search-button}}\n     <$action-setfield $tiddler=\"$:/temp/tmap/bar/search\" text=\"\" />\n     <$action-setfield $tiddler=<<state>> text=\"1\" />\n    </$button>\n  </$reveal>\n  <$reveal type=\"nomatch\" state=<<state>> text=\"\">\n    <$button\n        tooltip=\"Close zoom popup\"\n        class=<<tv-config-toolbar-class>>>{{$:/core/images/advanced-search-button}}\n     <$action-setfield $tiddler=<<state>> text=\"\" />\n    </$button>\n    <div class=\"tmap-search-dropdown\">\n      <div class=\"tc-drop-down\">\n        <$edit-text\n            focus=\"true\"\n            tiddler=\"$:/temp/tmap/bar/search\"\n            field=\"text\"\n            type=\"text\"\n            tag=\"input\"\n            default=\"\" />\n        <small><$count filter=<<filter>> /> results</small>\n        <hr />\n        <div class=\"tmap-very-small-list\">\n          <$list filter=<<filter>>\n              variable=\"item\"\n              emptyMessage=\"//No results//\">\n            <$button\n                class=\"tc-btn-invisible\"\n                message=\"tmap:tm-focus-node\"\n                param=<<item>>>\n              <$view tiddler=<<item>> field=\"title\" />\n            </$button>\n          </$list>\n        </div>\n      </div>\n    </div>\n  </$reveal>\n</div>"
        },
        "$:/plugins/felixhayashi/tiddlymap/hook/editor": {
            "title": "$:/plugins/felixhayashi/tiddlymap/hook/editor",
            "caption": "Map",
            "tags": "$:/tags/SideBar",
            "text": "\\define width() calc(100% - 15px)\n\n<div class=\"tmap-mobile-editor\">\n  <div class=\"tmap-flash-message tmap-warning\">\n    The editor is not displayed in mobile mode.\n  </div>\n</div>\n<div class=\"tmap-desktop-editor\">\n  <$tiddlymap\n    class=\"tmap-sidebar-map-editor\"\n    editor=\"advanced\"\n    object-id=\"main_editor\"\n    click-to-use=\"false\">\n  </$tiddlymap>\n</div>"
        },
        "$:/plugins/felixhayashi/tiddlymap/hook/liveTab": {
            "title": "$:/plugins/felixhayashi/tiddlymap/hook/liveTab",
            "caption": "Live",
            "text": "\\define width() calc(100% - 15px)\n\n<div class=\"tmap-mobile-editor\">\n  <div class=\"tmap-flash-message tmap-warning\">\n    The live tab is not displayed in mobile mode.\n  </div>\n</div>\n<div class=\"tmap-desktop-editor\">\n  <$set name=\"view\"\n      filter=\"[{$:/temp/tmap/currentTiddler}get[tmap.open-view]]\"\n      emptyValue=<<tmap \"option\" \"config.sys.liveTab.fallbackView\">>>\n  <div>\n    <$tiddlymap\n        view=<<view>>\n        click-to-use=\"false\"\n        refresh-triggers=\"$:/temp/tmap/currentTiddler\"\n        object-id=\"live_tab\">\n    </$tiddlymap>\n  </div>\n  </$set> \n</div>"
        },
        "$:/plugins/felixhayashi/tiddlymap/misc/quickConnectButton": {
            "title": "$:/plugins/felixhayashi/tiddlymap/misc/quickConnectButton",
            "tags": "$:/tags/ViewToolbar",
            "description": "{{$:/language/Buttons/TiddlyMap/Hint}}",
            "caption": "{{$:/plugins/felixhayashi/tiddlymap/icon}} {{$:/language/Buttons/TiddlyMap/Caption}}",
            "text": "\\define buttonClass() $(tv-config-toolbar-class)$ $(additional-classes)$\n\n\\define nonExistentItem()\n<<item>> <span style=\"color: #9E9E9E\">(will be created)</span>\n\\end\n\n\\define noConnectionsMsg()\n<tr><td colspan=\"4\">//No connections found!//</td></tr>\n\\end\n\n\\define normalSearchFilter()\n[!is[system]!has[draft.of]search:title{$:/temp/quickConnectSearch}sortcs[title]limit[50]]\n\\end\n\n\\define regexSearchFilter()\n[!is[system]!has[draft.of]regexp{$:/temp/quickConnectSearch}sortcs[title]limit[50]]\n\\end\n\n\\define showButton(state)\n<$button set=\"$:/temp/tmap/state/popup/quickConnect\"\n         setTo=\"$state$\" tooltip={{$:/language/Buttons/TiddlyMap/Hint}} \n         aria-label={{$:/language/Buttons/TiddlyMap/Caption}}\n         class=<<buttonClass>>>\n<$list filter=\"[<tv-config-toolbar-icons>prefix[yes]]\">{{$:/plugins/felixhayashi/tiddlymap/icon}}</$list>\n<$list filter=\"[<tv-config-toolbar-text>prefix[yes]]\">\n<span class=\"tc-btn-text\"><$text text={{$:/language/Buttons/TiddlyMap/Caption}}/></span>\n</$list>\n</$button>\n\\end\n\n\\define searchResults()\n<td>\n  <$button tooltip=\"Create incoming edge\">\n    <<tmap \"option\" \"misc.arrows.in\">>\n    <$action-sendmessage $message=\"tmap:tm-create-edge\"\n                         from=<<item>>\n                         to=<<currentTiddler>>\n                         force=\"true\"\n                         label={{$:/temp/quickConnectSearch/type}}\n                         view={{$:/temp/quickConnectSearch/view}} />\n  </$button>\n</td>\n<td>\n  <$button tooltip=\"Create outgoing edge\">\n    <<tmap \"option\" \"misc.arrows.out\">>\n    <$action-sendmessage $message=\"tmap:tm-create-edge\"\n                         from=<<currentTiddler>>\n                         to=<<item>>\n                         force=\"true\"\n                         label={{$:/temp/quickConnectSearch/type}}\n                         view={{$:/temp/quickConnectSearch/view}} />\n  </$button>\n</td>\n<td>\n  <$list\n      filter=\"[<item>is[tiddler]]\"\n      emptyMessage=<<nonExistentItem>>>\n    <$view tiddler=<<item>> field=\"title\" />\n  </$list>\n</td>\n\\end\n\n\\define hidePopup()\n<$macrocall $name=\"showButton\" state=<<qualify>> />\n\\end\n\n\\define showPopup()\n<$set name=\"additional-classes\" value=\"tmap-active-button\">\n  <$macrocall $name=\"showButton\" state=\"\" />\n</$set>\n<$set\n    name=\"searchFilter\"\n    filter=\"[field:title[$:/state/tmap/tid-toolbar]has[re-filter]]\"\n    value=<<regexSearchFilter>>\n    emptyValue=<<normalSearchFilter>>>\n<div class=\"tmap-quick-connect tc-reveal tc-popup\">\n  <div class=\"tc-drop-down\">\n    <div class=\"title\">Create connection</div>\n    <table class=\"tmap-quick-connect-search-bar\">\n      <tr>\n        <td>Type:</td>\n        <td>\n          <$edit-text\n              tiddler=\"$:/temp/quickConnectSearch/type\"\n              field=\"text\"\n              type=\"text\"\n              tag=\"input\"\n              default=\"\" />\n          <$select tiddler=\"$:/temp/quickConnectSearch/type\" default=\"\">\n            <option></option>\n            <$list filter=<<tmap \"option\" \"selector.allEdgeTypesById\">>>\n              <option>{{!!title}}</option>\n            </$list>\n          </$select>\n        </td>\n      </tr>\n      <tr>\n        <td>Search:</td>\n        <td>\n          <$edit-text tiddler=\"$:/temp/quickConnectSearch\" type=\"text\" tag=\"input\" default=\"\"></$edit-text>\n          <$checkbox\n              tiddler=\"$:/state/tmap/tid-toolbar\"\n              field=\"re-filter\"\n              checked=\"1\"\n              unchecked=\"\"\n              default=\"\"> regexp\n          </$checkbox>\n<!--\n          <small>(<$count filter=<<searchFilter>> /> results)</small>\n-->\n        </td>\n      </tr>\n      </table>\n      <table class=\"tmap-create-connection-table\">\n      <tr>\n        <td colspan=\"2\">\n          <table class=\"tmap-very-small-list\">\n            <$list\n                filter=<<searchFilter>>\n                variable=\"item\">\n            <tr><<searchResults>></tr>\n            </$list>\n            <tr>\n            <$list filter=\"[{$:/temp/quickConnectSearch}regexp[.+]] -[is[tiddler]]\" variable=\"item\">\n              <<searchResults>>\n            </$list>\n            </tr>\n          </table>\n        </td>\n      </tr>\n    </table>\n    <div class=\"title\">Existing Connections</div>\n    <div class=\"tmap-quick-connect-existing-bar\">\n      <$select\n          tiddler=\"$:/state/tmap/tid-toolbar\"\n          field=\"direction\"\n          default=\"both\">\n          <option value=\"both\">both</option>\n          <option value=\"in\">incoming</option>\n          <option value=\"out\">outgoing</option>\n      </$select>\n      <$checkbox\n          tiddler=\"$:/state/tmap/tid-toolbar\"\n          field=\"filter.links\"\n          checked=\"-[[tw-body:link]]\"\n          unchecked=\"\"\n          default=\"\"> hide links\n      </$checkbox>\n    </div>\n    <table class=\"tmap-connection-table\">\n<!--\n    <tr>\n      <th></th>\n      <th>Tiddler</th>\n      <th>Type</th>\n      <th></th>\n    </tr>\n-->\n    \n    <$tmap-connections\n        filter=<<tmap mergeFields \"$:/state/tmap/tid-toolbar\" \"filter.\">>\n        direction={{$:/state/tmap/tid-toolbar!!direction}}\n        emptyMessage=<<noConnectionsMsg>>>\n      <tr>\n        <td title=<<direction>>><<directionSymbol>></td>\n        <td><$link to=<<neighbour>>><$view field=\"title\" /></$link></td>\n        <td><<edge.type>></td>\n        <td>\n          <$button\n              tooltip=\"Delete this connection\"\n              class=\"tc-btn-invisible\">{{$:/core/images/close-button}}\n            <$action-sendmessage $message=\"tmap:tm-remove-edge\"\n                id=<<edge.id>>\n                from=<<edge.from>>\n                to=<<edge.to>>\n                type=<<edge.type>> />\n          </$button>\n        </td>\n      </tr>\n    </$tmap-connections>\n    </table>   \n  </div>\n</div>\n</$set>\n\\end\n\n<$list filter=\"[all[current]is[tiddler]]\"><$list filter=\"[{$:/temp/tmap/state/popup/quickConnect}prefix<qualify>]\" variable=\"item\" emptyMessage=<<hidePopup>>><<showPopup>></$list></$list>"
        },
        "$:/plugins/felixhayashi/tiddlymap/media/fullscreen.png": {
            "title": "$:/plugins/felixhayashi/tiddlymap/media/fullscreen.png",
            "type": "image/png",
            "text": "iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQffARwOKQxPfTsHAAAEcUlEQVRIx72XX0xTZxjGn+c9JcYQ50qM5RjKkOOG1NQEQiMV1tkLIbLsypCahsTojIkX6kgBr7aG7Wo6ou7STHbnjdGb/Ymb2ABODdiIxKR/IdoeR1PIKJAZdZntLnZq0CEWtHtuzjk57/l+3/e9J8/7fkQB8vv9DIfDHyqK8nEul2sSkS0AzABAMkNyAsBNAD9qmna9t7c397oxudzLXbt2icVi+YxkH0mQ/4YvdRWRxZ/6EonEmcHBweyKwR6P5wCAfhEBSWzatClls9mS27ZtS1dVVc1v3LgxAwDT09PmBw8erI9Go5ZIJFKZSqVUEUE2mwXJg/39/d8XDN63b9+XAD4nie3bt0dbWlpC9fX1eiFpGR8ftwYCAVsoFKoxdumrc+fOffFynLIE9AyAHpLYvXv3yNGjR4dUVV1AgSovL19wOp2Tjx49QiKRqCD5kcPhMAeDwSuvBHs8nq9FxEcSXq93wOPx3MUqZbfbf1+zZs2f0Wi0mmSjw+EoDQaDV/8D9ng8B0ieFBHs37//17a2tjDeUJqmzZSWls6HQiFNUZQmh8ORvH379t3nOW5vb1dMJtPfJLFnz56bHR0dQQDwer3HlhrwwoUL3y5+fl3cpUuXGoaHh3cCQCqVMl28ePGZAICiKMdJwm63R/PQt6m9e/cGbTZbhCRUVT0OACa/3894PN4HAK2traFCVriaHXC5XKFYLLYVQJ/f7z8tsVjMBQBWqzVVV1eno0iqra19qKpqSkSwsLDgEpJtJFFbW5tEkaVpWlJEUFJS0iYkdxrgdLHB1dXVacNenSaS75NEVVXV/EpzW2jO87JarfOGp39gImkWEeS9t5gqKyvLGGCzKV8E/i/lq5jkcrkMSUxPT5uLDZ2dnTWLCEQkIyISFxEkk8n1Lwd6vd5jr3Kl5fSq76amptYbFSsmInKLJOLxuKXYK9Z13WKAbwnJnwAgGo1WFhucTCYrFUUBgJ+loqJimCTS6bR67969imJBJyYmKmZnZ1URgcvlum7q7e3NHT582Aegb3Bw0Ga32x8ulbPVVKfFunPnjk1EkMvlfG63OysAkMlkzhrbvfXy5csNb3u1gUCg4f79+1sB4MmTJ2df6LmOHDlyUETOK4qC9vb2X5qbm6NvAzo2NlYzMDDQShLZbPbQiRMnzr/QgQSDwbEdO3aUkmyKRCJb1q1bN1dZWfnHm0IDgUCr8Sef6unpOblkzzU6Onq1sbHRTLIxEolsefr06bOampqp1UCHhoYabty44Tbyerarq8u3bJc5MjJyxel0liqK0qTrulXX9XfXrl3714YNGwrqNCcnJ63Xrl1zhsPhOsMeT/l8Pl/BDX13d/enAL4zLA4WiyWlaVpi8+bNaVVVF8rKyjJ5G5yZmXknkUhYdF1/b25uTs2fOkge6uzsPL/iI4zf75fHjx93KoryjclkgtGfgSQMI0B+YovvSXbV19efdrvdKz/CvDyBbDbbTPITkjtFRBOR54ZPclJEbgL4weFw/LYcMK9/AFcdm7xTEIntAAAAAElFTkSuQmCC"
        },
        "$:/plugins/felixhayashi/tiddlymap/media/halfscreen.png": {
            "title": "$:/plugins/felixhayashi/tiddlymap/media/halfscreen.png",
            "type": "image/png",
            "text": "iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQffBAgRIDS2XJMlAAAEdklEQVRIx72XX2xTZRjGn+f9TiAEGHYhlMIObut0dGTAQlP2R2e9GUmNN0vYRrkgICEhIeDSdXeaE70SJIKXZNM7bkjmhX+CMgZVM3BpGIHM9nQOtlO0ac3oSiRkxlEvPF0AYXaw+lydnO/L+X3v95687/MSRcgwDMZisdeVUm/l8/kWkjUAHCRBMgvgF5LDAL5yu90/GIaR/69vcqFFv98vTqfzXRE5CQDkP9tF5LF9IjK/Zis0NTV16vLlyw8XDe7s7NxP8jM7KmzcuDHl8XisLVu2pCsrK3Pr1q3LAkAmk3FMTk6uMU3TaZrmplQq5SKJfD4Pkgf6+/s/Lxq8Z8+eDwC8BwDbtm0z29rafm5oaEgWk5YbN27oQ0NDdWNjY7X2zXx45syZ95/cp5580dXVdYpkLwC0tbX9dOTIkYjL5bqHIuV0Ou81NjZO3L9/H5OTkxUk3/D5fI5oNHr+meCurq6PSIYAIBgMDnZ0dFzHc6q+vv7X5cuX/5FIJKpJNnq93pXRaPTCv8CdnZ37ReQ4Sezbt++7QCAQwwvK7Xb/vmrVqtzY2JhbKdXi8/mskZGR6/M53r17t9I07S+SCAQCw3v37o0uBhAMBo8+7f3Zs2c/BYCBgQFvJBJpBoBUKqWdO3duTgBA07RjJLF161ZzsdBi1N7eHq2rq4uLCDZs2HAMAGgYBhOJxEMACIfDX2zfvj35oqDCDRQiBoBYLFbR19fXDgBlZWUipmm2AoCu66mlgD5LHo/njsvlSimlkMvlWkVEAiICj8djocSqqamxSGLZsmUBIdlsnyhdanBVVVVaRCAiTRqAV0QElZWVuaUCPJrbR6Xres6u6a9qIuIgiULtLaXKy8uzSikAcGiFJvB/ab7DAciKCDKZjKPU0Lt37zrsHGeF5DhJWJa1ZqkAwWDw6NOqWSqVWmPfcEJE5ApJjI+PO0sdcTKZdNoRXxGSX5OEaZqbSg22LGuT3aO/EV3XvyeJdDrtunnzZkWpoBMTExXT09MuEUFra+sPmmEY+UOHDoVInoxEInX19fV3nrc2L6Rr167ViQjy+XzI7/c/FADIZrOnASAej28eGBjwLnW0Q0ND3tu3b28midnZ2dOPea7Dhw8fEJF+pRQ6Ojq+bWlpMZcCOjo6Wjs4OLjLNoAHe3t7+x9zINFodHTnzp0rRaQlHo/XrF69ekbX9ekXhV66dGmXbX9PhMPh40/1XCMjIxeampocJBvj8XjN7OzsXG1t7W/PA41EIt7h4eE37UhP9/T0hBZ0mVevXj3f3Ny8UinVYlmWnkwmX1qxYsWfa9euLcpp3rp1S7948WJTPB5vsMvjiVAoFCra0IfD4XdI9hWmhPXr16eqq6unqqqq0i6X6155eXnW/jEdmUymzLIsZzKZfHlmZsZVqMkkD3Z3d/cveoQxDEMePHjQLSIfa5oGkrArz/wYU3guNBu7+/Ts2LHjE7/fv/gR5skDzM3NvSYibwNoVkq5STqUUiCZJTmhlBrO5/Nf+ny+HxcCFvQ3ae6MHdgDqpkAAAAASUVORK5CYII="
        },
        "$:/plugins/felixhayashi/tiddlymap/icon": {
            "title": "$:/plugins/felixhayashi/tiddlymap/icon",
            "tags": "$:/tags/Image",
            "text": "<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"\n   class=\"tc-image-tiddlymap-button tc-image-button\"\n   version=\"1.1\"\n   width=\"22pt\"\n   height=\"22pt\"\n   viewBox=\"0 0 128 128\">\n  <defs\n     id=\"defs4\">\n    <marker\n       refX=\"0\"\n       refY=\"0\"\n       orient=\"auto\"\n       id=\"Arrow1Lend\"\n       style=\"overflow:visible\">\n      <path\n         d=\"M 0,0 5,-5 -12.5,0 5,5 0,0 z\"\n         transform=\"matrix(-0.8,0,0,-0.8,-10,0)\"\n         id=\"path3850\"\n         style=\"fill-rule:evenodd;stroke:#000000;stroke-width:1pt\" />\n    </marker>\n    <marker\n       refX=\"0\"\n       refY=\"0\"\n       orient=\"auto\"\n       id=\"Arrow1Lstart\"\n       style=\"overflow:visible\">\n      <path\n         d=\"M 0,0 5,-5 -12.5,0 5,5 0,0 z\"\n         transform=\"matrix(0.8,0,0,0.8,10,0)\"\n         id=\"path3847\"\n         style=\"fill-rule:evenodd;stroke:#000000;stroke-width:1pt\" />\n    </marker>\n    <inkscape:path-effect\n       effect=\"skeletal\"\n       id=\"path-effect4329\" />\n    <inkscape:path-effect\n       effect=\"skeletal\"\n       id=\"path-effect4321\" />\n    <inkscape:path-effect\n       effect=\"skeletal\"\n       id=\"path-effect4315\" />\n    <inkscape:path-effect\n       effect=\"skeletal\"\n       id=\"path-effect4307\" />\n    <inkscape:path-effect\n       effect=\"skeletal\"\n       id=\"path-effect4299\" />\n    <inkscape:path-effect\n       effect=\"skeletal\"\n       id=\"path-effect4293\" />\n  </defs>\n  <g\n     transform=\"translate(0,-1024.5289)\"\n     id=\"layer1\">\n    <path\n       d=\"m 17.867073,4.5821643 a 3.7249374,3.7249374 0 1 1 -7.449875,0 3.7249374,3.7249374 0 1 1 7.449875,0 z\"\n       transform=\"matrix(-6.3328802,0,0,6.2775831,193.9581,1100.3667)\"\n       id=\"path4139-1-14\"\n       style=\"fill-opacity:1;fill-rule:nonzero\" />\n    <path\n       d=\"M 77.450496,1064.5069 C 58.849552,1025.9634 15.704158,1023.3858 2.8821873e-7,1034.558 L 0.02388589,1035.2674 C 24.502636,1022.2072 44.810725,1042.1507 60.163934,1074.112 z\"\n       id=\"path4337\"\n       style=\"fill-opacity:1;stroke-width:0.58181816;stroke-miterlimit:4;stroke-dasharray:none;marker-start:none;marker-end:none\" />\n    <path\n       d=\"m 12.878637,11.280739 4.75937,-2.7478243 4.759371,-2.7478236 0,5.4956479 0,5.495648 -4.759371,-2.747824 z\"\n       transform=\"matrix(4.6545455,0,0,4.6545455,-13.580429,1027.7638)\"\n       id=\"path3004\"\n       style=\"fill-opacity:1;fill-rule:nonzero\" />\n  </g>\n  <metadata\n     id=\"metadata3772\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:title></dc:title>\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n</svg>\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/media/surface.png": {
            "title": "$:/plugins/felixhayashi/tiddlymap/media/surface.png",
            "type": "image/png",
            "text": "iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAGYktHRAAmALMAAQfdEQQAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfeDBYVBDLiNMeiAAAFvUlEQVRIx7WXbUxTZxTH/+c8VwQLlAKuEotF2mJRlMFEqeCUiMzojH7YEjMSlM1EY2Z04vbBbUrcZqbOTZfFOKMOcWRuZMyoS4xUN16EMUVUMkAFJ6VQkdFSoOIL9O5DBREFX/l/vOf+z+88z715znkITyMZZMjDTLfEC0iWE0hAD0DlZhkC7HCDagWoxA0cvzq/uwgE+UkpachoJjhiCta6mXYwATLfN7AnM923MzGIuC8hARn/lN3ZiUy4nxlsyEM6QAcgPECdb6TNFDTbMn10UnOkMsap9dE5AMDSVaeqdlYoz9qL1WftReOuuS6HMDHcshsEfrdyXscPTw3W/cabieRPmYAEdcrltLD3q2ar32x4mq9S2HIi9LBl78QzracnMDEI9FlFin3jE8G6PN5JLK9hAt4Zv6ps0+TvyvAc+rLmo+m5DfungwhEvKs8uWVt/7h4CPorb2VJzmACPpy01bzO+MUFPKcSg+c2+kijOs85zoQTKF6TplA0ZrvyHwEb8pAOgW0kgE8m7zyZHr6uGi+o6IDpLQEjAp1/tZ7WMUkJY5f6WRqzOy48AP8CETSCylkAS3VrS1YbNl7CS9IkZcx/rm5XT1XHxVBBvCh+gfPzqlzIDAD6kVgDBhJGp1z+OPLrc3jJWhOx6ZwpKKmGiGEL1q4BAIYMYqYdBCBt/OoqDJPeGpteJZEEiUfsgAxi/TG8DgAG/yjb7FcWNAwXOD5oljVcMcEmSELSH/rXmYjngwnTgmZZHmeIPaFcPlTCJ8UH/GwWIoYkjZzPRDSDQJgWNKt54Is513drb3W7vIdK5uru9BkslnN9t3amWZPaB/aPaxYQYBImBsFAxJiojHEONB6u/z5mpPC+N1jihQXRi72Fz92hCrPfaQnIub5bCwB6/ygnEYNBEczEKiLGuPtnb3/dvN2o8mbvQRO33WtVyPLgjWhP7ZbEcF9jY74tzwAAY701DokkCJJU7KmAHzEtK01OjvR/tcFLeN/trXjganUKY7PSS9X5uPiMk2PSetzdYol2RUWdq0b94JD2dDKGDAcRw9pVp+pvAoAsk9m8Ur+heE/tlsSB367tXqsiy2Q26xTG5t4V9fdH+EU1laTcyE4NW1Xffq/Nd2FB9GLbbatKIgFBwiEJ4qtMrK5uv6TU+OgcM82aVIPfpKYsk9kMAKlhq+pTw1bVx55QLldIfl06hbG5zlWjLkq25vQWN9OsSV1YEL14iXZFRb4tzxDhF9XnB4CYgPg6ALjmqlF61oorDOZSAqPcUaoGgJX6DcUHTafMA7fu/DznvpX6DcUyZPRCe1WUbM0J9Aru3FO7JVGGjP7Q3uKyTGZzVUelmjxbXUqTT/rOkmTpT51vpC13RkkuhlHrK5e93XCrPkR298zmyrmdhTIR/r1VG3KmJV8zXNCKtjJNU5c1RJDAJNOcIgZBJlAGg/Czdf/E4QKbbx6dyCQgwBmZlOn2dKc2+y4AOGsvMn57ZfPUlw3NseydeslZbiQQ7tQH7Orrx1W5kEPTfBuIeFF158XQwJHBbUa/6NaXAT118/iEvKZDSUwCIHn5TylHyx+aQBoPuSpC05QKJk4osxfqVV7BbUa/Ka0vCs1p2PsGEwPg7dlxv2977MxlzW7PH7dMpSJQ/Fl7of5Wj6snLjCx6Xmgh60Hph5pykliYshw78qKO5Yx6LAHAJaDbSfC0gMVTFJCTcel0MsdlQF+kv/dsT7a9qcBXnT+HfqjZY+pzF4Q4xlvsf3A1IehQw70cwoi3yPQPkECRIzxowy2aOW0+skBsc3higntY7w1DgC4cbtRZem65l/dflFd01GpvXnHFkIgeMZaWr4v9sj+Z77CZMrg0sKoD4jFV17sBYAgSAITQ5Dk2TLP2QuA+p4TaP2412K/yaTMZ7/CDCzgfElcIhEvJNAMiSQdEasESSBiB4PrBIsSctOx8XHTiocC9up/PG8QrAaKLngAAAAASUVORK5CYII="
        },
        "$:/language/Buttons/TiddlyMap/Caption": {
            "title": "$:/language/Buttons/TiddlyMap/Caption",
            "text": "tiddlymap"
        },
        "$:/language/Buttons/TiddlyMap/Hint": {
            "title": "$:/language/Buttons/TiddlyMap/Hint",
            "text": "Toggle TiddlyMap actions"
        },
        "$:/plugins/felixhayashi/tiddlymap/misc/macros": {
            "title": "$:/plugins/felixhayashi/tiddlymap/misc/macros",
            "text": "\\define concat(str) $str$\n\n\\define input-text(field, index, default, readonly, class, focus)\n  <$reveal type=\"match\" text=\"\" default=\"$readonly$\">\n    <$edit-text\n        tiddler=<<output>>\n        field=\"$field$\"\n        index=\"$index$\"\n        type=\"text\"\n        tag=\"input\"\n        default=\"$default$\"\n        focus=\"$focus$\"\n        class=\"$class$\" />\n  </$reveal>\n  <$reveal type=\"nomatch\" text=\"\" default=\"$readonly$\">\n    <input type=\"text\" value=\"$default$\" readonly=\"true\" disabled=\"true\" />\n  </$reveal>\n\\end\n\n\\define input-button(field, index, default, default, label:\"Proceed\")\n  <div class=\"tmap-button-wrapper\">\n  <$button>$label$\n    <$action-setfield $tiddler=<<output>> $field=\"$field$\" index=\"$index$\" $value=\"$default$\" />\n  </$button>\n  </div>\n\\end\n\n\\define input-textarea(field, index, default, default, class, focus)\n  <$edit-text\n      tiddler=<<output>>\n      field=\"$field$\"\n      index=\"$index$\"\n      autoHeight=\"no\"\n      type=\"text\"\n      tag=\"textarea\"\n      default=\"$default$\"\n      class=\"$class$\"\n      focus=\"$focus$\" />\n\\end\n\n\\define input-checkbox(field, index, readonly, default)\n  <$reveal type=\"match\" text=\"\" default=\"$readonly$\">\n    <$checkbox\n        tiddler=<<output>>\n        field=\"$field$\"\n        index=\"$index$\"\n        checked=\"true\"\n        unchecked=\"false\"\n        default=\"$default$\" />\n  </$reveal>\n  <$reveal type=\"nomatch\" text=\"\" default=\"$readonly$\">\n    <input type=\"checkbox\" value=\"$default$\" readonly=\"true\" disabled=\"true\" />\n  </$reveal>\n\\end\n\n\\define input-multi-checkbox(selectFilter, invert:\"no\", default)\n  <div class=\"tmap-no-stretch\">\n  <$list\n      filter=\"$selectFilter$\"\n      emptyMessage=\"– This list contains no items –\">\n    <$checkbox\n        tiddler=<<output>>\n        tag=<<tmap \"splitAndSelect\" \"|\" \"0\">>>\n      <$view\n          tiddler=<<tmap \"splitAndSelect\" \"|\" \"1\">>\n          field=\"title\" />\n    </$checkbox><br />\n  </$list>\n  </div>\n\\end\n\n\\define input-select(field, index, selectFilter, default, nochoice)\n  <$select\n      tiddler=<<output>>\n      field=\"$field$\"\n      index=\"$index$\"\n      default=\"$default$\">\n    <$set name=\"nochoice\" value=\"$nochoice$\">\n      <$list filter=\"[<nochoice>regexp[.+]]\">\n        <option value=\"\"><b><<nochoice>></b></option>\n      </$list>\n    </$set>\n    <$list filter=\"$selectFilter$\">\n      <option value=<<tmap \"splitAndSelect\" \"|\" \"0\">> >\n        <$view tiddler=<<tmap \"splitAndSelect\" \"|\" \"1\">> field=\"title\" />\n      </option>\n    </$list>\n  </$select>\n\\end\n\n\\define input-radio(field, index, selectFilter, default)\n  <$list filter=\"$selectFilter$\">\n    <$radio\n        tiddler=<<output>>\n        field=\"$field$\"\n        index=\"$index$\"\n        value=<<tmap \"splitAndSelect\" \"|\" \"0\">>>\n      <<tmap \"splitAndSelect\" \"|\" \"1\">>\n    </$radio><br />\n  </$list>\n\\end\n\n\\define tmap-row(title, field, index, type, descr, note, label, default, readonly, reset, selectFilter, nochoice, invert, class, focus)\n  <tr>\n    <td class=\"tmap-title\">$title$:</td>\n    <td>\n        <<$type$\n          field:\"$field$\"\n          index:\"$index$\"\n          readonly:\"$readonly$\"\n          default:\"$default$\"\n          label:\"$label$\"\n          invert:\"$invert$\"\n          selectFilter:\"$selectFilter$\"\n          nochoice:\"$nochoice$\"\n          focus:\"$focus$\"\n          class:\"$class$\">>\n        <$reveal type=\"match\" text=\"true\" default=\"$reset$\">\n          <$button>reset\n            <$action-setfield $tiddler=<<output>> $field=\"$field$\" $index=\"$index$\" $value=\"$default$\" />\n          </$button>\n        </$reveal>\n    </td>\n    <td>\n      <span class=\"tmap-description\">$descr$</span>\n      <$reveal type=\"nomatch\" text=\"\" default=\"$note$\">\n        <div class=\"tmap-note\">''Note:'' $note$</div>\n      </$reveal>\n    </td>\n  </tr>\n\\end\n\n\\define visConfiguration(inheritedList, extensionField, styleName:\"style\")\n  <fieldset><legend>Visjs configurations ($styleName$)</legend>\n    <div class=\"tmap-flash-message tmap-info\">\n      Only config items that you actually changed have an effect on\n      the graph. Other options are visible, yet, inactive.\n    </div>\n    <$tmap-config\n        mode=\"manage-node-types\"\n        inherited=\"$inheritedList$\"\n        extension=\"$extensionField$\" />\n  </fieldset>\n\\end\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/misc/defaultViewHolder": {
            "title": "$:/plugins/felixhayashi/tiddlymap/misc/defaultViewHolder",
            "text": "Default"
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/nodeTypes/tmap:central-topic": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/nodeTypes/tmap:central-topic",
            "description": "The style is applied to the node that you marked as central topic in a map.",
            "style": "{\"font\":{\"size\":22,\"color\":\"rgba(0,0,0,1)\"},\"shape\":\"star\"}"
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/nodeTypes/tmap:neighbour": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/nodeTypes/tmap:neighbour",
            "description": "Neighbours are all nodes that are not part of the original set of nodes (\"matches\") but are connected (either outgoing or incoming) to a node of the original set.",
            "style": "{\"color\":\"#565656\"}"
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/views/Default/filter/edges": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/views/Default/filter/edges"
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/views/Default/filter/nodes": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/views/Default/filter/nodes"
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/views/Default": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/views/Default",
            "config.physics_mode": "false",
            "isview": "true"
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/views/Live View/filter/edges": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/views/Live View/filter/edges",
            "filter": "[prefix[$:/plugins/felixhayashi/tiddlymap/graph/edgeTypes]]",
            "text": "\n\n"
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/views/Live View/filter/nodes": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/views/Live View/filter/nodes",
            "filter": "[field:title{$:/temp/tmap/currentTiddler}]"
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/views/Live View": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/views/Live View",
            "config.neighbourhood_scope": "1",
            "config.refresh-triggers": "$:/temp/tmap/currentTiddler",
            "config.physics_mode": "true",
            "config.vis": "{\"physics\":{\"forceAtlas2Based\":{\"springLength\":0,\"springConstant\":0.09}}}",
            "isview": "true"
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/views/Graph search/filter/nodes": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/views/Graph search/filter/nodes",
            "filter": "[!is[system]search{$:/temp/search}] [!is[system]search:tags{$:/temp/search}] [!is[system]search:text{$:/temp/search}limit[10]]"
        },
        "$:/plugins/felixhayashi/tiddlymap/graph/views/Graph search": {
            "title": "$:/plugins/felixhayashi/tiddlymap/graph/views/Graph search",
            "config.refresh-triggers": "$:/temp/search",
            "config.neighbourhood_scope": "1",
            "config.physics_mode": "true"
        }
    }
}