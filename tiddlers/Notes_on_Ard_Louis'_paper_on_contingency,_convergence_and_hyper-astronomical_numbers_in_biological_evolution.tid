created: 20160308192539512
creator: guillefix
modified: 20161104134331132
modifier: guillefix
title: Notes on Ard Louis' paper on contingency, convergence and hyper-astronomical numbers in biological evolution
tmap.id: cb919384-dca2-40d9-9f45-5ed7779cea75
type: text/vnd.tiddlywiki

Modern synthesis
1. Variation unbiased
2. Space of possible genotypes very vast (even after discarding biologically unviable ones). Evolution is contingent. C.f genetic drift.

However,
*Contingency in genotype space does not imply contingency in phenotype space => convergent evolution

*Genetic code (mapping from codons to aminoacids) has redundancy. Mackay suggested this could have arrived because it was fittest code. However, evolving the code is very costly (as it would affect many proteins at one) so probably very unlikely. Thus, Crick proposed it was a "frozen accident".
*Neutral theory of evolution.
*pre-Darwinian evolution of genetic code. Optimized for error reduction

Protein coding
Hoyle-Salisbury paradox. How can evolution find right proteins in hyperastronomically large space?
Maynard Smith argument
Keefe and Szostak computer experiments

Levinthal's paradox

Redundancy, correlaton, and funnel-shapped landscapes

RNA case study

When talking about the word game, word probability incorrectly used

For self assembling system the many to one map is from cluster configurations (like genotype) to physically distinct systems (like phenotype). However self assembly explores the phenotype space uniformly and thus shows a bias in the genotype space, and it's a bias against simplicity and symmetry.

Algorithm information theory....
For fixed length codes, simple codes have many ways of appearing

Fixed code lengths means we have a finite state machine. Algorithmic complexity for finite state machines?

~~The formula given in the slide of Solomonoff is not a probability, but an expected number of times a certain program will come up, that's why it's not normalized. For long codes, it's approximately a probability, though~~. No

Feed fixed input length codes with a short pefix corresponding to the map (the conditon of it being short, in particular much shorter than the inputs, could be the quantitiative condition corresponding to Ard's observation that the map should be "simple"). Then feed this to a Turing Machine (TM). Results will be of varying length. You expect shorter lengths to be more common because:
Input to the TM is approximately like feeding random fixed-length codes (because prefix code is much shorter than input, by assumption, and inputs are random).
If we reverse the TM, hmm no it doesn't work. Well the output will be an input that produces a fixed-length string of bits for the reversed TM, but the distribution in outputs is not random now?
Are there more fixed length strings that will produce shorter codes? Seems unlikely. But im missing he many to one nature of the mapping in this description. Or hmmmm the little prefix code should make this happen somehow? What kind of "prefix codes" can do this?