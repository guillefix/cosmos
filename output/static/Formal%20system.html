<p>&lt;p&gt;A &lt;strong&gt;Formal system&lt;/strong&gt; is a &lt;a class=&quot;tc-tiddlylink tc-tiddlylink-resolves&quot; href=&quot;#Set&quot;&gt;Set&lt;/a&gt; of rules you can apply to a set of objects.&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;tc-tiddlylink tc-tiddlylink-resolves&quot; href=&quot;#Formal%20language&quot;&gt;Formal language&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;tc-tiddlylink-external&quot; href=&quot;https://en.wikipedia.org/wiki/Formal_grammar&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Formal_grammar&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;tc-tiddlylink tc-tiddlylink-resolves&quot; href=&quot;#Formal%20systems%20and%20semantics&quot;&gt;Formal systems and semantics&lt;/a&gt;&lt;/p&gt;&lt;p&gt;MU-puzzle&lt;/p&gt;&lt;h2 class=&quot;&quot;&gt;&lt;u&gt;Rewrite systems&lt;/u&gt;&lt;/h2&gt;&lt;p&gt;The most common type of formal system. (Are there other types actually?)&lt;/p&gt;&lt;p&gt;&lt;u&gt;(Abstract) Rewrite systems&lt;/u&gt;&lt;/p&gt;&lt;p&gt;A set of objects, and a binary operation, &lt;span&gt;&lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;→&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;\rightarrow&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&quot;katex-html&quot; aria-hidden=&quot;true&quot;&gt;&lt;span class=&quot;strut&quot; style=&quot;height:0.36687em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;strut bottom&quot; style=&quot;height:0.36687em;vertical-align:0em;&quot;&gt;&lt;/span&gt;&lt;span class=&quot;base textstyle uncramped&quot;&gt;&lt;span class=&quot;mrel&quot;&gt;→&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;, that tells us how we are allowed to transforms expressions. If these rules act on &lt;em&gt;terms&lt;/em&gt; out of which an expression can be built, then this is a term rewrite system.&lt;/p&gt;&lt;p&gt;They are non-deterministic Markov algorithms, and they are Turing complete. They are related to normal forms, lambda calculus, and combinatory logic&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;tc-tiddlylink-external&quot; href=&quot;http://www.cs.tau.ac.il/~nachum/papers/survey-draft.pdf&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;http://www.cs.tau.ac.il/~nachum/papers/survey-draft.pdf&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Initial strings in a formal theorem are called &lt;em&gt;axioms&lt;/em&gt;, while any string producible by its rules are konwn as &lt;em&gt;theorem&lt;/em&gt;s.&lt;/p&gt;&lt;p&gt;The rules themselves are knwon as production rules or rules of inference.&lt;/p&gt;&lt;p&gt;A series of production rules that leads to a theorem is known as a derivation of that theorem.&lt;/p&gt;&lt;h3 class=&quot;&quot;&gt;&lt;u&gt;Decision procedure and &lt;a class=&quot;tc-tiddlylink tc-tiddlylink-missing&quot; href=&quot;#Decidable&quot;&gt;Decidability&lt;/a&gt;&lt;/u&gt;&lt;/h3&gt;&lt;p&gt;A &lt;strong&gt;decision procedure&lt;/strong&gt; is a &lt;a class=&quot;tc-tiddlylink tc-tiddlylink-missing&quot; href=&quot;#Computable&quot;&gt;Computable&lt;/a&gt; procedure (i.e. one that is guaranteed to finish in a finite amount of time) that determines whether a theorem will be reached by the production rules of the formal system, or not.&lt;/p&gt;&lt;p&gt;A theorem is &lt;a class=&quot;tc-tiddlylink tc-tiddlylink-missing&quot; href=&quot;#Decidable&quot;&gt;Decidable&lt;/a&gt; if it has a decision procedure for it.&lt;/p&gt;&lt;p&gt;The axioms must always be decidable. Their decision procedure is often in the form of an &lt;em&gt;axiom schema&lt;/em&gt;, with substitutable variables which are clearly defined.&lt;/p&gt;&lt;p&gt;Formal systems with only &lt;em&gt;lengthening&lt;/em&gt; rules always have a decision procedure for all strings. See page 48 of GEB.&lt;/p&gt;&lt;p&gt;See &lt;a class=&quot;tc-tiddlylink tc-tiddlylink-resolves&quot; href=&quot;#Computability%20theory&quot;&gt;Computability theory&lt;/a&gt;&lt;/p&gt;</p>