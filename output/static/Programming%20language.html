<p><u>Interpreted programming language</u></p><p>Interpreted at runtime, limited optimization</p><p><u>Compiled programming language</u></p><p>Compiled into machine code. Much more powerful optimization</p><h3 class=""><u>Programming language paradigms</u></h3><p><a class="tc-tiddlylink-external" href="https://en.wikipedia.org/wiki/Programming_paradigm" rel="noopener noreferrer" target="_blank">Programming paradigms</a></p><p><strong>Imperative</strong>: give instructions to change the state of the program</p><p><strong>Declarative</strong>: just write statements (assertions) of what things do, what functions do they perform. Then the program can take inptus and give outputs by passing inputs through the various nested functions (<a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Functional%20programming">Functional programming</a>).</p><p><b><a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Visual%20programming%20language">Visual programming language</a>s</b> Nice example: <a class="tc-tiddlylink-external" href="https://vvvv.org/" rel="noopener noreferrer" target="_blank">https://vvvv.org/</a></p><p><strong>Database-based programming</strong>: Nice example: <a class="tc-tiddlylink tc-tiddlylink-missing" href="#Eve%20language">Eve language</a>!</p><hr><p>Most programming languages are context-free. <a class="tc-tiddlylink-external" href="http://stackoverflow.com/questions/898489/what-programming-languages-are-context-free" rel="noopener noreferrer" target="_blank">http://stackoverflow.com/questions/898489/what-programming-languages-are-context-free</a>. See <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Theory%20of%20computation">Theory of computation</a></p><h2 class=""><u>Programming languages</u></h2><h3 class=""><a class="tc-tiddlylink tc-tiddlylink-resolves" href="#C%2FC%2B%2B">C/C++</a></h3><h3 class=""><a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Python%20(programming%20language)">Python</a></h3><h3 class=""><a class="tc-tiddlylink tc-tiddlylink-resolves" href="#JavaScript">JavaScript</a></h3><p><a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Assembly%20(programming%20language)">Assembly (programming language)</a></p><hr><p>Other languages</p><p>Go, Lisp, Clojure, </p><p><a class="tc-tiddlylink-external" href="https://www.rust-lang.org/" rel="noopener noreferrer" target="_blank">https://www.rust-lang.org/</a></p><p><a class="tc-tiddlylink-external" href="https://esolangs.org/wiki/Main_Page" rel="noopener noreferrer" target="_blank">Esoteric programming languages</a></p><hr><h1 class=""><u>Programming language design</u></h1><p>Continuing previous post.
I don't want programming languages, I want programmable environments. The idea is to have an environment which implements a Hofstadter-like strange loop, where the usually-assumed hierarchy of sourceCode -&gt; data/program, folds back on itself, and you just have one thing; whatever you want to call it: visual self-programming environment, self-modifying code, code as data (LISP), etc.
Bret Victor has explored this, but I think this idea needs to be more mainstream.</p><p>Some visual programming languages go some way in this direction, but none seem really satisfying.
An example of one that doesn't feel satisfying is VVVV. I was just checking it, and you just program, by building a graph, which when &quot;compiled&quot; produces your program. The problem with this, is that it doesn't bootstrap as the idea above does. The kind of graph is always the same, and all your nice software and design ideas that you keep having are only manifested in the products; it doesn't feed back!
Damn I wished I knew more computer science to try experiment with these things.. Although I guess it's not too late to learn.</p>