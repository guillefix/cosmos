<p>&lt;p&gt;&lt;a class=&quot;tc-tiddlylink-external&quot; href=&quot;https://mitpress.mit.edu/sicp/full-text/book/book.html&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://mitpress.mit.edu/sicp/full-text/book/book.html&lt;/a&gt; . A famous &lt;a class=&quot;tc-tiddlylink tc-tiddlylink-resolves&quot; href=&quot;#Programming&quot;&gt;Programming&lt;/a&gt; book using &lt;a class=&quot;tc-tiddlylink tc-tiddlylink-missing&quot; href=&quot;#Lisp&quot;&gt;Lisp&lt;/a&gt;&lt;/p&gt;&lt;p&gt;three foci of phenomena: the human mind, collections of computer programs, and the computer.&lt;/p&gt;&lt;p&gt;&lt;small&gt;It is not merely a matter of tactical convenience to separately identify the three foci. Even though, as they say, it's all in the head, this logical separation induces an acceleration of symbolic traffic between these foci whose richness, vitality, and potential is exceeded in human experience only by the evolution of life itself. At best, relationships between the foci are metastable. The computers are never large enough or fast enough. Each breakthrough in hardware technology leads to more massive programming enterprises, new organizational principles, and an enrichment of abstract models. Every reader should ask himself periodically &amp;quot;Toward what end, toward what end?&amp;quot; â€“ but do not ask it too often lest you pass up the fun of programming for the constipation of bittersweet philosophy.&lt;/small&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;We are about to study the idea of a &lt;strong&gt;computational process&lt;/strong&gt;. Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called &lt;strong&gt;data&lt;/strong&gt;. The evolution of a process is directed by a pattern of rules called a program. People create programs to direct processes. In effect, we conjure the spirits of the computer with our spells.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;u&gt;&lt;a class=&quot;tc-tiddlylink-external&quot; href=&quot;https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Elements of programming&lt;/a&gt;&lt;/u&gt;&lt;/p&gt;&lt;p&gt;An &lt;strong&gt;environment&lt;/strong&gt;: It should be clear that the possibility of associating values with symbols and later retrieving them means that the interpreter must maintain some sort of memory that keeps track of the name-object pairs. This memory is called the environment (more precisely the global environment, since we will see later that a computation may involve a number of different environments).&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;primitive expressions&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;means of combination&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;means of abstraction&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;See quote by &lt;a class=&quot;tc-tiddlylink tc-tiddlylink-resolves&quot; href=&quot;#John%20Locke&quot;&gt;John Locke&lt;/a&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Numbers and arithmetic operations are primitive data and procedures.&lt;/li&gt;&lt;li&gt;Nesting of combinations provides a means of combining operations.&lt;/li&gt;&lt;li&gt;Definitions that associate names with values provide a limited means of abstraction.&lt;/li&gt;&lt;/ul&gt;&lt;hr&gt;&lt;p&gt;&lt;a class=&quot;tc-tiddlylink-external&quot; href=&quot;https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.4&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;&lt;/p&gt;</p>