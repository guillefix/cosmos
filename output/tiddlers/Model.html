<p>A <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#System">System</a>, often a <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Mathematics">mathematical</a> or <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Computer%20science">computational</a> one, that <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Simulation">simulates</a> another system, i.e. it represents features of the original system, both structural, and behavioural.</p><hr><p><a class="tc-tiddlylink-external" href="https://pdfs.semanticscholar.org/1123/579e01563e7732fd91cfd4afa029c4fdbd50.pdf" rel="noopener noreferrer" target="_blank">See these notes on computer graphics</a>: </p><blockquote><p>In <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Computational%20mathematics">Computational mathematics</a> a very useful abstraction paradigm consists of devising four abstraction levels, called universes: the physical universe, the mathematical universe, the representation universe and the implementation universe (Figure 1.4). </p><p>The physical universe contains the objects from the real (physical) world which we intend to study; the mathematical universe contain the abstract mathematical description of the objects from the physical world; the representation universe contains discrete descriptions of the objects from the mathematical universe; and the implementation universe contains data structures and machine models of computation so that objects from the representation universe can be associated with algorithms in order to obtain an implementation in the computer.</p><p>Note that using this paradigm we associate to each object from the real (physical) world three mathematical models: a continuous model in the mathematical universe, a discrete model in the representation universe and a finite model in the implementation universe. This abstraction paradigm is called the four-universe paradigm (Gomes &amp; Velho, 1995).</p></blockquote><p>Basically, we go from the physical world back to the physical world, going through a peak of abstraction reached at the mind..</p><blockquote><p>The modeling process consists in choosing an object from the physical world, associate to it a mathematical model, discretize it and implement it. This implementation should provide solutions to properly posed problems involving the initial physical object. Note that the loss of information we mentioned above is a critical factor in this chain.</p></blockquote><hr><p>In <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Reinforcement%20learning">Reinforcement learning</a>, a model is a method for calculating next states and rewards, given a current state and action. It can be:</p><ul><li><strong>Distribution model</strong>: consists of the probabilities of next states and rewards for possible actions, given current state.</li><li><strong>Sample model</strong>: produces single transitions and rewards generated according to these probabilities. </li></ul><p><a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Dynamic%20programming">Dynamic programming</a> methods require a distribution model because it uses <a class="tc-tiddlylink tc-tiddlylink-missing" href="#Full%20backup">Full backup</a>s. A sample model is what is needed to simulate interacting with the environment during which sample backeups, like those used by many <a class="tc-tiddlylink tc-tiddlylink-resolves" href="#Model-free%20reinforcement%20learning">Model-free reinforcement learning</a> algorithms can be used. Sample models are generally much easier to obtain than distribution models.</p>